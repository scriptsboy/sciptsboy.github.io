[{"title":"基于 MIME 类型的服务端推送","date":"2018-07-03T15:12:03.000Z","path":"20180703/multipart-x-mixed-replace.html","text":"目前就职于视听行业相关的公司，故而需要接触流媒体传输相关技术。今天介绍一种基于 MIME 类型的服务端流媒体推送实现。multipartMIME 类型由类型和子类型组成：Content-Type: [type]/[subType]，前者是数据大类别，后者是具体的种类。multipart 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据。也就是一个消息可以包含多个消息体。我们常见的一般是表单相关的 multipart/form-data，当我们需要在提交表单时上传文件，就需要设置这个类型。电子邮件中使用的类型是 multipart/alternative，包含纯文本（text/plain）和 HTML（text/html）两种数据。其他相关的可以看看 维基百科 MIME#Content-Typex-mixed-replacemultipart/x-mixed-replace 是 Netscape 在 1995 年引入的。与其他的 multipart 子类型相比，新的消息体会覆盖前一个消息体，而不是累加。报文格式如：Content-type: multipart/x-mixed-replace; boundary=--myBoundary--myBoundaryContent-Type: image/pngContent-length: 100stream1...--myBoundaryContent-Type: image/pngContent-length: 100stream2...--myBoundaryboundary 用来指定一个边界符，用于分割多个消息体，多个消息体之间隔一行。可以指定为任意字符，但为了避免消息体中包含了该字符，尽量复杂一些。要实现服务器推送，就是不发送完整的报文，始终发送新的消息体。这样会使 HTTP 连接得到保持，服务器就可以按一定的频率持续推送数据。而 multipart/x-mixed-replace 类型的报文是没有结尾的，一旦客户端连接，将可以永远保持连接。客户端的运行策略为：客户端连接后，获取到第一段消息体并显示。之后发现下一段消息体的边界符，就认为第一段消息体已结束，开始显示第二段消息体的内容。往复替换，自动更新。栗子一个不超过 20 行的 NodeJS Demo：yscoder/multipart-x-mixed-replace-example。const http = require('http')const fs = require('fs')const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'multipart/x-mixed-replace; boundary=--test' &#125;) let i = 1 function sendData() &#123; const content = fs.readFileSync(`./imgs/run$&#123;i&#125;.png`) res.write(`--test\\nContent-Type: image/png\\nContent-length: $&#123;content.length&#125;\\n\\n`) res.write(content) i = i === 20 ? 1 : i + 1 setTimeout(sendData, 50) &#125; setTimeout(sendData, 50)&#125;)server.listen(8090)console.log('Server running!')网上找了一组包含 20 张图片的人物帧序列图，逐个发送到客户端。浏览器打开本地端口地址后可以看到动画的效果。实际运用中一般是连接媒体视频设备获取媒体流然后向客户端发送。客户端只需要使用 img 标签引用接口就可以持续接收到推送数据，监听 onload 事件把每次推送的数据绘制到 canvas 上。","tags":[{"name":"Server Push","slug":"Server-Push","permalink":"http://imys.net/tags/Server-Push/"},{"name":"MIME","slug":"MIME","permalink":"http://imys.net/tags/MIME/"},{"name":"multipart","slug":"multipart","permalink":"http://imys.net/tags/multipart/"},{"name":"x-mixed-replace","slug":"x-mixed-replace","permalink":"http://imys.net/tags/x-mixed-replace/"}]},{"title":"前端静态数据的管理","date":"2018-04-17T13:18:01.000Z","path":"20180417/front-end-static-data-manage.html","text":"静态数据所谓静态数据，本文内指的是一些静态常量、配置化数据以及枚举类数据等，很少变化或者说很少在运行时变化的数据。例如：API 服务器的 rootPath、常用的正则表达式、业务相关的枚举类数据、固定的填充数据以及 i18n 等。虽然这些数据很少变化，但在一个大的项目中非常容易到处使用。常见的问题有：同样规则的正则表达式，这写一个，那写一个业务枚举数据各种迷之 magicNumber 进行判断比较，如 if(this.type === 1)，1 是啥？？？对同一种数据的多处定义，A 组件一个 framework: [&#39;Vue&#39;, &#39;React&#39;, &#39;Angular&#39;]，B 组件用的时候又定义一次i18n 时，不同模块中的类型场景定义多个描述……这些问题的出现就给后期项目维护增加了时间和沟通成本，有意识的提取静态数据是必须要做的事。静态数据分离配置、工具类数据类似 AJAX、WebSocket 等常用模块配置，可以抽取到一个公共的 appConf.js 文件中，通过引用配置文件对模块进行配置。常用的正则也抽取到一个工具模块中。类似的还有校验类数据，比如允许用户上传的文件大小、文件类型等。枚举类数据一个用户的角色、权限、状态等数据，前端接收到的一般是 { role: 0, state: 1 } 这种，那么在代码中通常有三种使用场景：内容展示：user.role === 0 ? &#39;管理员&#39; : &#39;成员&#39;权限判断：user.role === 0 &amp;&amp; doSomething()选择、过滤时的列表展示：[{ value: 0, text: &#39;管理员&#39;}, { value: 1, text: &#39;成员&#39;}]此类数据后端都犯不着建个表存储，定个枚举类完事。如果是前后端同构的项目，大家都调用同一个枚举模块就行了。多数情况下，前端也需要对此类数据集中化管理，让之后的代码维护有路径可寻。我的做法有：由于 JS 目前没有内置枚举类，可以使用对象模拟，或者自己包装一个枚举类的实现。抽取到前端 service 层，与同一模块下的业务函数放一块。个人更倾向于第二种：// userServiceexport const MAGANER = 0export const MEMBER = 1export const isManager = role =&gt; MAGANER === roleexport const isMember = role =&gt; MEMBER === rolei18ni18n 的数据不仅要按业务模块纵深划分，还要考虑横切的通用类数据。纵深：user、project、docs…横切：action、date、httpCode…如果只按模块划分，那么可能就会出现重复定义的按钮文字、触发动作等，如下：&#123; user: &#123; enter: '保存', remove: '删除', msgcode: &#123; 10001: '添加用户成功！' &#125; &#125;, project: &#123; save: '保存', deleted: '删除', msgcode: &#123; 10001: '添加项目成功！' &#125; &#125;&#125;重复场景、语义的文字多处定义，而且属性名也不一致。改善后：&#123; action: &#123; enter: '确认', save: '保存', remove: '删除' &#125;, httpcode: &#123; 10001: '添加&#123;0&#125;成功！' &#125;, user: &#123;&#125;, project: &#123;&#125;&#125;END内容没什么技术含量，纯粹是出于代码洁癖，就是不想在项目看见任何重复的东西。","tags":[{"name":"前端","slug":"前端","permalink":"http://imys.net/tags/前端/"},{"name":"数据管理","slug":"数据管理","permalink":"http://imys.net/tags/数据管理/"}]},{"title":"Vue最佳实践","date":"2018-03-20T12:18:51.000Z","path":"20180320/vue-best-practices.html","text":"记录我在使用 Vue 中发现的一些好的代码实践，希望能够保持更新。🤠this 引用在组件作用域内使用箭头函数可以保证 this 永远指向组件本身。// badexport default &#123; data() &#123; return &#123; msg: 'hello' &#125; &#125;, methods: &#123; hello() &#123; setTimeout(function() &#123; console.log(this.msg) // this 指向 window &#125;) &#125; &#125;&#125;// goodexport default &#123; data() &#123; return &#123; msg: 'hello' &#125; &#125;, methods: &#123; hello() &#123; setTimeout(() =&gt; &#123; console.log(this.msg) // this 指向组件 &#125;) &#125; &#125;&#125;属性绑定绑定字符串不需要加冒号。&lt;!-- bad --&gt;&lt;component :str=\"'hello'\"&gt;&lt;/component&gt;&lt;!-- good --&gt;&lt;component str=\"hello\"&gt;&lt;/component&gt;布尔属性省略值时默认为 true。&lt;my-modal visible&gt;&lt;/my-modal&gt;&lt;!--等价于--&gt;&lt;!--&lt;my-modal :visible=\"true\"&gt;&lt;/my-modal&gt;--&gt;绑定无参函数不需要加括号。&lt;!-- bad，括号多余 --&gt;&lt;button @click=\"onClick()\"&gt;&lt;/button&gt;&lt;!-- good，隐式传递了 event 对象 --&gt;&lt;button @click=\"onClick\"&gt;&lt;/button&gt;只有一行代码的事件函数，可以直接写标签上。&lt;button @click=\"visible = true\"&gt;&lt;/button&gt;双向绑定表单组件一般都支持双向绑定，实际场景中表单组件值发生变化往往要在 POST or PUT 请求之后。如果直接在 v-model 绑定原始值往往会打破单向数据流。使用计算属性的 get/set 方式可以解决这个问题。（也适用 .sync）export default &#123; template: ` &lt;div&gt; &lt;input type=\"radio\" v-model=\"nameVal\" value=\"1\"&gt; &lt;input type=\"radio\" v-model=\"nameVal\" value=\"2\"&gt; &lt;/div&gt;`, data() &#123; return &#123; name: '' &#125; &#125;, computed: &#123; nameVal: &#123; get() &#123; return this.name &#125;, set(val) &#123; this.edit(val) &#125; &#125; &#125;, methods: &#123; edit(name) &#123; this.$http.put('/name', &#123; name &#125;).then(data =&gt; &#123; this.name = name &#125;) &#125; &#125;, created() &#123; this.$http.get('/name').then(data =&gt; &#123; this.name = data.name &#125;) &#125;&#125;释放资源善用 destory 释放原生事件、第三方组件、全局事件总线等。import bus from 'event-bus'import plugin from 'plugin'export default &#123; // ... created() &#123; bus.$on('hello', this.hello) // 注册全局事件 window.addEventListener('resize', this.onResize) // DOM 事件 plugin.init() // 第三方组件初始化 &#125;, destoryed() &#123; bus.$off('hello', this.hello) window.removeEventListener('resize', this.onResize) plugin.destory() &#125;&#125;修饰符Vue 内置了许多常用修饰符可以让你少写几行代码，提高开发效率。&lt;!-- 输入字符串转数字 --&gt;&lt;input type=\"text\" v-model.number=\"value\"&gt;&lt;!-- 输入字符串去前后空格 --&gt;&lt;input type=\"text\" v-model.trim=\"value\"&gt;&lt;!-- 监听鼠标按键，支持 left, right, middle --&gt;&lt;button @click.left=\"onLeftClick\"&gt;点击鼠标左键&lt;/button&gt;&lt;button @click.right=\"onRightClick\"&gt;点击鼠标右键&lt;/button&gt;&lt;!-- 停止冒泡，阻止默认行为 --&gt;&lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 键盘按下确认键，支持 keycode 和键别名 --&gt;&lt;input @keyup.13=\"onEnter\"&gt;&lt;!-- 只执行一次事件 --&gt;&lt;button @click.once=\"doThis\"&gt;&lt;/button&gt;&lt;!-- 监听原生事件 --&gt;&lt;el-button @click.native=\"doThis\"&gt;&lt;/el-button&gt;以上是一些常用的修饰符，更多用法可以去文档上找找。数据请求切换路由请求数据时，一般都需要兼容两种视图打开方式：路由跳转和直接 URL 输入。export default &#123; watch: &#123; $route() &#123; this.fetchData() &#125;, &#125;, methods() &#123; fetchData() &#123; // 避免重复请求 if(this.isLoading) return this.isLoading = true // 请求数据 // ajax... &#125; &#125;, created() &#123; this.fetchData() &#125;&#125;路由跳转会触发 watch -&gt; $route，如果是未创建的组件还会触发 create，直接 URL 只会触发 created 钩子。一般在两个位置都执行数据请求，再通过判断避免重复请求，还可以利用 isLoading 标记做加载动画。如果使用了 keep-alive 组件，还需要考虑 activated 钩子。减少嵌套层级组件即使未在 props 声明，也可以传递一些原生 DOM 属性。&lt;!-- bad --&gt;&lt;div class=\"content-view\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;!-- good --&gt;&lt;router-view class=\"content-view\"&gt;&lt;/router-view&gt;命名插槽中需要放置多个块时，可以利用 template 组件。&lt;!-- bad --&gt;&lt;my-component&gt; &lt;div slot=\"hello\"&gt; &lt;div class=\"block1\"&gt;&lt;/div&gt; &lt;div class=\"block2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/my-component&gt;&lt;!-- good --&gt;&lt;my-component&gt; &lt;template slot=\"hello\"&gt; &lt;div class=\"block1\"&gt;&lt;/div&gt; &lt;div class=\"block2\"&gt;&lt;/div&gt; &lt;/template&gt;&lt;/my-component&gt;不管是内置组件还是自己的组件，有时候不需要多一层包裹去添加样式，反而因此增加了嵌套层级。过滤器过滤器的最佳应用场景应该是值的转换，比如：Date 类型日期转字符串、货币、字符截断、markdown 等等。// 按长度截断文字，补...，中文 = 2const cnReg = /[\\u4e00-\\u9fa5]/Vue.filter('ellipsis', (str, len = 10) =&gt; &#123; let i = 0 let j = 0 let ret = '' const text = String(str).trim() const max = text.length while (j &lt; max &amp;&amp; i &lt; len) &#123; const c = text.charAt(j) ret += c j += 1 i = cnReg.test(c) ? i + 2 : i + 1 &#125; return ret === text ? text : `$&#123;ret&#125;...`&#125;)// 日期转相对时间Vue.filter('calendar', value =&gt; moment(value).calendar())也可以作一些业务数据区别展示。Vue.filter('userRole', value =&gt; ['创建者', '管理员', '成员'][value])Props布尔属性默认值为 false 可以省略数组最好声明默认值 []，保证数据请求成功前模版里的 v-for 不会出错对象也需要注意是否声明了默认值 {}，避免模版中使用 obj.xx 报错&#123; props: &#123; visible: Boolen, // 默认即为 false data: Array, // 需要进行非空判断 data2: &#123; // 可安全使用 v-for type: Array, default: [] &#125;, obj: Object, // 需要进行非空判断 obj2: &#123; // 可安全使用 obj.xx type: Object, default() &#123; return &#123;&#125; &#125; &#125; &#125;&#125;v-if如果模版中绑定了 obj.xx 时，需要注意 obj 是否是异步数据，默认值是否为 null。安全起见，可在组件最外层加 v-if 判断。&lt;template&gt; &lt;div v-if=\"!!obj\"&gt; &lt;p&gt;&#123;&#123;obj.name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;obj.age&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; obj: null &#125; &#125;&#125;&lt;/script&gt;路由对于经常发生变化的一级、二级菜单导航，可以和路由数据结合起来，按模块划分，视图直接引用对应模块的路由数据来生成导航，减少维护成本。// routes.jsexport const settingRoutes = []export const userRoutes = []export default [...settingRoutes, ...userRoutes]菜单组件中：&lt;template&gt; &lt;ul&gt; &lt;li v-for=\"item in menus\" :key=\"item.name\"&gt; &lt;router-link :to=\"item\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import &#123; settingRoutes &#125; from '../routes'export default &#123; data() &#123; menus: settingRoutes &#125;&#125;&lt;/script&gt;继承和混合用过ElementUI的同学，都知道其 Dialog 组件 是不支持垂直居中，只提供了一个top属性用于设置组件内容节点到顶部的距离。早期 1.x 版本时 Dialog 组件也不支持append-to-body。我们可以通过继承和混合来扩展这些需要的特性。// dialogEx.jsimport &#123; Dialog &#125; from 'element-ui'export default &#123; name: 'ElDialogEx', extends: Dialog, props: &#123; appendToBody: &#123; // 把组件插入 body 下 type: Boolean, default: true &#125;, center: Boolean // 设置垂直居中 &#125;, computed: &#123; sizeClass() &#123; // 这个 sizeClass 计算属性是组件源码里就有的，这里是利用了类名支持字符串拼接的特性，在这个函数里增加了垂直居中的自定义类拼接 return `el-dialog--$&#123;this.size&#125;` + this.center ? ' dialog-center ' : '' &#125; &#125;, mounted() &#123; if (this.appendToBody) document.body.appendChild(this.$el) &#125;, beforeDestroy() &#123; if (this.appendToBody) this.$el.parentNode.remove(this.$el) &#125;&#125;之后你又发现，在其他的一些组件中也需要appendToBody这个特性，那么就可以把相关的代码写成mixins。// appendToBody.jsexport default &#123; props: &#123; appendToBody: &#123; // 把组件插入 body 下 type: Boolean, default: true &#125; &#125;, mounted() &#123; if (this.appendToBody) document.body.appendChild(this.$el) &#125;, beforeDestroy() &#123; if (this.appendToBody) this.$el.parentNode.remove(this.$el) &#125;&#125;现在dialogEx组件可以写的更简单。// dialogEx.jsimport &#123; Dialog &#125; from 'element-ui'import appendToBody from 'mixins/appendToBody'export default &#123; name: 'ElDialogEx', extends: Dialog, mixins: [appendToBody], props: &#123; center: Boolean // 设置垂直居中 &#125;, computed: &#123; sizeClass() &#123; // 这个 sizeClass 计算属性是组件源码里就有的，这里是利用了类名支持字符串拼接的特性，在这个函数里增加了垂直居中的自定义类拼接 return `el-dialog--$&#123;this.size&#125;` + this.center ? ' dialog-center ' : '' &#125; &#125;&#125;第三方库的集成第三方库一般是传统的基于 DOM 和原生 js。它们虽然写起来没有使用任何的代码模版，但出于作者的编程经验其实都符合了大众使用预期。任何一个库一般都会提供以下的接口：使用自定义配置初始化可访问的属性可调用的功能函数事件绑定良好的生命周期钩子如果没有足够的编程经验用原生 js 去写一个插件可能最后就是一团乱麻。这也是 Vue 等众多前端框架的作用，它们约束了一个模块的代码模版，提供了事件管理、生命周期运行、属性和函数的定义，使即使经验不足的人也能写出一个看得过去的模块。把第三方库转换为一个 Vue 组件，其实就是把这个库的接口挂到 Vue 组件对应的组件选项上去。import Lib from 'lib'export default &#123; props: &#123; options: Object &#125;, data() &#123; return &#123; instance: null &#125; &#125;, methods: &#123; doSomething(xxx) &#123; // lib 的操作函数 // 外部使用 $refs 调用 this.instance.doSomething(xxx) &#125; &#125;, computed: &#123; libProp() &#123; // lib 的可访问属性使用计算属性访问 // 外部使用 $refs 调用 return this.instance.prop &#125; &#125;, watch: &#123; options(val) &#123; // 监听配置更新，调用 lib 接口更新配置 if (val) this.instance.updateOptions(val) &#125; &#125;, mounted() &#123; // mounted 或者 created 对应 lib 实例化并传入自定义配置 this.instance = new Lib(this.$el, this.options) // lib 内的事件 $emit 出去，外部监听 this.instance.on('update', (...args) =&gt; &#123; this.$emit('update', ...args) &#125;) &#125;, destroyed() &#123; // lib 如果提供了 destroy 等销毁资源的函数一般都会对其内部的 DOM 事件解绑 this.instance.destroy() &#125;&#125;也可能你想把一个库变为一个 Vue 指令。import Lib from 'lib'export default &#123; install(Vue, option = &#123;&#125;) &#123; // 存放全局配置 const defaults = option Vue.directive('my-directive', &#123; bind(el, &#123; value &#125;) &#123; // 当前配置混合全局配置 const options = Object.assign(&#123;&#125;, defaults, value) const lib = new Lib(el, options) el._libInstace = lib // 缓存 lib 实例 &#125;, update(el, &#123; value &#125;, vnode) &#123; // 更新 lib 配置 el._libInstace.setOptions(value) &#125;, unbind(el) &#123; // 销毁 lib el._libInstace.destroy() delete el._libInstace &#125; &#125;) &#125;&#125;指令有着完善的生命周期钩子，但在数据管理上偏弱。一般用于单一功能的集成，或者只需要一次初始化的插件。指令中可通过 el 或 el.dataset 进行生命周期间的数据共享。","tags":[{"name":"技巧","slug":"技巧","permalink":"http://imys.net/tags/技巧/"},{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"}]},{"title":"复杂单页应用数据管理总结","date":"2018-03-19T13:24:35.000Z","path":"20180319/complex-spa-data-manage-ko.html","text":"过去的一年都扎在 SPA 应用开发里了，直到现在偶尔还会回顾和思考关于数据管理方面还有哪些可以改善的地方。过年后在找工作的期间，发现有些面试官都理解不了我描述的项目经历中的项目复杂度，也许是所在城市（郑州）的原因，水太浅。现在对过去的一些经验做一下总结，也期望与相关领域的开发者一起交流。为何复杂复杂单页应用的特点：无刷新体验，全靠 Ajax 请求或 WebSocket 推送更新数据一种数据显示在多个视图区块存在使用率高的热数据，可随时调出并保持数据新鲜想象一下这样的场景：视图右上角显眼处显示了当前用户相关的头像、名字等用户信息。进入一个项目模块，显示了所有的有权限或公开项目，每个项目块上都展示该项目的管理者和参与者（1~N 个用户信息）。点击项目进去项目下的任务列表，每个任务块上都展示了该任务的负责人和参与人。假设该用户修改的用户头像，则该用户 UI 右上角头像需要更新，其次是项目列表或任务列表中，所有包含该用户头像展示的地方需要更新。最后是其他在线用户的 UI 上的项目或任务列表中存在该用户信息，也需要更新。核心实现做一个复杂的单页应用一定需要后端的支持和配合，前端对接口和推送的数据结构要有话语权，如果做不到这一点后续的各种实现会非常麻烦。由于项目使用了基于 Vue 的技术栈来开发，早期我们就根据 Vue 的特点制定了数据管理的核心思想：API 只针对单一数据模型返回数据，所有视图的数据聚合、过滤等由前端完成前端按模块存储数据，由视图层拼装业务数据整体下来，所有的数据从请求到视图渲染之前都是单一模型的数据，只到视图层渲染时才根据业务去组合需要的数据。这样做的好处是：不管一个数据在 UI 上有多少个区块显示，但最终的数据来源都存在于前端的某个唯一的存储模块内。这样当这个数据发生修改时，只需要在这个存储模块内修改了这条数据，所有的区块视图 都会得到更新。不管是请求数据还是推送数据，都只是把数据扔到前端的存储模块内。只要某个视图存在对某一条数据的引用，那么到需要更新的时候自然会更新。模块即服务模块即服务，这个概念是我们在开发过程中逐步发现的一个趋势。所谓的 模块，在项目中具体的代表是 Vuex 中的一个 stroe 模块。举例来说，一个 task模块 既存储了当前所有的任务数据，也包含了对任务数据的所有操作。而任务数据在整个应用中的表现形式不止于任务列表一种。可能在 A 路由中表现为任务列表，B 路由中表现为某个用户参与的所有任务。但是归根结底两种表现形式背后需要的数据结构是类似的，某些功能也可能类似（比如分类、过滤等操作）。那么这个模块就得到复用，除了请求数据的接口不同，但请求完成后都把数据放到 task 模块中，不管最终表现为哪种视图都引用 task 模块的数据去组成业务数据。数据即业务根据前面所述，如果一个视图引用 task 模块的数据去组成业务数据，那么之后必然要对后续 task 相关的业务操作得到响应。所有的业务操作回归到数据上，都属于增、删、改操作。所以视图模型必须从数据本身来描述业务。数据模块中增加、删除、修改一条数据，必须正确的反馈到视图模型中。我们大量使用了 Vue 中的 计算属性 来实现数据即业务。就拿 当前用户创建的所有任务 这个业务来说，计算属性可以表示为：this.$store.state.taskModule.taskList.filter(item =&gt; item.creator === this.loginUserId)后续推送了 task 相关的数据就会添加到任务模块中，对 task 的增、删、改操作也是去操作任务模块里的数据。最终对于视图来说，只要数据满足计算属性的描述，那么视图就得到更新。降低数据操作复杂性由于数据模块中一般存储了一种数据模型的集合（数据），那么在模块内的删、改类操作时都需要对原数据集进行循环遍历。我们之后对一些模块尝试了 扁平化数据结构。// 原数据;[ &#123; id: 't1', name: 'aaa', creator: &#123; userName: 'sfs', userId: 'u1' &#125;, tags: [ &#123; id: 't1', name: 'tag1' &#125;, &#123; id: 't2', name: 'tag2' &#125; ] &#125;, &#123; id: 't2', name: 'bbb', creator: &#123; userName: 'sfs', userId: 'u1' &#125;, tags: [ &#123; id: 't2', name: 'tag2' &#125;, &#123; id: 't3', name: 'tag3' &#125; ] &#125; // ...]从上面的数据结构，可以想象，修改一条任务的属性都需要进行循环查找才可修改，而如果是像 tags -&gt; t2 这种深层次对象修改，又需要多一层循环。// 打平后&#123; taskList: &#123; t1: &#123; id: 't1', name: 'aaa', creator: 'u1', tags: ['t1', 't2'] &#125;, t2: &#123; id: 't1', name: 'bbb', creator: 'u1', tags: ['t2', 't3'] &#125; &#125;, taskIds: ['t1', 't2'], userList: &#123; u1: &#123; userName: 'sfs', userId: 'u1' &#125; &#125;, userIds: ['u1'], tagList: &#123; t1: &#123; id: 't1', name: 'tag1' &#125;, t2: &#123; id: 't2', name: 'tag2' &#125;, t3: &#123; id: 't3', name: 'tag3' &#125; &#125;, tagIds: ['t1', 't2', 't3']&#125;数据打平为一层，对象关联通过 id 引用来描述每一种数据都单独拆分出来数据集和 id 集合两种形式，一种用来取值，一种用于顺序描述给定 1 个 ID，就可以很快获取到对应的值修改时减少循环遍历，但增加、删除时需要在两种数据形式上作修改数据操作这一块可以继续抽象，像一些 ORM 框架一样，形成声明式 Model，解放重复编码。","tags":[{"name":"SPA","slug":"SPA","permalink":"http://imys.net/tags/SPA/"},{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://imys.net/tags/Vuex/"},{"name":"前端","slug":"前端","permalink":"http://imys.net/tags/前端/"},{"name":"数据管理","slug":"数据管理","permalink":"http://imys.net/tags/数据管理/"}]},{"title":"Vue单页应用中的数据同步探索","date":"2017-05-07T07:55:40.000Z","path":"20170507/data-sync-in-vue-single-page-application.html","text":"一个多月没写博，最近一个月的 Github 提交数少了很多，总之就是各种状态不好。微博上看到上个月是水逆，看来我也是受灾群众了。😝单页应用的一个特点就是即时响应，对发生变化数据实现 UI 的快速变更。实现的基础技术不外乎 AJAX 和 WebSocket，前者负责数据的获取和更新，后者负责变更数据的客户端同步。其中要解决的最主要的问题还是数据同步。可以把这个问题拆分为两个具体问题：数据共享：多个视图引用的数据能在发生变化后，即时响应变化。数据同步：多终端访问的数据能在一个客户端发生变化后，即时响应变化。发布订阅模式在旧的项目中是使用了发布订阅模式解决这些问题。不管是 AJAX 请求的返回数据还是 WebSocket 的推送数据，统一向全局发布消息，每个需要这些数据的视图去订阅对应的消息使视图变化。缺点是：一个视图为了响应变化需要写很多订阅并更新视图数据的硬编码，涉及数据越多，逻辑也越复杂。数据流对于 Vue，首先它是一个 MVVM 框架。Model &lt;----&gt; ViewModel &lt;----&gt; View一目了然的关系，Model 的变化影响到 ViewModel 的变化再触发 View 更新。那么反过来呢，View 更改 ViewModel 再更改 Model？对于更新数据而言，更改 ViewModel 真是多此一举了。因为我们只需要改变 Model 数据自然就会按照Model &gt; ViewModel &gt; View的路径同步过来了。这也就是为什么 Vue 后来抛弃了双向绑定，而仅仅支持表单组件的双向绑定。对于双向绑定而言，表单算得上是最佳实践场景了。在开发实践中，最常见的还是单向数据流。Model --&gt; ViewModel --&gt; View --&gt; Model单向数据流告诉我们这样两样事：不直接绑定 Model，而是使用由 1~N 个 Model 聚合的 ViewModel。View 的变化永远去修改变更值对应的 Model。Data Flow解决数据问题的答案已经呼之欲出了。多个视图引用的数据在发生变化后，如何响应变化？保证多个 View 绑定的 ViewModel 中共同数据来自同一个 Model。多终端访问的数据在一个客户端发生变化后，如何响应变化？首先多终端数据同步来源于 WebSocket 数据推送，要保证收到数据推送时去更改直接对应的 Model，而不是 ViewModel。Vue中的解决方案不只是要思想上解决问题，而且要代入到编程语言、框架等开发技术中实现。Model的存放Model 作为原始数据，一般为 AJAX GET 得到的数据，应该位于整个 Vue 项目结构的最上层。对于 Model 的存放位置，也有不同的选择。非共享Model不需要共享的 Model 可以放到视图组件的data中。但仍然避免 View 直接绑定 Model，即使该 View 的 ViewModel 不再需要额外的 Model 聚合。因为最终影响 View 呈现的不只是来自服务器的 Model 数据，还有视图状态ViewState。来个🌰：一个简单的列表组件，负责渲染展示数据和关键字过滤功能。输入的过滤关键字和列表数据都作为 data 存放。export default &#123; data() &#123; return &#123; filterVal: '', list: [] &#125; &#125;, created() &#123; Ajax.getData().then(data =&gt; &#123; this.list = data &#125;) &#125;, methods: &#123; filter() &#123; this.list = this.list.filter(item =&gt; item.name === this.filterVal) &#125; &#125;&#125;试想一下，如果 View 直接绑定了以上代码中的list，那么在filter函数执行一次后，虽然 View 更新了，但同时list也被改变，不再是一个原始数据了，下一次执行filter函数将是从上一次的结果集中过滤。很尴尬，总不能重新请求数据吧，那样还搞什么 SPA。现在我们有了新的发现：ViewModel 受Model和ViewState的双重影响。ViewModel = 一个或多个 Model 组合 + 影响 View 展示的 ViewState即: viewModel = models.fn(viewState)Vue 中有没有好的方法可以很好的描述这个表达式呢？那就是计算属性computed。export default &#123; data() &#123; return &#123; filterVal: '', list: [] &#125; &#125;, computed: &#123; viewList() &#123; return this.filterVal ? this.list.filter(item =&gt; item.name === this.filterVal) : this.list &#125; &#125;, created() &#123; Ajax.getData().then(data =&gt; &#123; this.list = data &#125;) &#125;,&#125;改写代码后，View 绑定计算属性viewList，有过滤关键字就返回过滤结果，否则返回原始数据。这才称得上是 数据驱动。共享Model如果一个 View 中存在多处共享的 Model，那么毫不犹豫的使用 Vuex 吧。对于复杂单页应用，可以考虑分模块管理，避免全局状态过于庞大。即使是共享的 Model 也是分属不同的业务模块和共享级别。比如文档数据，可能只有/document起始路径下的视图需要共享。那么从节省内存的角度考虑，只有进入该路由时才去装载对应的 Vuex 模块。幸运的是 Vuex 提供的模块动态装载的 API。对于共享级别高的数据，比如用户相关的数据，可以直接绑定到 Vuex 模块中。store| actions.js| index.js| mutations.js+---global| user.js+---partial| foo.js| bar.js分模块管理后，马上就会遇到跨模块调用数据的问题。一个 View 中需要的数据往往是全局状态和模块状态数据的聚合，可以使用getter解决这个问题。export default &#123; // ... getters: &#123; viewData (state, getters, rootState) &#123; return state.data + rootState.data &#125; &#125;&#125;如果一个 View 是需要多个模块状态的数据呢？export default &#123; // ... getters: &#123; viewData (state, getters) &#123; return state.data + getters.partialData &#125; &#125;&#125;虽然不能直接访问到其他模块的 state，但是getter和action、mutation都注册在全局命名空间，访问不受限制。计算属性 vs GetterGetter 与组件的计算属性拥有相同的作用，其中引用的任何 state 或者 getter 变化都会触发这个 getter 重新计算。那么问题来了：什么时候我应当使用计算属性？什么时候使用 Getter？这里其实是有一个 数据前置 原则：能放到上层的就不放到下层。需要聚合多个 state 或 getter 时，使用 getter。如果有多个视图需要同样的数据组合就可以实现 getter 的复用。需要聚合的数据中包含 ViewState 时，使用 computed。因为在 store 中无法访问 ViewState。至此我们已经保证了应用内的任何一个共享数据最终都来源于某个全局状态或某个模块的状态。Model的更新Model 的更新有两种，一种是本地触发的更新，另一种是其他客户端更新再由服务器推送的更新。可以这样表示：Model = 本地原始数据 + 本地更新数据 + 推送数据我们似乎又回到了那个列表组件类似的问题上。要不把 3 种数据都设为 state，由 3 种数据组合的 getter 来表示 Model？现在来比较一下。另外有一个前提是 Vuex 只允许提交 mutation 来更改 state。单State对于一个 state 的更新不外乎是增、删、改、查四种情况，所以至少对应有 4 个 action 和 4 个 mutation，直接对表示源数据的 state 进行更改。export default &#123; state: &#123; data: [] &#125;, mutations: &#123; init(state, payload) &#123; state.data = payload &#125;, add(state, payload) &#123; state.data.push(payload) &#125;, delete(state, payload) &#123; state.data.splice(state.data.findIndex(item =&gt; item.id === payload), 1) &#125;, update(state, payload) &#123; Object.assign(state.data.find(item =&gt; item.id === payload.id), payload) &#125; &#125;, actions: &#123; fetch(&#123; commit &#125;) &#123; Api.getData().then(data =&gt; &#123; commit('init', data) &#125;) &#125;, add(&#123; commit &#125;, item) &#123; Api.add(item).then(data =&gt; &#123; commit('add', item) &#125;) &#125;, delete(&#123; commit &#125;, id) &#123; Api.delete(id).then(data =&gt; &#123; commit('delete', id) &#125;) &#125;, update(&#123; commit &#125;, item) &#123; Api.update(item).then(data =&gt; &#123; commit('update', item) &#125;) &#125; &#125;&#125;多State如果把一个 Model 拆成多个 state，本地更新数据和推送数据统一为变更数据，对应到增、删、改、查四种情况，那就需要 4 个 state，即：originData、addData、deleteData、updateData。mutation 和 action 到不会有什么变化，增、删、改原本就是分开写的，只是各自对应到不同的 state 上，最终的 Model 由一个 getter 来表示。export default &#123; state: &#123; originData: [], addData: [], deleteData: [], updateData: [] &#125;, getters: &#123; data(state) &#123; return state.originData.concat(state.addData) // add .map(item =&gt; Object.assign(item, state.updateData.find(uItem =&gt; uItem.id === item.id))) // update .filter(item =&gt; !state.deleteData.find(id =&gt; id === item.id)) // delete &#125; &#125;, mutations: &#123; init(state, payload) &#123; state.originData = payload &#125;, add(state, payload) &#123; state.addData.push(payload) &#125;, delete(state, payload) &#123; state.deleteData.push(payload) &#125;, update(state, payload) &#123; state.updateData.push(payload) &#125; &#125;, actions: &#123; // 略... &#125;&#125;这么一大串方法链看起来很酷对不对，但是性能呢？任何一个 state 的变更都将引起这个复杂的 getter 重新执行 5 个循环操作。知乎上有个相关问题的讨论：JavaScript 函数式编程存在性能问题么？其中提到的解决办法是惰性计算。相关的函数库有：lazy.js，或者使用 lodash 中的 _.chain 函数。还有一种办法是统一为K, V数据结构，这样一个混合函数就搞定了Object.assign(originData, addData, updateData, deleteData)。对比而言，我认为多 state 的方式更符合数据驱动及响应式编程思维，但需要有好的办法去解决复杂的循环操作这个问题，单 state 的方式就是面向大众了，两者都可以解决问题。甚至于全面使用响应式编程，使用 RxJS 替代 Vuex。数据同步前面提到过了，不管是本地更新数据还是服务端推送数据，可以统一为增、删、改三种接口。不管是本地更新还是推送数据，根据数据同步类型走同一个数据更改函数。这在 Vuex 中很容易实现。利于 Vuex 的插件功能，可以在接受推送后提交到对应的 mutation。前提是要和后端约好数据格式，更方便的映射到对应的 mutationType，比如：{ 数据名，同步类型，同步数据 }。export default store =&gt; &#123; socket.on('data', data =&gt; &#123; const &#123; name, type, data &#125; = data store.commit(type + name, data) &#125;)&#125;这样就实现了本地增、删、改与推送数据增、删、改的无差异化。推荐徐飞：单页应用的数据流方案探索徐飞：复杂单页应用的数据层设计","tags":[{"name":"SPA","slug":"SPA","permalink":"http://imys.net/tags/SPA/"},{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://imys.net/tags/Vuex/"},{"name":"数据流","slug":"数据流","permalink":"http://imys.net/tags/数据流/"},{"name":"数据同步","slug":"数据同步","permalink":"http://imys.net/tags/数据同步/"}]},{"title":"Vuex与前端缓存的整合策略","date":"2017-03-18T03:39:54.000Z","path":"20170318/vuex-cache-design.html","text":"如何存放或更新缓存？缓存数据来源是预知的，我们可以预先定义哪些 mutation 是缓存相关的。我们期望这个过程更自然一点，通过某种变化自动映射，使以后不管缓存类别增加还是减少都能修改极少的代码来应对变化。Vuex的插件可以拦截 mutations，借助这个机制，我们可以制定一种策略化的规则。可以规定，所有需要更新缓存的 mutationType 都要符合这种格式：module-type-cacheKey，非缓存的 mutationType 格式为 module-type。那么就可以拦截 mutation，去做我们想做的事了：store.subscribe((&#123; type, payload &#125;) =&gt; &#123; const cacheKey = type.split('-')[2] if (cacheKey) &#123; Cache.save(cacheKey, payload) &#125;&#125;)如何从缓存取数据避免请求？只需要在缓存相关的 action 中加入缓存判断。actionfetchData(&#123;commit&#125;) &#123; const cacheData = Cache.get(cacheKey) if(!cacheData) &#123; Api.getData().then(data =&gt; &#123; commit(mutationType, data) &#125;) &#125; else &#123; commit(mutationType, cacheData) &#125;&#125;设计优化以上的确已经足够完成缓存 读取 --&gt; 更新 的工作了。但试想一下将来某个其他数据类别要做缓存，我们就要把上面的代码格式再搬一遍。即：把新的需要缓存的数据类别对应的 mutationType 加 cacheKey 后缀，把获取数据的 action 中加缓存判断。虽然实际编码中也没有多大的工作量，但感觉还不是最好的开发体验。action优化action 中的痛点是：每次都需要重复写缓存判断。可以把这个判断过程拿出来放到一个大家都能访问到的公共的地方，且最好是与 Vuex 契合的。Vuex 支持 action 相互调用，我们可以设置一个单独的 action 用来提交。commitAction(&#123; commit &#125;, mutationType, getData) &#123; const cacheKey = mutationType.split('-')[2] const cacheData = Cache.get(cacheKey || '') if(!cacheData) &#123; getData().then(data =&gt; &#123; commit(mutationType, data) &#125;) &#125; else &#123; commit(mutationType, cacheData) &#125;&#125;,fetchData(&#123; dispatch &#125;) &#123; dispatch('commitAction', mutationType, Api.getData)&#125;不管是否需要缓存最终都走同一个 action 去提交，由这个 action 去做决策。mutation优化mutation 的痛点在于：加后缀啊！加后缀啊！！如果一个数据的相关逻辑复杂，可能对应很多个 mutationType，每个都需要：加后缀！要是代码能自动识别需要走缓存的 mutationType 就完美了！mutationType 默认的格式为 module-type，假如业务中一个 module 对应一个数据类别，我们就可以基于 module 作缓存识别。cacheConfig.jsexport default &#123; module1: 'key1', module2: 'key2', //...&#125;actioncommitAction(&#123; commit &#125;, mutationType, getData) &#123; const module = mutationType.split('-')[0] const cacheKey = CacheConfig[module] || '' const cacheData = Cache.get(cacheKey) if(!cacheData) &#123; getData().then(data =&gt; &#123; commit(mutationType, data) &#125;) &#125; else &#123; commit(mutationType, cacheData) &#125;&#125;,fetchData(&#123; dispatch &#125;) &#123; dispatch('commitAction', mutationType, Api.getData)&#125;interceptorstore.subscribe((&#123; type, payload &#125;) =&gt; &#123; const module = type.split('-')[0] const cacheKey = CacheConfig[module] if (cacheKey) &#123; Cache.save(cacheKey, payload) &#125;&#125;)当我们需要新增或减少缓存数据，只需要去 cacheConfig 中增加或减少一项模块配置。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://imys.net/tags/Vuex/"},{"name":"Cache","slug":"Cache","permalink":"http://imys.net/tags/Cache/"}]},{"title":"编写良好的前端组件","date":"2017-03-17T02:22:38.000Z","path":"20170317/write-good-front-end-component.html","text":"Vue 和 React 的大红大火，带来的是组件化和数据驱动的开发方式。Demo 很美好，但如果没有一定的实际开发经验积累，总是能把一个功能模块写成浆糊。依托于 Webpack 等构建工具，使得前端代码具备了后端编程语言的代码组织能力，摆脱了传统的「一泻而下」式的代码编写。至此，作为前端也该对自己的代码有更高的要求。组件职责划分一个组件只做一件事，基于功能做好职责划分。无状态组件公司用的是 Vue，最近又接触了下 React。对比来说，React 由于 jsx 式（js和html混合）的写法，加上构建工具的模块化管理，一个文件中可以有多个组件。还支持纯函数式的无状态组件，只是单纯的接受数据渲染 DOM，没有生命周期等额外的概念。无状态组件React// 无状态组件const noStatus = props =&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt;看起来就像一个简单的模版渲染过程。Vue 中没有无状态组件的概念，但实际上也存在类似功能的组件形式。比如图标组件，只接收 props 渲染模版，不做多余的动作。Vue&lt;template&gt; &lt;i class=\"icon\" :class=\"'icon-' + name\"&gt;&lt;/i&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; name: String &#125;&#125;&lt;/script&gt;端对端组件端对端组件指的是不需要依赖外部给予，自身就可以负责从数据获取到展示过程的组件。这类组件在业务开发中也很常见，比如公共的分类选择器。由于到多处调用，如果每次用的时候都由外部请求数据在调用组件展示，那么这个请求数据的代码显然是个重复的逻辑，索性直接就写入到组件内部了。端对端组件当然端对端组件也有缺陷。就是每次调用不管数据有没有变化，都会重新请求，造成冗余。如何改善，那又是另一个话题了。这篇文章中有提到：徐飞：复杂单页应用的数据层设计UI组件UI 组件指的是界面扩展类组件，比如：输入框、表格、树、下拉框等。像 Element、Vux 等组件库均属于此类组件。UI组件此类组件的特点是：复用性强，只通过 props、events 和 slots 等组件接口与外部通信。更像是一个对 HTML 的扩展标签。业务组件业务组件通常是根据最小业务状态抽象而出，有些业务组件也具有一定的复用性，但大多数是一次性组件。业务组件之前提到的组件数据或自给自足（端对端组件），或来自 props，那么业务组件的数据呢？propsglobal state只能是以上两种了，如果还是组件内部去请求数据，那么就还是属于端对端组件了。容器组件这类组件就是一个盒子，一般当作一个业务子模块的入口，比如一个路由指向的组件。容器组件通常是这种形式：&lt;div&gt; &lt;moduleA&gt;&lt;/moduleA&gt; &lt;moduleB&gt;&lt;/moduleB&gt; &lt;moduleC&gt;&lt;/moduleC&gt;&lt;/div&gt;容器组件内的子组件通常具有业务或数据依赖关系。如果没有使用全局状态管理，那么容器组件就是负责通过 props 分发数据到各个子组件，在通过 events 处理各个子组件的业务响应。此时容器组件需要做数据请求工作。如果使用了全局状态管理，那么容器内部的业务组件可以自行调用全局状态处理业务。但并不是说此时容器组件什么都不用干了。即使不需要请求数据，还是有许多组件间或一个业务模块内的诸多统筹工作要做。把上面的各类组件组装到一起就组成一个业务模块。业务模块组件设计原则尽可能的减少状态如果一个数据可以由另一个 state 变换得到，那么这个数据就不是一个 state。只需要写一个变换的处理函数，在 Vue 中可以使用计算属性。如果你的 state 是一个数组，而模版最外层是渲染这个数组，那么你需要做的事是把渲染的项作为一个组件，只接受一个单级对象形式的数据，由外部决定这个组件的展示次数。如果一个数据是固定的，不会变化的常量，那么这个数据就如同 HTML 固定的站点标题一样，写死或作为全局配置属性等，不属于 state。如果一个数据需要从外部得到，它应该属于 props。如果组件和兄弟组件拥有相同的 state，那么这个 state 应该放到更高的层级中，使用 props 传递到两个组件中。合理的依赖关系父组件不依赖子组件。要做到当我们把子组件删除后，只是丢失了一个功能，或一个模块等，而不会造成父组件及兄弟组件功能异常。子组件基于父组件传递 props 作出个性化展示。扁平化参数像 HTML 原生元素那样，只接受原始类型（字符串、数值、布尔值和函数）作为属性，避免复杂的对象。当然，数据除外。&lt;!-- good --&gt;&lt;my-component label=\"hello\" :actived=\"true\" :width=\"600\" :on-show=\"show\"&gt;&lt;/my-component&gt;&lt;!-- bad --&gt;&lt;my-component :config=\"myConfig\"&gt;&lt;/my-component&gt;良好的接口设计把组件内部可以完成的工作做到极致。虽然提倡拥抱变化，但接口不是越多越好。如果常量变为 props 能应对更多的场景，那么就可以作为 props。原有的常量可作为默认值。如果组件不能提供调用者所需求的功能，那么这个组件的接口还不够完善。如果需要为了某一调用者编写大量特定需求的代码，那么可以考虑通过扩展等方式构建一个新的组件。保证组件的属性和事件足够的给大多数的组件使用。End设计模式六大原则在组件设计中也有适用的地方。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"http://imys.net/tags/前端/"},{"name":"组件","slug":"组件","permalink":"http://imys.net/tags/组件/"},{"name":"React","slug":"React","permalink":"http://imys.net/tags/React/"}]},{"title":"关于拖拽排序后的持久化方案","date":"2017-02-24T07:09:00.000Z","path":"20170224/drag-the-sorted-field-design.html","text":"最近一次团队会议中提到了这个问题，感觉有点意思，就有了以下的思考。我们可以很轻松的写出以下解决思路：每一项的数据模型都有一个字段order，表示排序的依据。拖拽每一项后对order字段进行一定的变更，并发送修改请求，持久化排序字段。问题就在于第二步中的 进行一定的变更，是如何变更？从这一点入手就出现了各种不同的解决方案。取前后项差值除以2这是原来旧项目中采用的方案。每一项数据初始化一个较大的order值，如：10000、20000、30000…拖拽变化后，取前后项的order值相加除以2。假如把第三行拖拽到第一和第二行之间，那么它的order值由30000改为(10000 + 20000) / 2。理论上来讲，如果允许存在浮点数且不限制数据精度，绝对是可取的。退一步来说，也可以在数据临界时，或者某个空闲的时候依照当前顺序对数据库中的order列重新初始化。这种方案的特点是：新的order值永远在前后项order值的区间内。由这个特点可以衍生出一些方案，比如：降位法。原始数据：IDorder1cE2927ef1C618ea5Ed2687A61.12c70bADbe43C216DA261B24F12.14Da27EE5d3de2.28ea5Ed2687A62.365A64F9c12Ae3把最后一项放到倒数第二项之前：IDorder1cE2927ef1C618ea5Ed2687A61.12c70bADbe43C216DA261B24F12.14Da27EE5d3de2.265A64F9c12Ae2.218ea5Ed2687A62.3由于2.2和2.3在十分位上不存在数的间隔，所以插入到之间的项降一位到百分位上。取前后项的ID这是由链表数据结构想到的方案。每一项数据记录前一项或后一项的ID，拖拽变化后，进行对应的修改。缺点：数据渲染排序阶段开销大。假如取前一项ID为排序依据，需要找到前一项ID为null的为第一行数据，再找出前一项ID为第一行数据ID的为第二行数据…要深度遍历。前一项或后一项被删除，需要在删除数据的同时对受影响的排序字段进行数据修复，重新关联前一项或后一项的ID，至少 2 个请求。","tags":[{"name":"drag","slug":"drag","permalink":"http://imys.net/tags/drag/"},{"name":"sort","slug":"sort","permalink":"http://imys.net/tags/sort/"},{"name":"db","slug":"db","permalink":"http://imys.net/tags/db/"}]},{"title":"如何在Vue2中使用双向绑定？","date":"2017-01-19T11:30:01.000Z","path":"20170119/vue2-two-way-binding.html","text":"Vue2 取消了.sync指令修饰符，推崇单向闭环的数据流。即：父级通过props向子级传递数据，子级如果需要修改数据就需要在父级添加监听事件，并在子级中去触发事件修改值。在多数情况下，是不需要双向绑定的，单向数据流更容易追踪数据变化排查问题。但一些特定场景下，如弹窗，除了外部由父组件控制显示和隐藏外，组件内部也有关闭和取消等按钮需要控制显示和隐藏。这虽然可以通过触发事件让父级修改显示状态来实现，但每一个弹窗组件都需要做一遍这样的事总觉得很不爽。v-modelv-model是 Vue2 中唯一支持双向绑定的指令，用于表单控件绑定，但不代表它只能用在表单控件之上。在文档 使用自定义事件的表单输入组件 一节中提到了，v-model其实是个语法糖。&lt;input v-model=\"something\"&gt;&lt;!-- 等价于以下内容 --&gt;&lt;input :value=\"something\" @input=\"something = $event.target.value\"&gt;也就是说，你只需要在组件中声明一个name为value的props，并且通过触发input事件传入一个值，就能修改这个value。父组件中引用&lt;myComponent v-model=\"title\"&gt;&lt;/myComponent&gt;子组件const myComponent = &#123; template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;value&#125;&#125;&lt;/h1&gt;&lt;button @click=\"changeTitle\"&gt;Change&lt;/button&gt;&lt;/div&gt;', props: &#123; value: String &#125;, methods: &#123; changeTitle() &#123; this.$emit('input', '子组件') &#125; &#125;&#125;上面这个例子，最初显示的是父组件传入的title，点击子组件中的按钮后会修改显示值为子组件。组件内部控制关闭的弹窗现在可以解决弹窗组件内部自行关闭的问题了。Demo多字段的双向绑定一个组件只能定义一个v-model，假如想双向绑定多个值怎么办？v-model并没有限制value的数据类型，只是限制了是一个值！那么只需要把value的数据类型换成Object或者Array，把多出的字段作为对象的属性或数组的元素传入，多少个都不是问题了。从最佳实践角度出发，推荐只是特定场景下使用，比如自定义的表单组件。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"}]},{"title":"基于 document.execCommand 实现富文本编辑器","date":"2017-01-12T16:30:09.000Z","path":"20170113/create-rich-text-editor-by-execCommand.html","text":"前言最近在项目中准备集成一个富文本编辑器，原来使用的是 Quill，之后发现项目打包体积瞬增了 200kb。虽然 Quill 完全能够满足项目需求，但其提供的诸多功能是用不上的，可以使用更轻量的实现代替。在寻找新的替代品时，也顺便瞄了下各种编辑器的内部实现。一些体积庞大的编辑器一般都兼容低版本浏览器，不得不写很多兼容性的代码。而一些 MINI、轻量的编辑器是不对低端浏览器作兼容的，使用Selection、Range或者document.execCommand实现。之前在 JavaScript 获取输入时的光标位置及场景问题 中提到过Selection和Range，这次就说说document.execCommand。document.execCommand该方法可以对可编辑器区域进行操作，比如加粗文字、改变字号、插入链接等。可编辑区域也就是设置了contentEditable属性的元素。// 语法bool = document.execCommand(commandName, showDefaultUI[, arg])commandName：String，命令的名称showDefaultUI：Boolean，是否展示用户界面（暂时没有发现“用户界面”指的是什么），一般为falsearg：String，要传递的参数，比如插入链接需要传入一个 URL，可选返回值：Boolean，表示操作是否支持或是否启用假如要把选中的文字加粗，只需要这样：document.execCommand('bold', false)兼容性execCommand-support对于现代浏览器的兼容度较好，不过 Android 53 取消兼容的什么鬼？除了了解该方法的兼容性外，还需要了解每一种可执行命令的兼容性。比如decreaseFontSize，给选中文字添加small标签，也就是小号字体，谷歌是不支持的。可以使用以下方法检测命令是否在浏览器中支持：document.queryCommandSupported(commandName)简陋的实现不到 50 行代码，基于document.execCommand实现富文本编辑器。有兴趣的同学可以以此为出发点，去开发一个具备完整功能的编辑器。懒得折腾的可以像我一样多搜索几下，找一个合适的轮子。😅参考MDN: document.execCommand","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"Editor","slug":"Editor","permalink":"http://imys.net/tags/Editor/"},{"name":"ExecCommand","slug":"ExecCommand","permalink":"http://imys.net/tags/ExecCommand/"}]},{"title":"Webpack按需打包Lodash的几种方式","date":"2016-12-16T17:41:21.000Z","path":"20161217/webpack-use-lodash.html","text":"在数据操作时，Lodash 就是我的弹药库，不管遇到多复杂的数据结构都能用一些函数轻松拆解。ES6 中也新增了诸多新的对象函数，一些简单的项目中 ES6 就足够使用了，但还是会有例外的情况引用了少数的 Lodash 函数。一个完整的 Lodash 库，即使是压缩后，现最新版本也有 71k 的体积。不能为了吃一口饭而买下一个饭店啊。针对这个问题，其实已经有很多可选方案了。函数模块Lodash 中的每个函数在 NPM 都有一个单独的发布模块。NPM: results for ‘lodash’假如你只需要使用_.isEqual，那么你只需要安装lodash.isequal模块，然后按以下方式引用。var isEqual = require('lodash.isequal')// or ES6import isEqual from 'lodash.isequal'isEqual([1, 2, 3], [1, 2, 3]) // true全路径引用在你完整安装 Lodash 后，可以按lodash/函数名的格式单独引入需要的函数模块。var difference = require('lodash/difference')// or ES6import difference from 'lodash/difference'difference([1, 2], [1, 3]) // [2]使用插件优化在简单场景下，以上两种方式足以解决问题。而遇到复杂的数据对象时，我们不得不在一个文件中引入多个 Lodash 函数，这样就需要在文件中写多个require或import相关函数。import remove from 'lodash/remove'import uniq from 'lodash/uniq'import invokeMap from 'lodash/invokeMap'import sortBy from 'lodash/sortBy'// more...正写到关键处却因为引入一个函数要拉到文件头部去定义引用而打乱了思路，很不爽！于是我机智的到 Github 去搜索了webpack和lodash两个关键词的组合，排在首位的 lodash-webpack-plugin 就是为了解决这个问题而生。使用时需要以下模块，其实除了前两个剩下的一般都已安装了：$ npm i -S lodash-webpack-plugin babel-plugin-lodash babel-core babel-loader babel-preset-es2015 webpack配置：webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/, query: &#123; plugins: ['transform-runtime', 'lodash'], presets: ['es2015'] &#125; &#125;] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125;其中babel-plugin-lodash的配置，也就是plugins: [&#39;lodash&#39;]，并不是一定要在loaders中，也可以单独定义babel。webpack.config.jsvar LodashModuleReplacementPlugin = require('lodash-webpack-plugin');var webpack = require('webpack');module.exports = &#123; module: &#123; loaders: [&#123; loader: 'babel', test: /\\.js$/, exclude: /node_modules/ &#125;] &#125;, babel: &#123; presets: ['es2015'], plugins: ['transform-runtime', 'lodash'] &#125;, plugins: [ new LodashModuleReplacementPlugin, new webpack.optimize.OccurrenceOrderPlugin, new webpack.optimize.UglifyJsPlugin ]&#125;又或者是.babelrc文件中。以上工作完成了，在每个你需要使用 lodash 函数的文件中只需要引用一次 lodash，即可调用任意函数而不会造成完全打包。import _ from 'lodash'_.add(1, 2) // 打包时只会引入这一个函数模块注意：必须要使用 ES2015 的模块引用方式才有效。End以上即是我目前所知道的几种方式，如果哪位朋友有更好的方式（比如只需要全局引入一次），请一定分享与我！😋","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://imys.net/tags/Webpack/"},{"name":"Lodash","slug":"Lodash","permalink":"http://imys.net/tags/Lodash/"}]},{"title":"正确使用Vue指令的钩子函数","date":"2016-12-16T14:45:54.000Z","path":"20161216/vue-custom-directive-hook.html","text":"在 Vue 中可以把一系列复杂的操作包装为一个指令。什么是复杂的操作？我的理解是：复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。钩子函数对于自定义指令的定义，Vue2 有 5 个可选的钩子函数。bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。unbind: 只调用一次，指令与元素解绑时调用。接下来，定义一个简单的指令以验证这些钩子函数的触发时机。template&lt;div id=\"app\"&gt; &lt;my-comp v-if=\"msg\" :msg=\"msg\"&gt;&lt;/my-comp&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt; &lt;button @click=\"uninstall\"&gt;卸载&lt;/button&gt; &lt;button @click=\"install\"&gt;安装&lt;/button&gt;&lt;/div&gt;scriptVue.directive('hello', &#123; bind: function (el) &#123; console.log('bind') &#125;, inserted: function (el) &#123; console.log('inserted') &#125;, update: function (el) &#123; console.log('update') &#125;, componentUpdated: function (el) &#123; console.log('componentUpdated') &#125;, unbind: function (el) &#123; console.log('unbind') &#125;&#125;)var myComp = &#123; template: '&lt;h1 v-hello&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', props: &#123; msg: String &#125;&#125;new Vue(&#123; el: '#app', data: &#123; msg: 'Hello' &#125;, components: &#123; myComp: myComp &#125;, methods: &#123; update: function () &#123; this.msg = 'Hi' &#125;, uninstall: function () &#123; this.msg = '' &#125;, install: function () &#123; this.msg = 'Hello' &#125; &#125;&#125;)页面加载时bindinserted组件更新时点击“更新”按钮，更改数据触发组件更新。updatecomponentUpdated卸载组件时点击“卸载”按钮，数据置空否定判断以触发组件卸载。unbind重新安装组件时点击“安装”按钮，数据赋值肯定判断以触发组件重新安装。bindinserted区别从案例的运行中，对 5 个钩子函数的触发时机有了初步的认识。存疑的也就是bind和inserted、update和componentUpdated的区别了。bind 和 inserted据文档所说，插入父节点时调用 inserted，来个测试。bind: function (el) &#123; console.log(el.parentNode) // null console.log('bind')&#125;,inserted: function (el) &#123; console.log(el.parentNode) // &lt;div id=\"app\"&gt;...&lt;/div&gt; console.log('inserted')&#125;分别在两个钩子函数中输出父节点：bind 时父节点为 null，inserted 时父节点存在。update 和 componentUpdated关于这两个的介绍，从字眼上看感觉是组件更新周期有关，继续验证。update: function (el) &#123; console.log(el.innerHTML) // Hello console.log('update')&#125;,componentUpdated: function (el) &#123; console.log(el.innerHTML) // Hi console.log('componentUpdated')&#125;没毛病，update 和 componentUpdated 就是组件更新前和更新后的区别。结论文档说的没错…😒Demo最佳实践根据需求的不同，我们要选择恰当的时机去初始化指令、更新指令调用参数以及释放指令存在时的内存占用等。比较常见的场景是：用指令包装一些无依赖的第三方库以扩展组件功能。而一个健壮的库通常会包含：初始化实例、参数更新和释放实例资源占用等操作。Vue.directive('hello', &#123; bind: function (el, binding) &#123; // 在 bind 钩子中初始化库实例 // 如果需要使用父节点，也可以在 inserted 钩子中执行 el.__library__ = new Library(el, binding.value) &#125;, update: function (el, binding) &#123; // 模版更新意味着指令的参数可能被改变，这里可以对库实例的参数作更新 // 酌情使用 update 或 componentUpdated 钩子 el.__library__.setOptions(Object.assign(binding.oldValue, binding.value)) &#125;, unbind: function (el) &#123; // 释放实例 el.__library__.destory() &#125;&#125;)","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"VueDirective","slug":"VueDirective","permalink":"http://imys.net/tags/VueDirective/"}]},{"title":"获取隐藏元素的高度","date":"2016-12-08T02:15:25.000Z","path":"20161208/get-height-of-hidden-element.html","text":"当一个元素的样式被设置了display: none时，它的高度相关属性值为 0。这是因为修改display属性会触发元素的重排和重绘，而元素重排时将会重新计算它的一些属性值。被设置display: none的元素不占用文档空间，自然计算到的高度值为 0。关于重排和重绘：重绘重排重渲染 - Icarus隐藏元素的方式“隐藏”元素的方式有多种，除了设置display: none以外，还有visibility: hidden、opacity: 0、height: 0; overflow: hidden、transform: scale(0)等。为什么这里我把“隐藏”加了引号？因为上面提到的各种方式，有“真实隐藏”和“视觉隐藏”之分。这应该不难理解，比如visibility: hidden和opacity: 0虽然视觉上看不到，可元素还是在文档流中占用了位置。视觉隐藏的元素可以直接获取到元素的高度，所以我们要解决的问题主要还是设置display: none的元素。头脑风暴解决问题的关键在于透彻的分析问题。因为我们隐藏了元素，所以获取不到元素的高度。我们想要获取“隐藏”元素的高度做一些事。有没有一种“隐藏”元素的方式具有display: none的特征，且可以获取高度。OK。我们找到了一种可行性探索方案，接下来只要去验证各种隐藏元素的方式应该就能解决问题了。scrollHeight设置overflow: hidden可以根据元素高度裁剪视区，设置height: 0; overflow: hidden虽然文档流中占用了位置，由于高度为 0，最终表现特征达到了我们期望的display: none。此时该元素clientHeight、offsetHeight为 0，但是scrollHeight是有值的。scrollHeight是一个元素没有滚动条时的所有内容高度当一个元素没有滚动条时scrollHeight === offsetHeight当你有“获取隐藏元素的高度”这个需求时，真实目地其实就是要获取一个元素没有滚动条时的所有内容高度。否则固定高度加滚动条的情况下，高度是已知的，不会产生这个需求。也就是说scrollHeight就是我们最后想要得到的值。case最后，容我一猜，当你有这个需求时，也许是要实现这样的效果吧：SlideDown","tags":[{"name":"scrollHeight","slug":"scrollHeight","permalink":"http://imys.net/tags/scrollHeight/"},{"name":"display","slug":"display","permalink":"http://imys.net/tags/display/"},{"name":"height","slug":"height","permalink":"http://imys.net/tags/height/"},{"name":"overflow","slug":"overflow","permalink":"http://imys.net/tags/overflow/"},{"name":"SlideDown","slug":"SlideDown","permalink":"http://imys.net/tags/SlideDown/"}]},{"title":"JavaScript 获取输入时的光标位置及场景问题","date":"2016-11-25T02:02:01.000Z","path":"20161125/cursor-offset-at-input.html","text":"前言在输入编辑的业务场景中，可能会需要在光标当前的位置或附近显示提示选项。比如社交评论中的@user功能，要确保提示的用户列表总是出现在@字符右下方，又或者是在自定义编辑器中 autocomplete 语法提示，都需要获取光标当前的位置作为参照点。两种位置对于 WEB 开发来讲，当我们提到某某元素的位置，通常是指这个元素相对于父级或文档的像素单位坐标。而对于输入框中光标，就有了额外的区分。相对于内容相对于内容，光标位于第几个字符之后，姑且称之为字符位置吧。相对于UI相对于UI，也就是跟普通页面元素一样的像素位置了。插入或替换内容在前言提到的场景中，也有在光标位置处插入内容的需求，比如对选取文字加粗text =&gt; &lt;strong&gt;text&lt;/strong&gt;等。textareatextarea元素可以很容易获取到选择的一段文字的起止位置。如果当前没有选择文字，则两个位置值都为光标右侧字符的索引，从 0 开始。// 开始位置textarea.selectionStart// 结束位置textarea.selectionEnd对于加粗功能，有了起止位置，就能获取到选择的文字内容，然后对内容进行替换。由于textarea不能包含子元素，只有纯文本，所以基于textarea实现加粗只能像用 Markdown 标记语法实现。var selectedText = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd)textarea.setRangeText('**'+ selectedText +'**')textarea.setRangeText(text: String) 把选中的文字替换为其他内容。contenteditable也可能我们会使用contenteditable属性把一个元素变为可编辑元素。而上面所用的属性和函数都是普通元素所没有的，所以要换一种姿势实现。还是以加粗功能为例。// 获取文档中选中区域var range = window.getSelection().getRangeAt(0)var strongNode = document.createElement('strong')// 选中区域文本strongNode.innerHTML = range.toString()// 删除选中区range.deleteContents()// 在光标处插入新节点range.insertNode(strongNode)基于contenteditable的可编辑元素，其中的内容均为子元素，文本为textNode，加粗使用 HTML 元素，插入或替换是对元素的操作。如果想使用操作内容的思路实现会比较麻烦，因为可以获取到的起止位置是基于子元素的。&lt;div contenteditable&gt;hello&lt;strong&gt;你好&lt;/strong&gt;&lt;big&gt;w&lt;/big&gt;orld&lt;/div&gt;假如选中的文字是你好wor，调用相关 API 的输出如下。// 当前在文档中选择的文本，document 和 window 都有这个函数// var selection = document.getSelection()var selection = window.getSelection()selection.anchorNode // 你好selection.anchorOffset // 0selection.focusNode // orldselection.focusOffset // 2// 或者使用 Rangevar range = selection.getRangeAt(0)range.startContainer // 你好range.startOffset // 0range.endContainer // orldrange.endOffset // 2最终可以获取到起止元素以及选中区域在开始元素内容中的字符位置和在结束元素内容中的字符位置。其中的起止元素均为textNode类型，通过parentNode获取到包裹元素。range.startContainer.parentNode // &lt;strong&gt;你好&lt;/strong&gt;range.endContainer.parentNode // &lt;div contenteditable&gt;...&lt;/div&gt;需要注意的是通过Selection和Rang获取到起止位置是有方向之分的，从左向右选择和从右向左选择得到的值是正好相反的。基于光标像素位置创建内容这里就要开始用像素位置，同样分为两种实现来讲。contenteditable可编辑元素获取光标像素位置就像textarea获取光标的字符位置一样简单。var range = window.getSelection().getRangeAt(0)range.getBoundingClientRect() // &#123; width, height, top, right, bottom, right &#125;这么具体的尺寸值，实现自动完成真是 So easy!textareatextarea其中的内容都是纯文本，在 DOM 中不存在相关的对象，对于像素位置就得另作他想了。基于行高和字体大小计算// 1.获取光标结束位置var end = textarea.selectionEnd// 2.通过匹配光标之前文本中的换行符计算所在行var row = textarea.value.substring(0, end).match(/\\r\\n|\\r|\\n/).length// 3.计算 top，行高 * 行数 + 上填充 + 边框宽度var top = lineHeight * (row + 1) + paddingTop + borderWidth// 4.获取光标左侧的文本var leftText = textarea.value.split(/\\r\\n|\\r|\\n/)[row]// 5.影响一段文字所占宽度的因素太多，除字体大小、中英文、符号、字符间距等，还有字体、浏览器、系统等客观因素// var left = ...这个方案的思路是没问题的，但是考虑所有问题的成本太高。虽然可以创建测试元素去计算文本宽度，但这个方案本身是从严谨的角度出发的。与其混在一块，直接用取巧的办法更简单。这个方案的潜台词是：明明可以靠脸吃饭，却偏偏要靠才华！ 🙄镜像元素文本不支持定位？那我创建 DOM 好了。// 光标位置var end = textarea.selectionEnd// 光标前的内容var beforeText = textarea.value.slice(0, end)// 光标后的内容var afterText = textarea.value.slice(end)// 对影响 UI 的特殊元素编码var escape = function(text) &#123; return text.replace(/&lt;|&gt;|`|\"|&amp;/g, '?').replace(/\\r\\n|\\r|\\n/g, '&lt;br&gt;')&#125;// 创建镜像内容，复制样式var mirror = '&lt;div class=\"'+ textarea.className +'\"&gt;' + escape(beforeText) + '&lt;span id=\"cursor\"&gt;|&lt;/span&gt;' + escape(afterText) + '&lt;/div&gt;'// 添加到 textarea 同级，注意设置定位及 zIndex，使两个元素重合textarea.insertAdjacentHTML('afterend', mirror)// 通过镜像元素中的假光标占位元素获取像素位置var cursor = document.getElementById('cursor')cursor.getBoundingClientRect() // &#123; width, height, top, right, bottom, right &#125;End最后悄悄说一句，以上内容不兼容低版本 IE，但是 IE 毕竟主场运行，有些 API 反而是其他浏览器所没有的。就上面提到的案例来说，低版本 IE 也有对应的 API 可用。真是不想在 IE 上去浪费精力了，索性不提。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"Range","slug":"Range","permalink":"http://imys.net/tags/Range/"},{"name":"Selection","slug":"Selection","permalink":"http://imys.net/tags/Selection/"}]},{"title":"Vue单元测试起步","date":"2016-11-10T03:08:14.000Z","path":"20161110/vue-unit-test-start.html","text":"最近在搭建一个项目的前端开发环境，准备趁此把一些没用过的东西尝试下，比如：单元测试。使用vue-cli可以直接生成一个包含unit、e2e测试的开发环境，不过还是需要去了解其中的组织结构、配置和模块的使用等。准备没有一点相关经验，先把vue-cli生成后的test/unit目录拿到自己的项目中。test 目录结构:└─ test └─ unit ├─ specs ├─ .eslintrc ├─ index.js └─ karma.conf.js之后在package.json中找到karma相关的模块。karma 一个 JavaScript 测试运行器，其在测试中的作用相当于开发构建中使用的webpack。karma-webpack 连接karma和webpack的桥梁。不经过webpack编译命令是文件是无法独立运行的，karma需要了解你的webpack配置，决定如何处理你的测试文件。karma-phantomjs-launcher 是phantomjs在karma中的启动器，由此引出了phantomjs。PhantomJS 是一个没有界面的 “浏览器” ，内置了 JavaScript API，支持各种Web标准：DOM 处理、CSS 选择器、JSON、Canvas 和 SVG 等。在查找相关资料时，也发现了其他的常规浏览器launcher，比如：Chrome、Firefox、Safari、IE 等，以应对不同浏览器或多浏览器的测试需求。见Browserskarma-sourcemap-loader Karma插件，生成文件的sourcemap。karma-mocha 让你在 karma 中使用 Mocha 测试框架的插件，使用时还需要安装前置依赖mocha。karma-sinon-chai 让你在karma中使用sinon-chai断言库的插件，前置依赖有sinon-chai、sinon、chai…😕karma-spec-reporter 用于将测试结果显示到控制台。karma-coverage 生成代码覆盖率。其中要使用karma-phantomjs-launcher，需要先安装PhantomJS，通过phantomjs-prebuilt安装。看到这一大堆依赖，感觉面前又是一个不亚于 Webpack 的技术栈。之所以去了解每个模块的用处，就是为了在学习的时候直插心脏，忽略那些不重要的模块。以上来说，Karma 是基本的运行器，需要了解其配置和使用。测试框架 Mocha 和断言库 sinon-chai 类似于开发中使用的 Lodash，提供一系列用于测试的工具函数。剩下的按示例集成就好。安装整合一条命令。npm i -D karma karma-webpack phantomjs-prebuilt karma-phantomjs-launcher karma-sourcemap-loader mocha karma-mocha sinon chai sinon-chai karma-sinon-chai karma-spec-reporter karma-coveragePhantomJS 安装比较慢，也可以去其官网下载，并手动配置环境变量。安装好了，先跑一下看看是否安装正确，到package.json的scripts中注册一个命令：&quot;unit&quot;: &quot;karma start test/unit/karma.conf.js --single-run&quot;，然后运行。npm run unit然后不出意料的报错了，只是少装了一个模块isparta-loader，是一个代码覆盖工具，继续安装后运行OK。vue-unit-1配置karma.conf.js 文件内容分为两部分。module.exports 以上是对 Webpack 配置的处理，像webpack.dev.conf和webpack.prod.conf那样，在不同的环境里使用不同的配置。后一部分就是对 Karma 的配置了。module.exports = function (config) &#123; config.set(&#123; // 要启动的测试浏览器 browsers: ['PhantomJS'], // 测试框架 frameworks: ['mocha', 'sinon-chai'], // 测试报告处理 reporters: ['spec', 'coverage'], // 要测试的目标文件 files: ['./index.js'], // 忽略的文件 exclude: [], // 预处理文件 preprocessors: &#123; './index.js': ['webpack', 'sourcemap'] &#125;, // webpack webpack: webpackConfig, webpackMiddleware: &#123; noInfo: true &#125;, // Coverage options coverageReporter: &#123; dir: './coverage', reporters: [ &#123; type: 'lcov', subdir: '.' &#125;, &#123; type: 'text-summary' &#125; ] &#125;, // true: 自动运行测试并退出 // false: 监控文件持续测试 singleRun: true, // 以下是 vue-cli 没有生成的一些配置 // 文件匹配的起始路径 // basePath: '', // 服务器端口 // port: 9876, // 输出着色 // colors: true, // 日志级别 // LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG // logLevel: config.LOG_INFO, // 监控文件更改 // autoWatch: true, // 超时处理，6s内没有捕获浏览器将终止进程 // captureTimeout: 6000 &#125;)&#125;其中对于测试文件入口有点难以理解，仅仅是一个脚本文件，而不是路径匹配，也就是配置文件同级的那个index.js，只有 5 行代码。Function.prototype.bind = require('function-bind')const testsContext = require.context('./specs', true, /\\.spec$/)testsContext.keys().forEach(testsContext)const srcContext = require.context('../../src', true, /^\\.\\/(?!main(\\.js)?$)/)srcContext.keys().forEach(srcContext)看起来如果使用了高版本的 NodeJs 第一行代码是可以去掉了。testsContext匹配的是specs目录，里面是存放的是测试用例；srcContext匹配的是src目录，从正则上看是除了main.js以外的所有文件。也就是说，也可以通过脚本文件这种方式设置匹配的目标文件。实践现在看起来一切妥当了，可以开始写测试用例了。把以上步骤又重复了一遍，集成到了一个自己写的 Demo 项目中，然后运行测试。vue-unit-2什么鬼，找不到 less 变量。为了验证不是配置问题，我在 vue-cli 生成项目的组件中使用 less 写了个样式，运行测试出现了一样的问题。最后找到了这条issue。翻译了半天，感觉是匹配文件的问题。const srcContext = require.context('../../src', true, /^\\.\\/(?!main(\\.js)?$)/)原来的正则会匹配除了main.js以外的所有文件，所以样式文件也会被匹配上。使用 less 时一般只有一个变量文件，然后从一个 less 出口文件中解析，而单元测试本身做的工作是单文件测试，单个 less 文件肯定是找不到变量的。不过样式本身是不会对逻辑产生影响的，可以不参与测试，干脆直接锁定目标文件后缀，也就是 vue 组件。修改如下：const srcContext = require.context('../../src', true, /\\.vue$/)刚翻过一座山，又遇到一条河。vue-unit-3看起来是因为 API 不兼容，PhantomJS 中还没有集成 Promise。vue-unit-4为了避免相似的问题，索性把 launcher 换掉了，用karma-chrome-launcher。安装后，更改 Karma 配置中的browsers属性值为[&#39;Chrome&#39;]，测试运行成功。vue-unit-5有一些青色的 LOG，第一条使用 Vue 的应该都已经熟悉了，是浏览器控制台输出的 LOG，所以其他的也是浏览器的日志了。第 1、3、4 条 LOG 是有一个指令没有找到，第 2 条是关于路由的。指令和路由的引入是在项目入口的 js 文件内，可以预知如果我使用了其他类别的 Vue 插件也会报出 ERROR。还是有问题要解决啊！😒测试用例初次接触测试框架和断言，对于组件的测试用例也还在摸索中。从例子上看，大概思路如下：引入一个组件；创建一个用于测试的 Vue 实例，然后组件挂上去；对实例进行模拟操作，然后断言期望值。import Vue from 'vue'import SearchView from 'src/components/SearchView'describe('SearchView.vue', () =&gt; &#123; it('Input is normal', () =&gt; &#123; const vm = new Vue(&#123; el: document.createElement('div'), render: (h) =&gt; h(SearchView) &#125;) vm.key = '曾经的你' vm.$nextTick(() =&gt; &#123; expect(vm.$el.querySelector('.m-key').textContent).to.equal('曾经的你') &#125;) &#125;)&#125;)实际的项目中，针对复杂的逻辑或者异步操作，测试一定不会这么简单。😅下一步准备找一些 Vue 的开源项目，学习一下其中的测试用例写法。End!","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"Unit test","slug":"Unit-test","permalink":"http://imys.net/tags/Unit-test/"},{"name":"单元测试","slug":"单元测试","permalink":"http://imys.net/tags/单元测试/"},{"name":"Karma","slug":"Karma","permalink":"http://imys.net/tags/Karma/"},{"name":"Phantomjs","slug":"Phantomjs","permalink":"http://imys.net/tags/Phantomjs/"}]},{"title":"关于 text-transform: capitalize 失效的场景与解决方案","date":"2016-10-31T05:39:02.000Z","path":"20161031/text-transform-capitalize-not-working.html","text":"text-transform 是一个可以将文字进行大小写转换或单词首字符大写的 CSS 属性。自从知道了它，我就开始偷懒不在 js 中去在调用相关的转换函数了。昨天在给多说扩展用户 UA 功能时遇到一个 text-transform: capitalize 失效的问题，经过一番测试，找到了问题的原因。场景还原根据当时场景，抽取关键 css 属性：.capitalize &#123; text-transform: capitalize&#125;.before:before &#123; content: 'hello'&#125;.after:after &#123; content: 'world'&#125;现有如下的 HTML，你们猜最终会是什么结果？&lt;h1 class=\"capitalize\"&gt;hello world&lt;/h1&gt;&lt;h1 class=\"capitalize\"&gt;HELLO WORLD&lt;/h1&gt;&lt;h1 class=\"capitalize before\"&gt;world&lt;/h1&gt;&lt;h1 class=\"capitalize after\"&gt;hello&lt;/h1&gt;结果：Hello WorldHELLO WORLDHelloworldHelloworld问题DEMO链接：text-transform: capitalize 失效demo问题解析通过运行结果可以发现全小写单词组合时，转换没有任何问题，略过。大写单词组合全大写单词组合，转换失效？真的是这样吗？通过查阅相关文档，关于 capitalize 的介绍为：将每个单词的第一个字母转换成大写。看来是我们对它期望太高了，text-transform: capitalize并不能像 lodash 库中的转换函数那样，将全大写的的 AAA 转换成你期望的 Aaa。含有伪元素这也是我面临到的问题，每个 UA 标签上的 tootip 都是我用伪类模拟的。由于当时伪元素是绝对定位的，在视觉上真的是当作了另外的元素看待。而在问题 DEMO 中，我们还原了伪元素默认显示的位置：:before 就是在原始内容前追加内容，:after 就是在原始内容后追加内容。由于最后生成的内容之间没有间隙，导致 text-transform 转换时将其当作一个单词。为了验证我的结论，我在含有伪元素的内容前或后加了个空格：&lt;h1 class=\"capitalize before\"&gt; world&lt;/h1&gt;&lt;h1 class=\"capitalize after\"&gt;hello &lt;/h1&gt;最后转换成功：Hello WorldHello WorldDEMO解决方案虽然找到了问题的原因，但是实际场景中使用伪元素的初衷就是要将一个元素当作多个元素使用，HTML 中加空格会有半个中文字符宽度的空白，也就等于产生了不必要的边距。做到这里真是感觉不如直接写个 js 转换函数算了。function capitalize(string) &#123; return string.charAt(0).toUpperCase() + string.substr(1).toLowerCase()&#125;写出来后忽然发现这段代码完全可以用 CSS 去“实现”。.capitalize &#123; text-transform: lowercase;&#125;.capitalize:first-letter &#123; text-transform: uppercase;&#125;上个月旭哥博客有篇很详细的 :first-letter 介绍：张鑫旭：深入CSS :first-letter伪元素及其实例等其中提到了 :first-letter 和 :before 之间的猫腻，就是说 :first-letter 也生效于 :before 伪元素。不过我测试后发现，当 :before 伪元素设置为绝对定位时，:first-letter将只作用于原始内容。:first-letter和:before示例demo利用这个机制，总算可以给自己一个完美的答复了。.capitalize &#123; text-transform: capitalize&#125;.before &#123; padding-left: 2.5em&#125;.before:before &#123; position: absolute; left: 0; content: 'hello'&#125;.before:first-letter &#123; text-transform: uppercase&#125;.after:after &#123; position: absolute; content: 'world'; text-transform: capitalize&#125;附加内容在 :before 时，使用 :first-letter + uppercase 解决，如果原始内容有大写，需要再给原标签加 lowercase；附加内容在 :after 时，给 :after 再加 capitalize。DEMOEnd","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"},{"name":"text-transform","slug":"text-transform","permalink":"http://imys.net/tags/text-transform/"},{"name":"capitalize","slug":"capitalize","permalink":"http://imys.net/tags/capitalize/"}]},{"title":"使用“队列”解决“插队”业务场景","date":"2016-10-27T09:21:23.000Z","path":"20161027/use-queue-solve-continuous-request.html","text":"为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。我觉得用“插队”来描述这个场景真是再好不过了。队列既然有人要“插队”，我们就要定义一个规则：先进先出。也就是数据结构中的“队列”了。javascript 中队列的实现：// 实现1var queue = []// 进队queue.push(1)queue.push(2)queue.push(3)// 出队queue.shift() // 1queue.shift() // 2queue.shift() // 3// 实现2var queue2 = []// 进队queue2.unshift(1)queue2.unshift(2)queue2.unshift(3)// 出队queue2.pop() // 1queue2.pop() // 2queue2.pop() // 3实践定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。var requestQueue = []var XHR = function(method, url, param) &#123;&#125;点击操作的入口函数，先创建请求进队。因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。function myClick(method, url, param) &#123; var len = requestQueue.push(XHR(method, url, param)) if(len === 1) &#123; update() &#125;&#125;执行的永远是队列中的第一个请求。当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。如果存在未完成的请求，继续调用更新操作。function update() &#123; requestQueue[0].then(function(res)&#123; // request success requestQueue.shift() requestQueue.length &amp;&amp; update() &#125;)&#125;","tags":[{"name":"Promise","slug":"Promise","permalink":"http://imys.net/tags/Promise/"},{"name":"Request","slug":"Request","permalink":"http://imys.net/tags/Request/"},{"name":"HTTP","slug":"HTTP","permalink":"http://imys.net/tags/HTTP/"},{"name":"Queue","slug":"Queue","permalink":"http://imys.net/tags/Queue/"},{"name":"数据结构","slug":"数据结构","permalink":"http://imys.net/tags/数据结构/"}]},{"title":"java项目下基于webpack的前端开发环境构建","date":"2016-10-13T06:05:56.000Z","path":"20161013/java-webpack-dev-build.html","text":"标题可能不是很恰当，想不到一个合适的标题来概括我遇到以及解决的问题，暂且这样吧。项目描述是一个不完全与后端分离的基于 webpack 构建的 Vue 项目。项目入口是一个 jsp 页面，其中引用了一些 jsp 模版。我想是因为有一些内容需要后端直出到页面上。该页面上固定引用了 webpack 打包好的 css 及 js 文件路径，当然也加了动态参数用于刷新版本更新后的客户端缓存。可以使用 webpack 命令打包，或是用 webpack --progress --colors --watch 命令启动监听模式动态构建。这让前端开发环境变的不够友好：监听模式下修改文件后，是需要通过刷新页面获取更改的。好像回到了传统的前端开发环境中。解决方案由于入口页面是由后端渲染 jsp 生成的，用 html-webpack-plugin 插件生成 html 并注入脚本、样式的法子行不通了。热替换感觉没戏了，就想办法加个自动刷新吧。webpack-dev-server开始用 webpack-dev-server 代理后端服务器，可以实现监听更改、实时构建，但由于页面上的页面样式脚本引用与 webpack 构建好的文件路径匹配不上，还是获取不到更改。var webpack = require('webpack')var webpackDevServer = require('webpack-dev-server')var config = require('./webpack.config')var server = new webpackDevServer(webpack(config), &#123; hot: true, quiet: false, stats: &#123; chunks: false, colors: true &#125;, proxy: &#123; '**': 'http://localhost:8080' &#125;, historyApiFallback: true&#125;)server.listen(3000)跑了 3000 端口，页面上的文件引用依然是 8080 端口，好像是在后端就写死了。即使是我临时改了 jsp 文件的引用路径，还是需要手动刷新下页面才能获取更改。browsersync想起了 gulp 时代一直用的 browsersync，用它代理后端服务，监听文件变更并执行 webpack 命令，刷新浏览器。require('shelljs/global')var bs = require('browser-sync').create()bs.init(&#123; proxy: 'http://localhost:8080'&#125;)bs.watch('./src/**/*.*').on('change', function()&#123; exec('webpack', bs.reload)&#125;)但这样每次执行 webpack 命令，都相当于全新编译，所以速度很慢。以该项目而言，每次更改后需要等待 6s 才刷新浏览器。还实验了 gulp + webpack-stream，属于换汤不换药，每次还是全新编译。今天忽然想到，直接用 webpack 的监听模式启动，在每次编译后刷新浏览器就可以了。监听模式下，只有第一次是全新编译，之后会缓存未变化的模块，所以速度很快。var webpack = require('webpack')var webpackDevServer = require('webpack-dev-server')var config = require('./webpack.config')var bs = require('browser-sync').create()var compiler = webpack(config)bs.init(&#123; proxy: 'http://localhost:8080'&#125;)compiler.watch(&#123; aggregateTimeout: 300, // 300ms 内的文件更改聚合到一次构建中 ignored: /node_modules/, // 忽略大文件或基本不会变更的目录 poll: true &#125;, function(err, stats) &#123; bs.reload() console.log(stats.toString(&#123; chunks: false, colors: true &#125;))&#125;)监听模式除了命令行启动外，也可以使用 watch 方法调用，还可以通过 ignored 配置项忽略一些不会变更的目录。之后每次保存文件，只需要 100ms 左右就会刷新浏览器。感叹一句如今的前端把多少时间都耗在环境搭建上了~","tags":[{"name":"Java","slug":"Java","permalink":"http://imys.net/tags/Java/"},{"name":"jsp","slug":"jsp","permalink":"http://imys.net/tags/jsp/"},{"name":"Webpack","slug":"Webpack","permalink":"http://imys.net/tags/Webpack/"},{"name":"BrowserSync","slug":"BrowserSync","permalink":"http://imys.net/tags/BrowserSync/"}]},{"title":"如何为Canvas中特定图形绑定事件？","date":"2016-08-08T06:43:38.000Z","path":"20160808/canvas-event.html","text":"Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。这个思想同样也可以用在 Canvas 上，只需要为 canvas 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。isPointInPathcontext.isPointInPath(x, y);理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。var c = document.getElementById('canvas');var ctx = c.getContext('2d');ctx.rect(0, 0, 200, 200);console.log(ctx.isPointInPath(50, 100)) // true就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。产生路径的函数还有其他，比如：lineTo()、clip()、arc()、arcTo() 等。实现图形的事件绑定先来个简单的饼图吧。&lt;canvas id=\"c\" width=\"400\" height=\"400\"&gt;&lt;/canvas&gt;var canvas = document.getElementById('c');var ctx = canvas.getContext('2d');var r = canvas.width / 2;ctx.beginPath();ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3'; //蓝色ctx.fill();ctx.beginPath();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336'; //红色ctx.fill();function isInPath (x, y)&#123; ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y);&#125;canvas.addEventListener('click', function(e)&#123; if(isInPath(e.offsetX, e.offsetY)) &#123; console.log('hello') &#125;&#125;)现在创建一个红蓝拼接的饼图，isInPath 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出 hello。但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 hello，这是怎么回事呢？路径既然 isPointInPath(x, y) 的基于路径判断的，那我们就从路径入手。ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3';ctx.fill();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336';ctx.fill();当我们把画图时的 ctx.beginPath() 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。beginPath() 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。在 isInPath(x, y) 函数中，由于路径没有重置，所以最终最终判断的不止是 ctx.arc(r, r, r, 0, Math.PI * 1) 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。正确结果function isInPath (x, y)&#123; ctx.beginPath(); ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y)&#125;修改 isInPath 函数，加入重置路径，结果正确输出：示例Demo。实战示例鼠标悬浮显示区块数据的饼图。","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"Canvas","slug":"Canvas","permalink":"http://imys.net/tags/Canvas/"},{"name":"Event","slug":"Event","permalink":"http://imys.net/tags/Event/"}]},{"title":"VsCode插件：七牛图床工具，写文章更快一步","date":"2016-07-26T01:53:52.000Z","path":"20160726/vscode-extension-qiniu-upload.html","text":"前言一直以来，我都很少在文章中加插图。因为每加一张插图，我都需要先把图片上传到七牛，然后才能获取外链插入文章。之前写 Markdown 一直是用的 Sublime，直到 Vscode 最近一次更新有了 Tabs 之后，便开始尝试在工作中使用。与最初的预览版相比进步蛮大的，能看到很多 VS 的影子。之前也用过一段时间 Atom，虽然界面挺喜欢，但始终没有原生客户端的流畅感。到底客户端还是微软的强项，Vscode 这方面舒服多了，启动与大文件编辑都不比 Sublime 差。Vscode 是基于浏览器内核的跨平台编辑器，底层代码大部分都是 TypeScript，当然最终还是会编译为 javascript。这样对于一个前端而言就倍感亲切了，可以轻易的使用自己吃饭的语言去扩展功能。所以这个七牛图床工具就诞生了。vscode-qiniu-pv如何开始插件编写这里还是有必要把这个插件编写过程回顾一下，因为现在可供参考的中文资料实在不多。可以参考这篇文章 vscode编写插件详细过程 来完成插件开发环境部署和创建基本项目。项目配置以 Javascript 编写插件为例，这里我假设你已经建立了一个基础项目。就如我们经常在 github 上见到的前端或 Node 项目一样，都有一个 package.json 用于描述项目信息，也可以使用 npm 命令安装你需要的第三方库。此外这个文件中又包含了一些专属于 Vscode 的配置项。这里不在关注常规的 package.json 配置项，只介绍 Vscode 相关的。activationEvents插件在何时被激活。onLanguage:${language}：打开某种格式的文件时onCommand:${command}：输入某种命令时（Vscode中按F1）onDebug:${type}：调试某种语言类型时workspaceContains:${toplevelfilename}：当你的工作区包含某种文件时？*：任何时候，编辑器启动就激活描述可能有误，对应文档：Activation Events。contributesContributes 意思是贡献，这个属性中包含的都是可扩展点。keybindings：绑定按键来执行某个命令configuration：定义你的插件个性化配置menus：扩展菜单commands：用命令名执行某个命令……这四项应该是最常用的，更多：Contribution Points。OK，有了这些，大概可以为你的插件编写作构思了。&#123; // 插件何时被激活 \"activationEvents\": [ // 打开一个 Markdown 文件时，插件将被激活 \"onLanguage:markdown\" ], // 插件入口文件 \"main\": \"./extension\", // 扩展点 \"contributes\": &#123; // 按键绑定，当编辑区具有焦点且语言为 markdown 时，按 ctrl+q 执行 extension.qiniu.upload，也可针对 mac 平台独立配置 \"keybindings\": [&#123; \"command\": \"extension.qiniu.upload\", \"key\": \"ctrl+q\", \"mac\": \"ctrl+q\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'markdown'\" &#125;], // 插件配置属性，当你想要获取 qiniu 的配置时，以下所有 qiniu.xx 属性将合并于一个对象中 // title 和 description 将作为注释和属性提示分别在默认配置文件和用户配置文件中呈现 \"configuration\": &#123; \"type\": \"object\", \"title\": \"qiniu configuration\", \"properties\": &#123; \"qiniu.enable\": &#123; \"type\": \"boolean\", \"default\": false, \"description\": \"七牛图片上传工具开关\" &#125;, \"qiniu.access_key\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"一个有效的七牛 AccessKey 签名授权。\" &#125;, \"qiniu.secret_key\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"一个有效的七牛 SecretKey 签名授权。\" &#125;, \"qiniu.bucket\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"七牛图片上传空间.\" &#125;, \"qiniu.remotePath\": &#123; \"type\": \"string\", \"default\": \"$&#123;fileName&#125;\", \"description\": \"七牛图片上传路径，参数化命名。\" &#125;, \"qiniu.domain\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"七牛图床域名。\" &#125; &#125; &#125; &#125;&#125;以我的 package.json 为例，描述了以下信息：当你打开一个 Markdown 文件时，插件将被激活。执行 ctrl+Q 将启动一个命令，还有一个 when 属性，表示额外的命令激活条件。因为要上传到七牛，所以需要一些你的七牛用户信息，也就是 configuration，这可以在代码中方便的读取到。最后我需要以合适的方式获取你想上传的本地图片，以 Markdown 的图片格式写入到你的光标位置。编码插件的入口文件只有一个，也就是配置中的 &quot;main&quot;: &quot;./extension&quot;。一个基础的入口文件是这样的：var vscode = require('vscode');// 插件激活时执行function activate(context) &#123; // 注册命令 var disposable = vscode.commands.registerCommand('extension.hello', function () &#123; // 编辑器上方显示一条信息 vscode.window.showInformationMessage('hello!'); &#125;) // 加入释放队列？ context.subscriptions.push(disposable);&#125;exports.activate = activate;// 插件停用时执行function deactivate() &#123;&#125;exports.deactivate = deactivate;通过这个文件，可以发现 vscode 是个关键的对象，插件能做多少事都取决于这个对象可以提供多少接口支持。最初我是想通过复制命令实现功能的，也就是用户复制一个图片到编辑器，然后拦截剪贴板拿到图片路径上传、插入文档。事与愿违，Vscode 没有提供这方法的接口支持，见：Issues: Clipboard access through Extensions API。下面提到一个第三方包 node-copy-paste 也仅能访问字符串信息，只好作罢。Vscode 的接口调用大概分为两类：命令调用：Complex Commands API 和对象方法调用：vscode namespace API。前者很易用，比如预览 html 的示例：let success = await commands.executeCommand('vscode.previewHtml', Uri.parse('file:///some/path/to/file.html'));文档的示例是 TypeScript 写的，转换为 ES5 应该是这样：var success = commands.executeCommand('vscode.previewHtml', Uri.parse('file:///some/path/to/file.html')) .then(function(ret)&#123; // success &#125;, function(err) &#123; // error &#125;)如果能调用一个选择文件的窗口获取本地图片路径最好不过了。可我翻遍了文档，也只找到了一个选择文件夹的命令 vscode.openFolder，简直就是不想让你写的太轻松。最终只能使用一个输入框来接收本地图片路径，也就是预览图中的效果。以下是我用到的一些API：// 获取配置文件中的插件配置vscode.workspace.getConfiguration('qiniu')// 显示错误信息vscode.window.showErrorMessage('error')// 显示一个输入框，返回 Promise 对象vscode.window.showInputBox(option)// 编辑文件的函数，参数还是一个函数，这个回调函数的参数才是真正的可以用来增删文字的对象vscode.window.activeTextEditor.edit(function(textEditorEdit) &#123; // 在光标位置插入文本 // textEditorEdit.insert(editor.selection.active, img);&#125;)最终技术支持其实是 七牛SDK ヾ(･ω･`｡)。具体的代码可以去 Github 上看。安装打包、发布那篇文章中也提到了，我已经打包放到了 Github 仓库中，就是那个 ·vsix 文件。使用 Ctrl+O 选择插件包就可以安装了，在用户配置文件中加一下你的七牛配置，重启下就能用了，快捷键 ctrl+q。同时可以通过编辑器左侧插件面板在线搜索 qiniu-upload-image 安装。文件 -&gt; 首选项 -&gt; 用户设置，在右侧区域编写插件配置覆盖默认配置。配置文件示例如下，参考你的七牛用户信息填写：&#123; \"qiniu.enable\": true, \"qiniu.access_key\": \"xxxxxxxxxxxxx\", \"qiniu.secret_key\": \"xxxxxxxxxxxxx\", \"qiniu.bucket\": \"yourBucket\", \"qiniu.remotePath\": \"$&#123;fileName&#125;\", \"qiniu.domain\": \"http://xxx.xxxxx.com\"&#125;编辑器中鼠标悬浮会显示属性提示。Enjoy!","tags":[{"name":"VsCode","slug":"VsCode","permalink":"http://imys.net/tags/VsCode/"},{"name":"Qiniu","slug":"Qiniu","permalink":"http://imys.net/tags/Qiniu/"},{"name":"Markdown","slug":"Markdown","permalink":"http://imys.net/tags/Markdown/"}]},{"title":"对元素特性巧妙利用的一些例子","date":"2016-07-15T01:10:40.000Z","path":"20160715/clever-use-of-elements-feature.html","text":"在一些框架和库中都可见到一些创建一个空元素，通过对该元素特性测试来判定当前运行环境是否支持某种特性的运用。jQuery 也是以此来 support 各种环境，与其通过可被随意修改的 UA 测试环境倒不如直接创建元素测试来的准确。我们可利用元素本身特性去做的事并不止于 特性测试。细心一点，你会发现一些元素独一无二的特性可以被巧妙利用来做一些工作。HTML转义创建 Option 实例，传入要被转义的字符串。因为 Option 构造函数第一个参数为 text，所以任你传入任何 html 代码都会被转义为 textNode。new Option('&lt;div&gt;&lt;/div&gt;').innerHTML // \"&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;\"同理，给 div 的 innerText 赋值，再通过 innerHTML 取，也可以做到，只是看起来不如一行代码来的巧妙。var div = document.createElement('div');div.innerText = '&lt;a&gt;&lt;/a&gt;';console.log(div.innerHTML) // \"&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;\"解析URLa 标签天生支持这些 URL 属性，是不是像极了 NodeJS 中 URL 对象。var a = document.createElement('a');a.href = 'http://test.com:3000/a/b?k=1#dd';console.log(a.protocol); // \"http:\"console.log(a.host); // \"test.com\"console.log(a.hostname) // \"test.com\"console.log(a.port) // 3000console.log(a.pathname) // \"/a/b\"console.log(a.search) // \"?k=1\"console.log(a.hash) // \"#dd\"获取一串文字在浏览器中所占的宽度想知道宽度还不简单，扔到浏览器中跑一圈看看。var tester = document.createElement('div');tester.style.display = 'inline-block';tester.innerHTML = '博客：imys.net';document.body.appendChild(tester);console.log(tester.offsetWidth)display 属性一定要设置为 inline-block。因为 div:display 默认为 block，块级元素宽度默认等于父级元素宽度，这样获取到的宽度就不是字符的宽度了。当你想用 js 去截断一段长文字时，可以使用这个例子。判断canvas是否为空两个等宽等高内容相同的 canvas 所生成的 dataURL 是相同的，这样最终把对象的比较转换为字符串的比较。function isCanvasBlank(canvas) &#123; var blank = document.createElement('canvas'); blank.width = canvas.width; blank.height = canvas.height; return canvas.toDataURL() === blank.toDataURL();&#125;获取Computed styles这里的 Computed styles 不是指 getComputedStyle(element) 函数结果，而是像浏览器 Dev Tools 中 Styles 面板右侧的计算样式。是要获取最终被样式表影响的 css 属性，不包括标签默认属性和 user agent stylesheet。function filterInheritedStyles(el)&#123; var tester = document.createElement(el.tagName); document.body.appendChild(tester); // 元素必须插入到文档中才能计算出默认样式 var defaultStyle = window.getComputedStyle(tester, null); var currentStyle = window.getComputedStyle(el, null); var ret = &#123;&#125;; for(var k in currentStyle) &#123; if(currentStyle.getPropertyValue(k) !== defaultStyle.getPropertyValue(k)) &#123; ret[k] = currentStyle.getPropertyValue(k); &#125; &#125; document.body.removeChild(tester); return ret;&#125;创建一个标签相同的 Element 添加到文档中产生默认样式，与当前元素样式逐个比较，返回不一致的样式属性。不过这个函数还不是最终版的。当一个元素被插入到文档中时，由于没有添加 id 、 class 、style 属性，也就不会受 id 选择器、类选择器、行内样式影响，但显然会受标签选择器影响。所以如果能在返回值基础上对标签选择器属性进行过滤，才是最终结果。但目前通过 document.styleSheets 只限于获取内联样式表中规则，对于外部样式表中的规则检索还没有什么好的办法。暂时只知道这么多。针对前端复杂的客户环境，单就 特性测试 而言已经可以帮我们解决很多问题了。","tags":[{"name":"Html","slug":"Html","permalink":"http://imys.net/tags/Html/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"技巧","slug":"技巧","permalink":"http://imys.net/tags/技巧/"},{"name":"Element","slug":"Element","permalink":"http://imys.net/tags/Element/"}]},{"title":"获取移动设备旋转方向的几个方案","date":"2016-06-22T01:02:03.000Z","path":"20160622/screen-rotation-case.html","text":"某些偏门的 API 真是没有需求一辈子都不知道啊。分享一下最近对于获取移动设备旋转方向的探索。deviceorientationwindow.addEventListener('deviceorientation', function(e)&#123; console.log('absolute: ' + e.absolute) console.log('alpha: ' + e.alpha) console.log('beta: ' + e.beta) console.log('gamma: ' + e.gamma)&#125;);之前在 segmentfault 回答过相关问题，当时是从 MDN 翻出了这个事件。原贴：h5 页面如何获取手机陀螺仪的参数该事件在移动端兼容较好：Android Webview 4.3+、Chrome for Android 5.0、iOS 8.4+，据我测试微信也是支持的。没有在低端机上测试过，可能该事件会依赖设备传感器，可以加个 &#39;ondeviceorientation&#39; in window 判断一下。该事件触发频率高，适合对设备旋转精度要求较高的场景或是 3d 场景等，比如上面问题中的平衡球。orientationchange当设备的方向改变时，触发该事件。window.addEventListener(\"orientationchange\", function() &#123; console.log('angle: ' + screen.orientation.angle);&#125;);该事件是基于 2d 平面角度触发，输出仅有 0、90、270 3个数值，可以用来知晓当前设备的手持方向。至于为什么没有 360 这个角度，可能跟设备有关。我的手机怎么转都到不了 360 度，也就是竖屏时无法翻转。触发这个事件需要设备开启屏幕旋转，或者叫屏幕锁定，不同的设备叫法不一样。兼容性是个大问题，目前只发现手机上的 Chrome 可以使用，微信、iOS、以及一些双核国产浏览器都不兼容。screen.orientation通过上个事件让我发现了screen.orientation，在控制台输出后，发现它也有事件支持。console.log(screen.orientation) // &#123;angle: 0, type: \"landscape-primary\", onchange: null&#125;screen.orientation.onchange = function()&#123; console.log('angle: ' + screen.orientation.angle);&#125;通过对该对象输出，发现也可以使用 screen.orientation.type 判断设备方向。landscape-primary | landscape-secondary：横屏；portrait-primary | portrait-secondary: 竖屏；primary 表示向上或向右，secondary 表示向左或向下。之后测试该事件，手机 Chrome 和国产双核浏览器通过，生产环境下使用还不够理想。window.onresize完全是灵机一动想到的，设备旋转会使屏幕宽高置换，自然就会触发 resize 事件。window.onresize = function()&#123; console.log('innerWidth: ' + this.innerWidth + ' innerHeight: ' + this.innerHeight);&#125;通过屏幕宽高比较来判断横屏还是竖屏，设备兼容度毋容置疑。Media Queries最后就是 css3 媒体查询了。@media screen and (orientation: portrait)&#123; /* 横屏 */&#125;@media screen and (orientation: landscape)&#123; /* 竖屏 */&#125;如果仅仅是为了针对屏幕方向添加样式的话，使用媒体查询是最佳方案了。移动端使用也没有兼容问题，媒体查询从 IE9 就开始支持了。测试Demo测试Demo","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"Mobile","slug":"Mobile","permalink":"http://imys.net/tags/Mobile/"},{"name":"deviceorientation","slug":"deviceorientation","permalink":"http://imys.net/tags/deviceorientation/"},{"name":"orientation","slug":"orientation","permalink":"http://imys.net/tags/orientation/"}]},{"title":"javascript高阶函数介绍","date":"2016-05-30T15:02:08.000Z","path":"20160530/javascript-advanced-functions.html","text":"javascript 语言的特色之一便是函数即对象，因此便满足了高级函数的条件。高阶函数在《javascript设计模式和开发实践》中是这样定义的。函数可以作为参数被传递；函数可以作为返回值输出。实际上我们日常开发中会经常用到高阶函数。接下来通过几个经典的应用案例，带你认知高阶函数。回调函数提起回调，经典的应用莫过于 Ajax 异步请求。以 jQuery 为例。var getData = function(url, callback) &#123; $.get(url, function(data)&#123; callback(data); &#125;);&#125;由于网络请求时间的不固定性，我们不能确定请求完成的具体时间，那么解决的办法就是传递一个处理函数作为参数到请求数据的方法中，请求完成后执行回调函数。AOPAOP（面向切面编程）是著名的Java Spring框架中的核心概念之一。通过此编程模式可以在保持主逻辑代码不变的前提下，进行额外的功能拓展。在 Java 中使用 AOP 往往要通过一些高级特性来实现，而 javascript 就简单多了。比如测试一个函数的执行效率。var service = function()&#123; console.log('功能逻辑...');&#125;var test = (function()&#123; var time_start; return &#123; before: function()&#123; time_start = (+new Date()); console.log('计时开始...'); &#125;, after: function()&#123; var end = (+new Date()) - time_start; console.log('计时结束，用时：' + end); &#125; &#125;&#125;)();var aop = function(fn, proxy)&#123; proxy.before &amp;&amp; proxy.before(); fn(); proxy.after &amp;&amp; proxy.after();&#125;aop(service, test);// 计时开始...// 功能逻辑...// 计时结束：1柯里化在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这概念着实让我琢磨了半天，转换成代码大概是这样的。fn(1, 2, 3, 4) -&gt; fn(1)(2)(3)(4)() 假设这个函数是用于求和，那么就是把本来接收多个参数一次性求和的函数改成了接收单一参数逐个求和的函数。这样是不是容易理解了。来实现一个柯里化求和函数。var currying = function(fn)&#123; var args = []; return function()&#123; if(!!arguments.length) &#123; [].push.apply(args, arguments); return arguments.callee; &#125; else &#123; return fn.apply(this, args); &#125; &#125;&#125;var sum = (function(num)&#123; var ret = 0; return function()&#123; for(var i = 0, len = arguments.length; i &lt; len; i++) &#123; ret += arguments[i]; &#125; return ret; &#125;&#125;)();var newSum = currying(sum);newSum(1)(2)(3)(4)() // 10看起来挺巧妙，但是这种案例明摆着就像不从实际出发的面试题。那再看下一个例子。var find = function(arr, el)&#123; return arr.indexOf(el) !== -1;&#125;一个简单的函数用于查询数组中是否某个值，每次使用都需要这样调用。find(arr, 1);find(arr, 2);既然 arr 是个固定参数，那么我们可以先保存一个接收过 arr 的函数，再用这个函数去处理变化的参数。var newFind = currying(find)(arr);newFind(1);newFind(2);反柯里化与柯里化相对应。柯里化是为了缩小适用范围，创建一个针对性更强的函数；反柯里化则是扩大适用范围，创建一个应用范围更广的函数。对应的代码转换就变成这样。fn(1)(2)(3)(4) -&gt; fn(1, 2, 3, 4) 实例Array.forEach = function()&#123; var fn = [].pop.call(arguments); var arr = arguments.length &gt; 1 ? arguments : arguments[0]; return [].forEach.call(arr, fn);&#125;Array.forEach(1, 2, 3, function(i)&#123; console.log(i); // 1 2 3&#125;);Array.forEach('123', function(i)&#123; console.log(i); // 1 2 3&#125;);Array.forEach(&#123; '0': 1, '1': 2, '2': 3, 'length': 3&#125;, function(i)&#123; console.log(i); // 1 2 3&#125;);类数组借用 Array 原型函数，是很常见的应用了。这个例子应用 call 函数提取出一个新的函数，可以接收更多的参数和类型，适用性更广。函数节流函数节流也不算很厉害的技巧了，平常写代码严谨的人应该都有此类应用的经历。比如页面滚动加载数据的场景。当页面滚动到底部时，会触发 Ajax 去请求数据；当页面滚动频繁时，就可能出现上个请求还未结束又开始了一个新的请求。这个时候就需要用函数节流了。var getData = (function()&#123; var onAjax = false; // 是否开始 ajax return function(callback)&#123; if(!onAjax) &#123; onAjax = true; $.get('/xxx', function(data)&#123; callback(data); onAjax = false; &#125;); &#125; &#125;&#125;)();$(window).scroll(function()&#123; if(滚动到底部) &#123; getData(render); &#125;&#125;);分时函数与函数节流一样，分时函数也是用来解决函数频繁执行带来的性能问题。不同的是，函数节流场景为被动调用，分时函数为主动调用。就算一个列表展示页面没有使用分页组件，也会像上个例子那样触发式分组渲染。而如果真的遇到需要一次性把所有数据渲染到列表时，大量的 DOM 创建会对浏览器造成极大开销，或卡顿、或假死等。该处理是否必须同步完成？数据是否必须按顺序完成？如果以上两个问题都为“否”的话，为何不尝试分割这个处理过程。// arr: 源数据// process: 处理函数// count: 每次抽取个数var chunk = function(arr, process, count)&#123; setTimeout(function()&#123; for(var i = 0; i &lt; Math.min(count, arr.length); i++) &#123; process(arr.shift()); &#125; if(arr.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100);&#125;创建一个队列，使用定时器取出下一批要处理的项目进行处理，接着在设置另一个定时器。一旦某个函数需要花 50ms 以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。惰性加载当你逛网店发现了心怡的商品时，是立刻收藏或加购物车，还是等到买的时候再搜索相关商品一个一个的找到它？浏览器特征检测是前端开发中必不可少的，比如返回顶部，我们需要区分火狐和其他浏览器来决定 scrollTop 应当设置给谁。// 新手var gotop = function()&#123; if(/firefox/i.test(navigator.userAgent)) &#123; document.documentElement.scrollTop = 0; &#125; else &#123; document.body.scrollTop = 0; &#125;&#125;// 老司机var gotop = (function()&#123; var isFF = /firefox/i.test(navigator.userAgent); var docEl = document[ isFF ? 'documentElement' : 'body' ]; return function()&#123; docEl.scrollTop = 0; &#125;&#125;)();浏览器的特征是保持不变的，既然如此为什么不一开始就保存下来呢。与此同理，日常编程中要注意缓存那些经常使用、改变较少或不做改变的内容。参考《JavaScript设计模式与开发实践》《JavaScript高级程序设计》 第三版JS函数式编程指南 - 柯里化《编写高质量代码：改善JavaScript程序的188个建议》","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://imys.net/tags/Function/"}]},{"title":"Hexo添加站内搜索功能初步完成","date":"2016-05-11T08:08:50.000Z","path":"20160511/hexo-search.html","text":"不止一次有同学在 Issues、邮件等渠道中向我反馈增加站内搜索功能。本来准备什么时候搞个 2.0 版的主题再加上这些新功能，可一直没什么太好的想法，反正也是折腾，就把搜索功能做了一下。搜索方案针对无数据库的静态博客搜索方案一般有两种：第三方搜索服务；序列化站点内容作为数据源，然后自己写查询方法。第三方搜索服务基于搜索引擎的包括 Google 和百度提供的站内搜索，比如 Hexo 文档中的辅助函数 search-form 就提供了一个 Google 搜索框。搜索结果取决于该搜索引擎对你站点的收录情况。抛开其他原因来讲，没有颜值的搜索服务我是不会考虑的。接着我实验了一下在 Hexo 中有用户基础的 Swiftype 和 Hexo 官网使用的 Algolia。SwiftypeSwiftype 安装很简单，关于其在 Hexo 中使用的文章介绍也很多，我只说下使用体验。配合我自定义的搜索框样式，外观展现还算过关。可以对色调进行修改，由于是在单页面展示搜索结果，就算不提供外观修改也可以自己重写 css ，类似多说。Swiftype-colors搜索结果的展示可以自定义，包括内容布局、字段排列、分页等。Swiftype-results搜索结果容器可完全自定义，可设置单页或新页面显示搜索结果，对外观的控制力更强。Swiftype-container可以设置字段权重，比如优先展示文章标题的匹配结果。Swiftype-sort可以单独为某个关键字搜索结果进行管理，比如排序、置顶、删除等等，话说某度推广不就是这样吗。Swiftype-rank可以设置抓取规则，比如只抓取文章页。Swiftype-rules默认的字段匹配不满意，下图是对hexo的搜索结果。Swiftype 的body字段默认抓取整个页面，我每个页面的左侧 footer 都有hexo这个单词，在我设置了只抓取文章页后，博客一共 46 篇文章也就匹配了 46 个结果。我期望它只对文章内容检索，这样更精准。Swiftype-show如果能自定义抓取字段，指定抓取内容当然是极好的。Swiftype 文档中也提供了这方面内容，Crawler。大概看了一下，感觉 Content Inclusion/Exclusion 和 Meta Tags 方式应该能满足需求。我也尝试了一下，发现没效果，不知道是不是要重新抓取才生效。设置重新抓取后等了 1 个小时还没什么效果，我只好先进行下一步了。AlgoliaAlgolia 我只注册了账户，然后就没有然后了。。。因为我准备使用方案2了。从 Algolia 管理界面和文档上来看不会比 Swiftype 差，可留作备选。自定义搜索没有数据库的前提下实现查询，也可以使用数据文件做数据源。Hexo 中也有这方面的先驱者，在 Hexo-Plugins 页可以找到生成数据文件的两个插件，hexo-generator-json-content 和 hexo-generator-search。hexo-generator-json-content 生成的数据文件为json格式。meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;]hexo-generator-search 生成的数据文件为xml格式。&lt;search&gt; &lt;entry&gt; &lt;title&gt;Post title&lt;/title&gt; &lt;url&gt;http://yourposturl.html&lt;/url&gt; &lt;content type=\"html\"&gt;helloworldhelloworldhelloworldhelloworldhelloworldhelloworld&lt;/content&gt; &lt;/entry&gt; &lt;entry&gt; &lt;title&gt;Post title&lt;/title&gt; &lt;url&gt;http://yourposturl.html&lt;/url&gt; &lt;content type=\"html\"&gt;helloworldhelloworldhelloworldhelloworldhelloworldhelloworld&lt;/content&gt; &lt;/entry&gt;&lt;/search&gt;对于 js 语言来说还是解析 json 更方便，如果需要用xml做数据文件我完全可以使用已有的atom.xml。hexo-generator-json-content 生成的json数据内容挺全的，不过并不是我都需要的。可以通过添加站点配置设置你需要生成的字段。meta是站点信息，pages是除文章页以外的页面信息，这都是我不需要的，我只要求搜索文章页。此外，文章页的字段也可以根据需求减少，以减小数据文件大小。下图可以直观看出每个字段表示的内容。hexo-generator-json-contentslug、comments、link、keywords、categories都是无内容或不需要的字段；date和updated、path和permalink留其一即可；excerpt可以不要，因为我们要检索文章全文；raw是markdown元数据，content是包含html标签的文章内容，处理起来最方便的是text纯文本。最后的配置如下，需要放到hexo/_config.yml中。jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true接着就是实现查询方法并把结果渲染到页面。// xhr加载数据function loadData(callback) &#123; // 略...&#125;// 匹配文章内容返回结果function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regExp.test(post.title) || post.tags.some(function(tag) &#123; return regExp.test(tag.name); &#125;) || regExp.test(post.text);&#125;// 渲染到页面function render(data) &#123; // 略...&#125;// 查询function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125;正则加上filter、some两个数组过滤函数，就这么简单。也没想做太复杂，否则匹配结果高亮、匹配片段截取又够折腾半天。完成后就是现在博客的搜索了，PC 端浮动面板显示，Mobile 端全屏显示。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"}]},{"title":"Vue中的数据交互","date":"2016-05-03T09:39:44.000Z","path":"20160503/vue-data-interaction.html","text":"在 Vue 中通常以一个 Vue 实例来表示一个应用，一个应用由若干个组件拼装而成。没错，就像“装机”一样。当你把主板、CPU、显卡、内存、散热器、SSD、电源等摆放到机箱的各个位置后，很明显产生了一个明确的需求：我怎么让这些东西协同工作？回到 Vue 中，处理不同组件之间的数据或状态是一件经常遇到的事。好在 Vue的文档 足够详细。关于组件交互的部分，如果没有实际需求，我表示难以明白props以及自定义事件等使用场景是什么。Propsprops是定义在子组件中的属性，用来定义期望从父组件传下来的数据。从实际场景着手，写一个简单的需求。&lt;!-- 子组件模板 --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123;helloWorld&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;template&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt;当父组件中输入内容时显示到子组件中。这时，我需要在子组件中声明一个 props 属性来接收父组件中输入的内容。// 子组件module.exports = &#123; props: &#123; helloWorld: String &#125;&#125;;// 父组件module.exports = &#123; components: &#123; child: require('child') &#125;, data: function()&#123; return &#123; text: '' &#125; &#125;&#125;;还需要告诉子组件，它的 props 对应父组件中的哪个数据。&lt;!-- 在子组件上标记 --&gt;&lt;child :hello-world=\"text\"&gt;&lt;/child&gt;camelCase 格式属性用作 HTML 特性时需要转换成 kebab-case 格式。当前需求轻松的解决了！有没有发现 props 好像是单向的，父 -&gt; 子？不，并不是。只是默认是单向的。可以通过添加额外的修饰符来显示强制双向或单词绑定。&lt;!-- 双向绑定 --&gt;&lt;child :hello-world.sync=\"text\"&gt;&lt;/child&gt;&lt;!-- 单次绑定 --&gt;&lt;child :hello-world.once=\"text\"&gt;&lt;/child&gt;而正像 Vue 文档中所说的，默认单向绑定是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。举个例子，如果当前子组件设置为双向绑定，另有其他的子组件依赖父组件的helloWorld属性。这种关系下如果子组件修改了数据，势必引起其他子组件的状态改变。某些场景下我们并不希望发生这种情况。自定义事件使用自定义事件也可以实现父子组件之间的通信，通过事件触发的形式来传递数据。使用$on()监听事件；使用$emit()在它上面触发事件；使用$dispatch()派发事件，事件沿着父链冒泡；使用$broadcast()广播事件，事件向下传导给所有的后代。现在变更需求，把输入框拿出来作为子组件B。&lt;!-- 子组件B模板 --&gt;&lt;template&gt; &lt;input type=\"text\" &gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;template&gt; &lt;child-b&gt;&lt;/child-b&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt;当子组件B内容变化时，我应当通知父组件：头儿，我的工作完成了。&lt;template&gt; &lt;input type=\"text\" v-model=\"text\" @change=\"onInput\"&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: function () &#123; return &#123; text: '' &#125; &#125;, methods: &#123; onInput: function () &#123; if(this.text.trim()) &#123; this.$dispatch('child-next', this.text); &#125; &#125; &#125;&#125;;&lt;/script&gt;父组件收到通知后，广播给其他需要的子组件：B已经完成XXX了，剩下的东西交给你了。module.exports = &#123; components: &#123; child: require('child'), 'child-b': require('childB') &#125;, events: &#123; 'child-next': function (text) &#123; this.$broadcast('child-finish', text); &#125; &#125;&#125;;或者为了能从父组件中直观的看出事件来源，可以使用显示声明绑定事件。&lt;template&gt; &lt;child-b @child-next=\"handle\"&gt;&lt;/child-b&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; components: &#123; child: require('child'), 'child-b': require('childB') &#125;, methods: &#123; handle: function (text) &#123; this.$broadcast('child-finish', text); &#125; &#125;&#125;;&lt;/script&gt;接收广播的子组件，需要添加对应的处理事件。&lt;template&gt; &lt;p&gt;&#123;&#123;helloWorld&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: function () &#123; return &#123; helloWorld: '' &#125; &#125;, events: &#123; 'child-finish': function (text) &#123; this.helloWorld = text; &#125; &#125;&#125;;&lt;/script&gt;与 props 方式相比，自定义事件的方式各个组件的数据独立，不会被父或子组件轻易修改。因为我们能控制在何时进行事件派发和广播。当然这两种方式并不冲突，可以结合使用来创造最佳实践。Vuex最后就是使用大杀器 Vuex 了。不管是props还是自定义事件，如果数据要由子组件到另一个子组件中，都要进行父组件的中转。随着项目的逐步增大，数据流也会变得复杂，难以管理和发现问题。而 Vuex 就是独立的一个数据管理层。你需要把组件的本地状态和应用状态区分开来，把应用状态交由 Vuex 来管理，方便每一个组件去交换数据更新状态。这是一个简单的例子","tags":[{"name":"Vue","slug":"Vue","permalink":"http://imys.net/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://imys.net/tags/Vuex/"}]},{"title":"一个HTML元素可以做什么？","date":"2016-04-13T08:37:53.000Z","path":"20160413/one-element-can-do-much.html","text":"自 CSS3 问世以来，在广大开发者的智慧下诞生了很多创造性的设计，如：18个你可能不相信是用CSS制作出来的东西。个人平时也喜欢收藏这些有趣的东西，其中一些设计对单个 HTML 元素的极限利用，很值得我们去学习。以下就来说一说这些神奇的黑科技。伪元素伪元素是比较常见的单元素利用了，:before与:after基本上支持普通元素的所有 CSS 属性，它使 1 个元素可以当作 3 个元素来使用。比如制作一个单元素的菜单图标，三条线。.icon-menu &#123; position: relative;&#125;.icon-menu,.icon-menu:before,.icon-menu:after &#123; width: 1em; height: .25em; background: #666;&#125;.icon-menu:before,.icon-menu:after &#123; content: ''; position: absolute; left: 0;&#125;.icon-menu:before &#123; top: .3125em;&#125;.icon-menu:after &#123; top: .625em;&#125;在辅以圆角、CSS三角等，一些看起来复杂的图标也不是不能实现。Github 早已有 css 图标的项目了：Cikonss。实际场景中的应用不限于此，如：下拉菜单上的三角箭头、时间线上的圆点标记（在我的博客归档页就是此种）等。当你需要添加一些无内容的修饰性元素时，你就该想到使用伪元素。但也不是说有内容的用伪元素无法实现，一些静态的展示内容也可以用，可以利用伪元素content属性。比如一个带统计数量的badge，对应的 html 可以这样写。&lt;span data-count=\"10\" class=\"badge\"&gt;消息&lt;/span&gt;在 css 中利用伪元素展示自定义属性。.badge:after &#123; content: attr(data-count); /* ... */&#125;我的博客 PC 端文章页右侧的分享所用的 tips 就是利用伪元素纯 css 实现的。borderborder实现 css 图形的案例已经屡见不鲜了，实际应用中常用的还是三角形。既然提到了border，也应该顺带提下outline。两者都可以肆意的实现各种长短粗细的线条，一些特殊的场景中一条粗边框就可当作一个矩形来利用。还拿菜单图标来说，设置上下两个边框样式，outline 在画上一条，可以通过outline-offset来调整间距，是不是也能凑出一个图标呢。除了使用border绘制多边形外，其实扇形、弧线也是可以很容易实现的。/* 扇形 */.sector &#123; width: 0; height: 0; border: 30px solid #000; border-top-color: transparent; border-bottom-color: transparent; border-radius: 50%;&#125;/* 弧线 */.arc &#123; width: 40px; height: 40px; border: 1px solid #000; border-top-color: transparent; border-bottom-color: transparent; border-radius: 50%;&#125;具体是什么效果，自测吧。扇形、弧线可以轻易的制作一个 loading 效果：css实现的各种loading效果。box-shadowbox-shadow可以设置元素阴影效果，且可以设置多组值。但是我万万没有想到它居然强大如斯：1个元素实现的像素画。先看下box-shadow的文档介绍压压惊。box-shadow: [inset] offset-x offset-y [blur] [spread] [color];值说明inset可选，默认阴影在边框外。使用inset后，阴影在边框内（即使是透明边框），背景之上内容之下。offset-x/offset-y必需，用来设置阴影偏移量。offset-x设置水平偏移量，如果是负值则阴影位于元素左边。offset-y设置垂直偏移量，如果是负值则阴影位于元素上面。如果两者都是 0，那么阴影位于元素后面。这时如果设置了blur或spread则有模糊效果。blur可选，模糊距离。值越大，糊糊面积越大，阴影就越大越淡。 不能为负值。默认为 0，此时阴影边缘锐利。spread可选，阴影的大小。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。color可选，阴影的颜色。平常使用中一般会设置 4 个值来实现阴影效果，即offset-x、offset-y、blur、color。从属性介绍中看当blur省略后，默认值为 0，边缘锋利，也就是小方块的效果。而通过设置每一组offset-x、offset-y的偏移值，加上不同的颜色设置，的确是实现像素画的绝妙之想。当前博客的404页面就是用box-shadow堆叠出来的。相关资源分享：singledivcss图形26个字母原来这个世界还有另外一种 css：别人手中的 css。","tags":[{"name":"Html","slug":"Html","permalink":"http://imys.net/tags/Html/"},{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"}]},{"title":"CSS实用Tips","date":"2016-04-06T09:42:48.000Z","path":"20160406/css-tips.html","text":"作为自己做前端开发以来的CSS爬坑总结，内容偏向PC端，不定期补充。只作提示，不深谈。盒子模型1、区分content-box和border-box的尺寸计算。2、行级元素无宽高，但可设内外边距。3、外边距margin可设负值，内边距padding不可以。4、当内外边距值为百分比时是相对于元素宽度计算的。5、border是个好玩的东西，关键字：css三角形。定位与布局1、添加了position: absolute与float样式后，元素会隐式改变display属性为inline-block，可以设置宽高属性，不需要再显示设置display。2、清除浮动，一般有clear: both/left/right和overflow: hidden。首选clear，如果目标区块存在溢出元素时，会被overflow: hidden截断。3、绝对定位的元素，在top、right、bottom、left属性未设置时，默认为auto，在文档流中紧跟前一个元素。这个特性通常可以实现一些神奇的效果。4、尽量为每一个定位元素合理分配z-index，特别是relative元素。按级别一般为：主体内容 &lt; 下拉列表、日历等与主体紧密联系的内容 &lt; 浮动的头部或左右导航、工具栏等 &lt; 遮罩、模态窗口等。遵循这个规则能少踩很多坑。5、绝对定位的元素可以溢出添加了overflow: hidden的父容器且不被截断；绝对定位的起始点是参照离其最近的祖先定位元素，一直到body。6、隐藏元素一般用display: none、visibility: hidden，使用CSS3过渡和动画时首选visibility。因为display只有两个状态改变none -&gt; block/inline-block/...，没有值域的变化（我是这么理解的），visibility在底层实现中是有一个 0-1 的变化。7、当IE&lt;=7时，遇到定位布局问题，你可能需要了解haslayout与层叠上下文。8、在移动端开发中，使用Flexbox新旧语法混合是很好用的布局解决方案。选择器1、一些简单的交互效果就不需要用js去实现了，灵活使用选择器就可以搞定。如：鼠标悬浮于一个元素时显示某个子元素或兄弟元素、输入框具有焦点时显示输入提示、CSS模拟单复选框等。2、jquery中有的选择器，基本上也能在CSS中使用或找到替代方案。3、链接的伪类样式要按照link、visited、hover、active顺序设置，移动端用active代替hover。4、除了首元素、末元素外，还有首行选择器:first-line和首字符选择器:first-letter。5、使用子元素伪类选择器:nth-child(n)可以按照你的规则选取任意组合的子元素。6、伪元素选择器:before/:after可以把一个元素当作三个元素使用，需注意某些元素不支持该选择器。其属性content为必设值，可以是字符串或使用attr()插入元素属性值、使用url()插入图像等。排版与修饰1、文本处理：大小写转换text-transform、文字截断text-overflow、改变文本流方向direction、书写方向writing-mode、换行处理white-space等。2、当font-weight设为数值时，需要对应的字体有该数值字重支持，否则无效。bold等价于700数值。3、垂直对齐vertical-align是个资深奇葩，各个浏览器解析均有差异。除了一些固有属性值外，还可以设数值、百分比。4、你想设置2个边框吗？使用outline吧。5、浏览器字体最小基准是12px。6、设计图中的一些字体效果，可以尝试用text-shadow实现，减少图片应用。7、使用CSS3时遵循渐进增强原则，对于不支持的浏览器保证布局无错乱、功能正常使用。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"}]},{"title":"使用HTML5 history API增强移动端用户体验","date":"2016-03-16T06:42:51.000Z","path":"20160316/use-history-pushState.html","text":"起因最近做的一个图片浏览功能，请自行脑补手机图库、微博查看图片等场景。功能做好之后，马上有同学反应：进入图片浏览层时，如果用户触摸手机后退按钮，整个页面都会返回，能否在触摸返回时只关闭浏览层？一般移动端会对 WebView 做一些默认的设置，比如 Hook 用户触摸后退按钮，调用 WebView 后退方法。既然如此，就可以利用这一点，通过操纵浏览记录使用户触摸后退关闭浏览层。history想要操纵浏览记录，就不得不提history对象了。通过常用的back()、forward()、go()方法就可以自由的控制浏览器跳转到任意一个历史记录。而在 HTML5 中，history 又添加一些新的成员，允许你对浏览记录进行添加和修改却不会刷新页面，这就是解决问题的关键了。history.pushState(stateObj, title, url) 用于创建新历史记录；history.replaceState(stateObj, title, url) 用于修改当前历史记录；history.state 读取当前状态，创建历史记录时会添加状态对象；window.onpopstate 是一个事件，当历史记录被修改时会触发。简单实现&lt;div id=\"container\"&gt;&lt;/div&gt;就把这个 div 看作一个图片浏览层吧，样式脑补。function Demo(id) &#123; this.el = document.getElementById(id);&#125;Demo.prototype = &#123; constructor: Demo, show: function() &#123; // 处理显示的代码... this.el.classList.add('in'); &#125;, hide: function() &#123; // 处理隐藏的代码... this.el.classList.remove('in'); &#125;, useState: &#123; show: function() &#123; // 参数1是 Object 类型，可以被 history.state 读取 // 参数2是标题，在一些浏览器中会被忽略，象征性的传空就可以了 // 参数3是新记录的地址，会在末尾追加，如：http://test.com/demo history.pushState(&#123; page: 'demo' &#125;, '', '/demo'); // 调用真正的显示方法 this.show(); &#125;, hide: function() &#123; // 返回上一条历史记录 history.back(); &#125; &#125;, bindEvent: function() &#123; var _this = this, handelShow = this.show, handelHide = this.hide, imgs = document.getElementsByTagName('img'), // 假设图片浏览层上有一个 .back 后退按钮 back = document.getElementsByClassName('back')[0]; // 加个判断避免兼容性问题 if(history.pushState) &#123; // 如果可以使用 history API 就重新赋值 handelShow 和 handelHide handleShow = this.useState.show.bind(this); handleHide = this.useState.hide.bind(this); // history.state 变化时触发，假设初始 URL = http://test.com window.onpopstate = function(e) &#123; // 这里的 e.state 和 history.state 等价的 if(!e.state) &#123; // 无状态时隐藏 _this.hide(); console.log(document.location); // http://test.com &#125; else if(e.state.page === 'demo') &#123; // 如果是自己定义的状态就显示 _this.show(); console.log(document.location); // http://test.com/demo &#125; &#125;; &#125; // 给图片绑定事件 [].forEach.call(imgs, function(img)&#123; img.addEventListener('touchstart', function() &#123; handelShow(); &#125;); &#125;); // 图片浏览层上的后退事件 back.addEventListener('touchstart', function() &#123; handelHide(); &#125;); &#125;&#125;;// 调用new Demo('container');执行history.pushState()时不会触发window.onpopstate，只有前进forward()、后退back()时才会触发，所以在之后还需要调用显示的方法。对于不支持history.pushState的浏览器执行的还是原来的显示和隐藏方法，handleShow和handleHide在判断内才被重新赋值。通过在window.onpopstate判断history.state来执行不同的操作，当然你也可以判断location。以上代码未经测试，只作思路展示，注释说明了一切。应用场景在 SPA 场景中，history 早已大显神通。与history.state相似的还有location.hash，也有其对应的事件window.onhashchange，一般用于处理 IE 低版本的兼容。抛开本篇描述的功能需求，类似的场景也可以运用。比如左侧导航在原生APP都是可以通过触摸返回来关闭，在浏览器中也可以模拟这种操作体验。","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"History","slug":"History","permalink":"http://imys.net/tags/History/"},{"name":"用户体验","slug":"用户体验","permalink":"http://imys.net/tags/用户体验/"}]},{"title":"阿里云搭建Git服务，实现Hexo自动部署","date":"2016-03-03T08:33:19.000Z","path":"20160303/hexo-nginx-auto-deploy.html","text":"使用 gitcafe pages 更新博客只需要敲几条命令，如果因为博客搬到了阿里云，却没有原来操作方便，那便得不偿失了。所以就准备在服务器上建个 Git 远程仓库，用 Git Hooks 实现自动部署。Git HooksGit Hooks 就是一些触发特定事件的脚本。比如 commit、push、merge 等等，也区分本地 Hooks 和服务端 Hooks。我这次使用的是post-receive。当用户在本地仓库执行git-push命令时，服务器上远程仓库就会对应执行git-receive-pack命令，而git-receive-pack命令会调用pre-receive钩子。这需要在服务器上建立一个 Git 远程仓库，和一个用于获取更新（git pull）的本地仓库。远程仓库：最原始的版本库，所有的本地仓库就可以克隆这个仓库。就像你在 Github 创建一个项目，这就是一个远程仓库。本地仓库：这个就是平常的工作目录，容易理解。总体的流程为：本地执行git push；Git 服务器更新并 Hook；执行pre-receive脚本，命令为：定位到服务器本地仓库目录，执行git pull。我的 git 已经安装了，Ubuntu 安装很简单：sudo apt-get install git 创建 git 用户，用来运行 git 服务：sudo adduser git 用 git 用户运行貌似是约定俗成的事，像 github 一个仓库的 URL 为git@github.com:user/project.git，@ 符号前面的 git 就是运行 git 服务的用户名。初始化远程仓库：我的目录名为website，仓库名为blog，以此为例。cd /website sudo git init --bare blog.git 远程仓库名以.git结尾。还需要给 git 用户设置该目录的权限：sudo chown -R git:git blog.git 出于安全考虑，禁用 shell 登录：vi /etc/passwd 找到这一行：git:x:1002:1002:,,,:/home/git:/bin/bash 修改为：git:x:1002:1002:,,,:/home/git:/usr/bin/git-shell 可以使用git-shell，通过ssh使用 git，但无法使用 shell 登录。创建证书登录，把本地公钥添加到/home/git/.ssh/authorized_keys。不过默认的id_rsa公钥一般都被占用了，可以再建个其他名字，创建.ssh/config区分。初始化服务器本地仓库：我是在远程仓库旁边建立的。cd /website git clone blog.git 因为是在同一台电脑上，所以克隆直接使用本地路径。这将会在website生成一个名为blog本地仓库。ls -la 可以看到当前路径下有一个blog.git目录和一个blog目录。考虑到 git-hooks 运行使用的是 git 用户，也对服务器本地仓库授权：chown -R git:git blog 设置 hook 执行脚本：vi blog.git/hooks/post-receive 输入以下内容：#!/bin/sh cd /website/blog git pull origin master 很好理解，就是定位到服务器本地仓库然后拉取更新。保存后赋予可执行权限：chmod +x blog.git/hooks/post-receive 现在可以在本地（你的电脑上）进行测试了。找一个目录，进行版本库克隆：git clone git@server:/website/blog.git server 是你的服务器域名或者IP。因为仓库还没有内容，所以会显示：You appear to have cloned an empty repository. 你克隆了一个空仓库。现在可以随便创建点东西，push 到远程仓库，然后到/website/blog目录下看看有没有变化。我在操作的时候遇到一个错误：fatal: Not a git repository: ‘.’因为 hook 脚本执行了 cd 之后，继续执行 git 语句拉取的时候还是在 hooks 文件夹下，而不是 cd 的文件路径。修改后的脚本如下：#!/bin/sh unset GIT_DIR #还原环境变量 cd /website/blog git pull origin master 现在已经实现本地到远程服务器的同步了，只差一个 Web 服务器了。Nginx安装配置目前我的博客在 gitcafe 上，在 URL 后面随便加点后缀进入 404 页面，可以清楚的看到 nginx/1.8.0 的字样。以后还要玩负载均衡，服务器肯定就选它了。sudo apt-get install nginx 看了很多文章，发现其中描述的 Nginx 的文件结构都不太一样，看来跟系统环境有关系。我的目录结构如下，环境是阿里云 Ubuntu 14.04 ：所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下启动程序文件在/usr/sbin/nginx日志放在了/var/log/nginx中，分别是access.log和error.log在/etc/init.d/下创建了启动脚本nginx默认的虚拟主机的目录设置在/usr/share/nginx/html启动 Nginx ：sudo /etc/init.d/nginx start 默认的服务器配置是 80 端口，如果你没有其他的 Web Server 在运行，打开服务器域名或 IP 应该可以看到Welcome to nginx!现在定位到配置文件，修改配置：vi /etc/nginx/nginx.conf 找到server { ... }区域：server &#123; listen 80; #端口 server_name localhost yoursite.com; #域名或IP root /website/blog; #站点根目录 charset utf-8; #文件编码 index index.html index.htm; #首页 error_page 404 /404.html; #404页面 error_page 500 502 503 504 /50x.html; #服务端错误页面 #url访问匹配路径，可以添加多个 location / &#123; index index.html index.htm; root /website/blog; #这里可以是绝对路径或者相对路径，基于站点根目录 &#125;&#125;可以用一条命令测试配置是否正确：nginx -t -c /etc/nginx/nginx.conf 重启 Nginx 服务器使配置生效：/etc/init.d/nginx restart 现在开始部署 Hexo。Hexo 部署原来的 Hexo 使用的是 hexo-deployer-git 插件，会在 Hexo 下生成一个 .deploy_git 目录，从这个目录上传到 pages 分支。现在我觉得不需要这个插件了，可以直接在 public 目录下初始化 git 仓库然后上传。cd hexo/public git init git add -A git commit -m &apos;add myBlog&apos; git remote add origin git@server:/website/blog.git git push origin master 这时候打开站点，就可以看到博客了。我的域名还没有备案，之前注册的域名有备案号，需要迁到阿里云。好像审核期间需要关站，真是麻烦。参考廖雪峰-搭建Git服务器使用 Git Hooks 实现自动项目部署Nginx中文文档","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"http://imys.net/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://imys.net/tags/Linux/"},{"name":"部署","slug":"部署","permalink":"http://imys.net/tags/部署/"}]},{"title":"阿里云Linux-Ubuntu折腾记","date":"2016-02-20T08:25:34.000Z","path":"20160220/start-linux-on-aliyun.html","text":"观望阿里云很久了，终于在这个春节来了后，一咬牙、一狠心、一跺脚就买下了一台 ECS。不分昼夜的折腾了几天后，终于在几天前配置好了自己期望的使用环境。由于本人初次接触 Linux，配置期间三度初始化磁盘（等价于手机恢复出厂设置），可以说是一步一个坑的走下来的。现趁热打铁对最后一次正确的安装配置做一下总结，给后人乘凉吧。选择配置作为开发者，选择 Linux 是毋庸置疑的。CPU 单核2G，对于我目前来说绝对是够用了。我会用来做什么？当然是瞎折腾了！一台远程服务器就相当于你多了一台24小时不关机的电脑，可以挂点有趣的服务跑着，比如爬虫之类。或者当个代码仓库，用来项目演示。当然，博客也肯定会迁过去的。带宽 2G，不知道带宽提升是不是会影响远程桌面速度。对于 Linux 的诸多版本之间的优劣，我也不甚了解，就选了个耳濡目染较多的 Ubuntu，版本自然是选最新版的64位。Linux 自带 20G 系统盘，另外我又加了一块 100G 云盘，感觉现在还用不了这么大空间。以上配置一年的价格是 1200+，我选择的地域是青岛，比国内其他地域相对便宜点。另外付款的时候填写推荐码可以优惠 10%，这是我的推荐码：rg2j5m。当然你使用我的推荐码付款后我将得到一定的返比代金卷，可以用来购买阿里云的产品。目的本文最终将会配置完成这样一个 Linux 使用环境：GNOME 中文图形界面；Windows 远程桌面连接；Nodejs 安装。更新软件源不管是从阿里云连接管理终端还是用的 Putty 等 SSH 连接工具，总之你现在应该已经打开一个黑窗口了。开始第一步。sudo apt-get update apt-get是一个包管理工具，在 Ubuntu 环境下，会是你以后经常用到的命令之一，类似于 Nodejs 环境下的npm。apt-get 命令一般需要 root 权限执行，所以一般跟着sudo命令。某些情况下，如果你的一个命令运行失败，可以加上sudo命令再尝试下，也许就神奇的成功了。Linux 系统基本上分两大类：RedHat系列：Redhat、Centos、Fedora等，使用 yum；Debian系列：Debian、Ubuntu等，使用 apt-get。apt-get 常用命令：update 更新软件包列表upgrade 升级软件包install pkg 安装软件包remove 移除软件包参考：apt-get的更多使用在查找 Linux 相关资料时，尽量带上系统环境与版本，不同版本环境下出现问题的解决办法不一定适用。GNOME 安装安装 x-window 的基础：sudo apt-get install x-window-system-core 安装 GNOME 登录管理器：sudo apt-get install gdm 安装 Ubuntu 的桌面：sudo apt-get install ubuntu-desktop 安装 GNOME 基础软件：sudo apt-get install GNOME-core OK！现在从阿里云连接管理终端登录的话，就可以看到 GNOME 漂亮的登录界面。如果还是黑屏的话，执行startX命令。startX 即为启动 x-window 服务，适用于任何图形界面的启用。在 Ubuntu 环境下当然不止 GNOME 一种图形界面，常见的还有 KDE、XFCE 等，从第2个步骤开始对应命令如下：sudo apt-get install kdm 或 xdmsudo apt-get install Kubunut-desktop 或 Xubuntu-desktop我没有使用经验，不知道孰优孰劣，有兴趣，可自行尝试。不过这三种桌面我倒是都安装过，之所以最后选择 GNOME 完全是撞上了，因为我三度初始化磁盘。对，是巧合！从界面美观上看，我更倾向于最后的 GNOME。设置中文环境这个坑我爬了很久！如果你的人品好，请使用最简单的界面设置方式来切换语言环境。System Settings -&gt; Language Support 进来会有一个弹出框自动安装语言更新，直接关掉Install/Remove Languages… -&gt; Chinese Simplified 勾选 -&gt; Apply Changes从上面列表里把汉语拉到第一位，如果可以的话（反正我是怎么都拉不上去）选项卡 Text -&gt; 列表里选择汉语 -&gt; Apply System-Wide…注销后登录就是汉语了而我是使用命令的方式强行设置的。上面的步骤最好先尝试下，我也不确定直接使用命令形式设置能否成功。安装中文的支持sudo apt-get install language-selector language-env language-pack-zhv 使安装生效，配置区域，看到zh_CN.UTF-8... up-to-date就表示成功了dpkg-reconfigure locales 将本地默认语言改为中文LC_ALL=zh_CN.UTF-8 配置系统环境sudo vi /var/lib/locales/supported.d/zh 加入以下配置参数：zh_CN.GB18030 GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.GB18031 GB18031zh_HK.BIG5 BIG5zh_TW.BIG5 BIG5生成locale（保存在/usr/lib/locale/中）：sudo locale-gen 编辑vi /etc/profile：export LC_ALL=&quot;zh_CN.GB18030&quot; 编辑vi /etc/default/locale：#LANG=&quot;zh_CN.UTF-8&quot;#LANGUAGE=&quot;zh_CN:zh&quot;LC_ALL=&quot;zh_CN.GB18030&quot;LANG=&quot;zh_CN.GB18030&quot;LANGUAGE=&quot;zh_CN.GB18030:zh_CN.GB2312:zh_CN&quot;SUPPORTED=&quot;zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en&quot;SYSFONT=&quot;lat0-sun16&quot;SYSFONTACM=&quot;8859-15&quot;添加个人系统变量，当 GNOME 启动后，会读取这个文件里面的设置：vi ~/.profileexport G_FILENAME_ENCODING=GB18030export G_BROKEN_FILENAMES=1注销重新登录或重启生效。在以上的步骤中用到了vi命令，运行后可以在 shell 环境中编辑文件。著名的 VIM 编辑器就是在 VI 的基础上改进的。以下这些操作可能让你很快上手 VI，比如对路径为/a文件进行编辑。执行vi /a打开文件，不存在则创建；按键盘编辑功能键insert使文件进入输入模式，现在可对文件进行修改，像使用任意文本编辑器一样；按esc退出输入模式，进入指令模式；输入:wq!对修改的文件进行保存并退出；如果文件没有进行修改，输入:q退出；如果要放弃修改，输入:q!退出。参考：Linux下vi命令大全远程桌面连接阿里云的网页版连接管理终端在图形界面下非常卡，一定让你很不爽。让我们开始有趣的部分吧！安装 Xrdp：sudo apt-get install xrdp vnc4server xbase-clients 安装 dconf-editor：sudo apt-get install dconf-editor 运行 dconf-editor：dconf-editor 展开org -&gt; GNOME -&gt; desktop -&gt; remote-access；只打开enabled和notify-on-connect，其他都关掉；修改vnc-password，这是你的远程登录密码；启动远程桌面连接：Windows 上，按win + R运行mstsc；输入你的服务器 IP 和用户名连接；登陆模式选vnc-any，IP和密码输入连接成功。如果你依然觉得卡的话，可以对远程连接做以下配置。启动远程桌面连接 -&gt; 显示选项显示 -&gt; 颜色可进行降级调整，还可以在显示设置调整远程桌面窗口大小体验 -&gt; 进行连接和功能的降级调整这些调整需要结合服务器配置和网络条件进行合理的选择。另外还有一种基于 XFCE 桌面环境的连接方式，这在我第一回合就尝试过，也是可行的。参考：Windows 7远程桌面连接Ubuntu 14.04Nodejs 安装Nodejs 的安装有很多种，最简单的就是在服务器浏览器里面从 Nodejs 网站中选择对应版本下载，其次还可以下载源码编译以及从软件中心(apt-get)安装等。我这里使用的是 NVM 安装，它是一个 Node 版本管理器。安装 Git：sudo apt-get install git 安装 NVM：cd ~/安装路径git clone https://github.com/creationix/nvm.git设置 NVM 下载源为淘宝镜像：NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/dist nvm install 0.11.11 配置 NVVM 的相关环境变量，编辑~/.bashrc：source ~/git/nvm/nvm.shexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/dist安装 Nodejs，nvm install version：nvm install v4.2.4 同时可以安装下cnpm，从淘宝镜像安装模块：npm install -g cnpm --registry=https://registry.npm.taobao.org 开始进行服务器连接测试，以下不是必须要做的。安装 Express 生成器：cnpm install express-generator -g 生成测试应用：cd ~/demoexpress test安装所有依赖包：cd testcnpm install启动测试应用：npm start 从本地打开http://服务器IP:3000可以看到 Welcome to Express，就证明服务器连接成功。感谢Windows使用VNC viewer访问Ubuntu 14.04远程桌面的简单方法http://www.cnblogs.com/huangfenghit/archive/2011/05/08/2040201.html快速搭建 Node.js 开发环境以及加速 npm快速搭建 Node.js 开发环境以及加速 npm当然，实际参考的文章远比这多的多。不过，是这几篇文章在重要的阶段带我登上云端。遗憾的是安装过程中没有截图，只是凭记忆把这些东西串连起来了，实际操作中难免有误，见谅！","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"Linux","slug":"Linux","permalink":"http://imys.net/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://imys.net/tags/Ubuntu/"}]},{"title":"写一个歌曲下载工具","date":"2016-02-15T08:33:31.000Z","path":"20160215/download-music-by-nodejs.html","text":"最近有朋友找我帮他下载歌曲，果然在其他人眼里，程序员简直是“无所不能”的存在啊。不过，这个需求对于程序员来讲，还算是比较正常的，比那些找你“刷QB”、“盗号”什么的强多了。要是放到以前下载歌曲，直接回一句“搜百度”完事，近年来歌曲版权逐渐被重视了，一些歌曲逐渐变为会员下载或者收费下载。不过好歹还是可以在线播放的，只要能播放，那想找到歌曲文件就很简单了。可以从开发者工具 - Network 里找音乐文件的请求链接，或者打开浏览器本地缓存文件夹找大文件。为了防止以后有朋友发出重复需求，我决定写一个工具出来。这其中涉及到了跨域访问、页面内容抓取，最终决定用express和cheerio来搞，服务端不存在跨域问题。试了一些音乐网站的歌曲搜索和播放后，最终把目标瞄准了酷我音乐。搜索酷我的歌曲搜索就是一个表单提交，页面跳转，服务端直接输出一个包含搜索结果的页面，这个页面的 URL 包含了查询字符串。http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你字段type表示搜索类型，也就是该页面上的 7 个标签页。对应关系如下：all --综合artist --歌手music --歌曲album --专辑mv --MVplaylist --歌单lyric --歌词对于目前的需求来说，type=music已经足够了。key是搜索关键字。该页签下还有一个参数pn表示页数，每页最多显示 25 项，该参数省略表示第一页。该页面的搜索列表和分页均为后端直出，想要封装自己的接口只好获取整个页面内容，然后解析 DOM ，组成自己需要的数据。模版views/index.html&lt;input type=\"text\" id=\"key\" value=\"曾经的你\"&gt;&lt;button id=\"search\"&gt;搜索&lt;/button&gt;&lt;hr&gt;&lt;ol id=\"list\"&gt;&lt;/ol&gt;&lt;hr&gt;&lt;div id=\"page\"&gt;&lt;/div&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/1.9.0/jquery.min.js\"&gt;&lt;/script&gt;模版使用的 ejs。路由// 页面渲染app.get('/', function(req, res) &#123; res.render('index', &#123; title: 'Music' &#125;);&#125;);// 搜索app.get('/search/:key/:pn', function(req, res) &#123;&#125;);实现逻辑很简单，点击搜索时取文本框的值 ajax 请求/search/:key/:pn获取数据渲染#list和#page。(function () &#123; var $key = $('#key'), $so = $('#search'), $list = $('#list'), $page = $('#page'); function getData(key, pn) &#123; $.getJSON('/search/' + key + '/' + pn, function(data) &#123; // 渲染 #list 和 #page &#125;); &#125; function search() &#123; var key = $.trim($key.val()); if(!key) &#123; return; &#125; getData(key, 1); &#125; $so.click(function () &#123; search(); &#125;); $key.keyup(function(event) &#123; if(event.keyCode === 13) &#123; search(); &#125; &#125;);&#125;.call(this));根据前端的需求，后端输出的数据格式应该是这样的。&#123; list: [], page: ''&#125;开始封装对应格式的数据。通过开发者工具 - Elements 可以找到酷我搜索结果页面的列表和分页的 Dom。可以使用 http 模块去请求这个页面，拿到整个页面文档，使用 cheerio 选取对应的 Dom 来组装成我们需要的数据。相关Dom歌曲列表的选择器为.m_list ul，分页的选择器为.page。当然，使用类选择器时要确定该类在页面内是唯一的。// 搜索app.get('/search/:key/:pn', function(req, res) &#123; // http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你&amp;pn=1 var key = req.params.key, pn = req.params.pn, option = &#123; host: 'sou.kuwo.cn', port: 80, path: '/ws/NSearch?' + querystring.stringify(&#123; type: 'music', key: key, pn: pn &#125;), method: 'GET' &#125;; var req2 = http.request(option, function(res2) &#123; var body = ''; res2.setEncoding('utf8'); res2.on('data', function(data) &#123; body += data; &#125;); res2.on('end', function() &#123; // 解析 html var $ = cheerio.load(body), $list = $('.m_list ul li'), $page = $('.page'), list = []; $list.each(function(i, el) &#123; var $this = $(el); list.push(&#123; id: parseInt($this.find('input[name=\"musicNum\"]').val()), name: $this.find('.m_name a').attr('title'), album: $this.find('.a_name a').attr('title'), singer: $this.find('.s_name a').attr('title') &#125;); &#125;); $page.find('a').each(function(i, el) &#123; var $this = $(el), href = $this.attr('href'); if (href !== '#@') &#123; var num = href.split('=').reverse()[0]; $this.attr('data-option', JSON.stringify(&#123; key: key, pn: num &#125;)); &#125; $this.attr('href', 'javascript:;'); &#125;); res.send(&#123; page: $page.html(), list: list &#125;); &#125;); &#125;); req2.on('error', function(e) &#123; console.log(e); &#125;); req2.end();&#125;);歌曲的数据项取了 id、歌名、专辑、歌手。分页的 Dom 结构比较简单，我直接把分页内的a:href属性替换了，添加自定义数据用于前端点击重渲染，直接返回整个分页的 HTML。以上代码引用的模块有http、querystring、cheerio。不得不说cheerio用来爬页面实在是太棒了！以上代码在一个请求处理逻辑中又发出 http 请求，显然可以封装出一个请求模块，以备其他地方使用。lib/request.jsvar http = require('http');module.exports = function(options) &#123; return new Promise(function(resolve, reject) &#123; var req = http.request(options, function(res) &#123; var body = ''; res.setEncoding('utf8'); res.on('data', function(data) &#123; body += data; &#125;); res.on('end', function() &#123; resolve(body); &#125;); &#125;); req.on('error', function(e) &#123; reject(e); &#125;); req.end(); &#125;);&#125;添加一个 request 模块用于 http 请求，以 Promise 方式返回。这样搜索的处理逻辑代码就变成这样。app.get('/search/:key/:pn', function(req, res) &#123; // http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你&amp;pn=1 var key = req.params.key, pn = req.params.pn, option = &#123; host: 'sou.kuwo.cn', port: 80, path: '/ws/NSearch?' + querystring.stringify(&#123; type: 'music', key: key, pn: pn &#125;), method: 'GET' &#125;; request(option).then(function(body) &#123; // 解析 html var $ = cheerio.load(body), $list = $('.m_list ul li'), $page = $('.page'), list = []; $list.each(function(i, el) &#123; var $this = $(el); list.push(&#123; id: parseInt($this.find('input[name=\"musicNum\"]').val()), name: $this.find('.m_name a').attr('title'), album: $this.find('.a_name a').attr('title'), singer: $this.find('.s_name a').attr('title') &#125;); &#125;); $page.find('a').each(function(i, el) &#123; var $this = $(el), href = $this.attr('href'); if (href !== '#@') &#123; var num = href.split('=').reverse()[0]; $this.attr('data-option', JSON.stringify(&#123; key: key, pn: num &#125;)); &#125; $this.attr('href', 'javascript:;'); &#125;); res.send(&#123; page: $page.html(), list: list &#125;); &#125;, function(e) &#123; console.log(e); &#125;);&#125;);数据有了，开始写前端页面渲染部分。function getData(key, pn) &#123; $.getJSON('/search/' + key + '/' + pn, function(data) &#123; var body = ''; data.list.forEach(function (v, i) &#123; body +='&lt;li&gt;&lt;a href=\"download/'+ v.id +'\"&gt;'+ v.name +' '+ v.album +' '+ v.singer +'&lt;/a&gt;&lt;/li&gt;'; &#125;); $list.html(body); $page.html(data.page); &#125;);&#125;每次调用这个方法都会获取数据渲染列表和分页。歌曲列表的每一项直接使用了 a 链接，点击直接下载歌曲，会有一个新的路由/download/:id。分页内的 a 链接已经加上了自定义数据，直接添加点击事件拿到数据调用getData方法。$page.on('click', 'a[data-option]', function () &#123; var option = $(this).data('option'); getData(option.key, option.pn);&#125;);至此，搜索加分页就全部完成了。下载在酷我的页面中点击歌曲名可以跳转到一个歌曲播放页，该页面 URL 格式为http://www.kuwo.cn/yinyue/100062/，其中的 100062 就是歌曲ID了。对于资源文件，直接分析 Network，找到资源文件请求和歌曲ID之间的关系，期望可以直接获取到资源文件的链接。酷我Network最终分析结果：ID100062 的资源文件名是 1058000744.aac。有一个请求 http://antiserver.kuwo.cn/anti.s?rid=MUSIC_100062&amp;format=aac|mp3&amp;type=convert_url&amp;response=url 的结果为 http://win.web.ra03.sycdn.kuwo.cn/07baab80f0a6dd9b3a091879b308ae68/56c2840e/resource/a1/48/63/96/1058000744.aac。这样我们直接用歌曲ID去请求http://antiserver.kuwo.cn/anti.s就能获得歌曲链接了。酷我的默认请求为.aac格式，应该是和参数format=aac|mp3有关，可以改成format=mp3|aac。app.get('/download/:id', function(req, res) &#123; // http://antiserver.kuwo.cn/anti.s?rid=MUSIC_100062&amp;format=aac|mp3&amp;type=convert_url&amp;response=url var option = &#123; host: 'antiserver.kuwo.cn', port: 80, path: '/anti.s?rid=MUSIC_' + req.params.id + '&amp;format=mp3|aac&amp;type=convert_url&amp;response=url', method: 'GET' &#125;; request(option).then(function(body) &#123; res.redirect(body); &#125;, function(e) &#123; console.log(e); &#125;);&#125;);request 模块又派上用场了，由于该请求直接返回了歌曲链接，我就直接重定向到该链接了。为了使歌曲在新窗口打开，前端页面列表项中的 a 链接要添加target=&quot;_blank&quot;。成果展示截图DownloadMusicCodeGithub - DownloadMusic","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"Express","slug":"Express","permalink":"http://imys.net/tags/Express/"},{"name":"Cheerio","slug":"Cheerio","permalink":"http://imys.net/tags/Cheerio/"}]},{"title":"我为什么选择了前端？","date":"2016-02-07T05:43:14.000Z","path":"20160207/end-2015.html","text":"初出茅庐前年的腊月二十九我接到了上传简历后的第一个面试通知，于是去年初六没到，我就收拾好东西来郑州了。我当时的求职意向写的是：.NET/JAVA/前端。不知道哪儿来的自信，我就是感觉自己干什么都可以。我从来都觉得一个程序员不应该被语言和技术所标记。在这个行业，学习能力决定了你能走多远。事实上，我根本就是一个刚出炉的菜鸟。那个时候已经有一年多的码龄，看起来什么都会点，也能写出一些让初学者感觉叼炸天的东西来。可是对于很多东西的理解都不够深，感觉就是学了一些杂七杂八的招式，所知种种也都还在基本应用的层面。这些也终于在面试的时候暴漏了。由于我的求职岗位多，面试机会也多。写简历的时候还想把安卓也写上，尝试写过一个APP，感觉代码跟 java swing 差不多，上手也不难。当时跨平台呼声很大，还是决定走 WEB 路线。面试挫折不到一周的时间，大概面试了六七家公司，现在所在是面试的第三家。并不是这家公司的待遇有多好，而是有一家公司打击到了我（虽然我不服）。那家公司面试的是前端，还是我比较看好的一家。懂后端的去面试前端一般是很受欢迎的，我也这么认为的。虽然当时对于原型、作用域、闭包等一些进阶知识都一头雾水，但是我还是玩出了 java 编程的感觉。我还写了类、对象、继承、简单工厂模式，硬是用 js 实现了一个棋牌游戏的规则。最后导师告诉我，面向对象运用的不错，编程套路是不区分语言的，但是规则如果写到前端是不是就不安全了。也对，我开个控制台，改点变量不就无敌了。所以说，当时的我对于面试前端有着盲目的自信。一到那边就开始做笔试了。该公司逼格很高，两套面试题，一套中文，一套英文，我当时懵逼了。然后向 HR 确认可以不做英文才放下了心。这显然是一个对英语水平的检测，至于我的英文水平？我可以这么说，谷歌懂的我都懂！面试题也都很基础，比如 HTML 标签的使用（考察文档结构语义化）、HTML5 和 CSS3 常用标签和属性（考察对新技术的了解）、实现某种需求要如何写样式（考察基本功）、如何解决某种页面 兼容性问题（考察经验）、js 语言基础和 jquery 的一些属性和方法的掌握（也是基本功），还有判断 js 代码的执行结果（考察对 js 语言的掌握）。我是一题不落的写完了，不求对，只求完整。在写题的过程中我已经发现了自己的不足。主要是页面兼容性和 js 语言基础。学习过程中都是后端为主，作为处女座，前端我也会用CSS3、jq特效以及bootstrap之类的框架打扮的漂漂亮亮的。我怎么可能去想什么页面兼容性问题。写 js，大概除了判断、循环、定义变量和函数就全是一股脑儿 jq 了。不足是不足，我相信这些我都是可以在以后的工作中快速掌握的。我还是对面试成功抱有希望的。做完面试题后，HR 叫了一个小伙子进来，看来是要进行真正的考验了。说一下印象深刻的几个问题。问我为什么要做前端？的确，我的简历上后端技术居多，不知道一些人是不是会以为我是二傻子。我脱口而出：前端好玩！这是来自心底的答案。难道前端不好玩吗？用 winform、swing 写界面的时候太痛苦了。而在前端简直就没有实现不了的，加上新的 h5、css3 又让网页增添许多表现力。学后端不代表我不关注前端，通过一些技术社区和博客，我可是知道前端进入了一个怎样的时代。这让我感觉前端大有可为！这也是我在求职意向写上前端的理由之一。还有一个理由是 CURD 写烦了，前端直接处理数据合理的展示给用户，更能有成就感！问了一个我从来没有关心过的问题，js 有哪几种基本数据类型？我回答的是：整型、浮点型、布尔型和字符串，还是十分肯定的语气。从后端的角度考虑，基本类型就是不需要用new来声明，因为知道有一个parseFloat函数，理所当然的以为float是一种数据类型。而正确答案中的undefined、null居然会是数据类型，这对于使用强类型语言的我根本是难以理解的。还现场看了我的代码，就是棋牌游戏那个。开头就指着$().ready(function(){ })说我写的不对，$()里面应该写参数、写window。我不置可否。然后对我写的类和继承提出质疑。继承的实现有多种，我还是知道的。我写的这种应该是少见的，但也不至于说有什么错误。直到我现在看看当时的代码，都比我们公司后端写的 js 强多了。问了我 js 常用的函数以及调用方式。我回答的不够好，平常还是太依赖 jq，或者使用的时候查文档。一些答案都是猜的，因为语言的共通性，你几乎可以确定 java 中某些类的一些函数，js 中也有。我说用的时候查下不就行了，他说你查哪儿，我说 w3cSchool。然后我清楚的记得他那写满一脸 hehe 的表情。:-)最后是现场编码，冒泡排序。我当时也是慌了，连个冒泡都没写正确，面试完下楼才恍然大悟，是内层循环条件写错了。他问我有没有什么问题要问他的。我一脸微笑的看着他，问：你工作多久了？ :-)他一脸不爽，有点不耐烦的说：2年了。 一 一+走的时候 HR 说回去等通知，结果半路上就收到短信给我画上句号了。阴差阳错之后的几个面试也不理想，郑州很多小作坊的网络公司，进去就是坑。而我现在所在的公司，当时给我的工资真的不高，完全就是把我当初学者。我最初去的时候以为面试的职位是 .NET，每个要面试的公司我都会提前做功课了解该公司行业和技术类别。结果来面试我的人，就是我现在的领导，也就是说是叫我来做前端。也没做什么笔试，不过登记表填了半天，查户口一样。面谈也没问我什么特别难的问题，更多的是问了我对新技术的了解。这点我还是很让人满意的，并且我表现出了足够的兴趣。“一谈技术，两眼放光”，说的就是那时的我了。领导还是我的老乡。第二次去的时候，就是在之前的面试失败之后了。那天回去之后我就把面试中存在的疑问查找了下答案。对于这样的面试结果虽然不满意，但是却萌发了我走前端之路的心思。陌生的领域往往有着致命的诱惑。如果说现在有游戏开发的工作愿意要我，给我较低的工资我也愿意去。这次来就是确定意向的。因为薪资给的低，我问到了涨薪制度。他表示半年涨一次固定薪资。我继续追问了有没有可能给予优秀的人涨更高的工资，我表示自己能够快速的成长起来。他表示如果试用期表现好，可以涨多点。最后他介绍了下公司状况以及行业地位，以及当前团队正在进行的项目，并且向我表示有移动端开发项目。当我知道目前他们团队，也就是我现在的团队，正在做整站改版的时候，我决定留下来了。既然我要踏入前端，那么这次整站改版就是一次很好的实践机会，应该可以从头到尾系统的学习很多东西。就当是一次发工资的培训了。好像有点混乱，我也忘了是一次谈好还是去了两次。焉知非福最后不谦虚的说，我们公司是真的赚到了。目前公司 3 个前端，js 基本都是我写的，或者是他们俩复制我的代码到其他地方。我承担了前端的大部分工作，在后端的配合上也有着绝对的优势。我也赚到了，因为这个平台，让我完成了很多实践。反正这里前端没有比我强的，也不怕有人对我有何见教。这个 MD 是年前创建的，直到今天我才写完。╮(╯▽╰)╭","tags":[{"name":"前端","slug":"前端","permalink":"http://imys.net/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://imys.net/tags/面试/"}]},{"title":"我刚知道的 Promise","date":"2016-02-03T03:19:47.000Z","path":"20160203/js-promise.html","text":"有时候，你会发现满世界都是某个字眼。Promise，就是这个家伙。简直阴魂不散，走到哪儿都能看到它。fetch、koa中都有TA的身影，而我却对TA一无所知。搜索TA的文章介绍，第一页中最早的一篇文章已经是2011年了。那是个我还不会HelloWorld的年代啊！用法Promise 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。看概念很迷糊，直接看实例理解吧。function $http(url)&#123; var core = &#123; ajax : function (method, url, args) &#123; var promise = new Promise( function (resolve, reject) &#123; var client = new XMLHttpRequest(); var uri = url; if (args &amp;&amp; (method === 'POST' || method === 'PUT')) &#123; uri += '?'; var argcount = 0; for (var key in args) &#123; if (args.hasOwnProperty(key)) &#123; if (argcount++) &#123; uri += '&amp;'; &#125; uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]); &#125; &#125; &#125; client.open(method, uri); client.send(); client.onload = function () &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; resolve(this.response); &#125; else &#123; reject(this.statusText); &#125; &#125;; client.onerror = function () &#123; reject(this.statusText); &#125;; &#125;); return promise; &#125; &#125;; return &#123; get : function(args) &#123; return core.ajax('GET', url, args); &#125;, post : function(args) &#123; return core.ajax('POST', url, args); &#125;, put : function(args) &#123; return core.ajax('PUT', url, args); &#125;, delete : function(args) &#123; return core.ajax('DELETE', url, args); &#125; &#125;;&#125;;$http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; // success&#125;, function(data)&#123; // error&#125;);以上是一个基于 Promise 的 ajax 实现，调用形式跟 vue-resource 如出一辙（果然又是大神们嚼烂的玩意儿）。Promise 的构造函数可以带有1个参数，它是带有resolve、reject两个参数的函数对象，如以上core.ajax函数中创建的 Promise 对象。其中 resolve 用于处理执行成功的场景，reject 用于处理执行失败的场景。在成功与失败的处理阶段 hook 到一个 Promise 对象中，最后通过then方法来真正的处理返回结果。Promise.prototype.then(onFulfilled[, onRejected])Promise.prototype.catch(onRejected)并不是所有的失败场景都需要在then方法中处理，在其后继续追加catch方法也是可以的。$http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; // success&#125;).catch(function(data)&#123; // error&#125;);由于then和catch仍然返回一个 Promise 对象，所以可以出现多个then或catch来处理不同的业务场景。$http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; return handleA(data);&#125;).then(function(data)&#123; // 此处 data 为 handleA 方法处理后的数据 return handleB(data);&#125;);为何要用咋一看 Promise 就是一个包装好的代理对象。不过它的出现究竟是为了解决什么问题呢？在 Promise 出现之前，如果你的逻辑中出现了异步操作，而又需要在异步操作外获取异步操作内的结果，不外乎是要使用回调了。function getList(callback) &#123; $.get(yourApi, function(data)&#123; callback(data); &#125;);&#125;使用 Promise 呢？function getList() &#123; return new Promise( function (resolve, reject) &#123; $.get(yourApi, function(data)&#123; resolve(data); &#125;).error(function(data)&#123; reject(data); &#125;); &#125;&#125;使用 Promise 代理了原来所需要的回调的，返回一个对象而不是传入回调参数的方法形式更直观和容易理解。在之后的编程中，当目标方法返回了一个 Promise 对象，我们就知道发生了异步操作，需要通过 then 方法来处理场景需求。到此为止，Promise 给我的感觉也只不过是语法糖罢了，这种形式的写法我也可以封装出来啊。接下来才是其真正的优点。比如异步处理多个的请求结果，原始写法。function getData(callback)&#123; $.get('/ApiA', function(dataA)&#123; $.get('/ApiB', function(dataB)&#123; $.get('/ApiC', function(dataC)&#123; callback(dataA, dataB, dataC); &#125;); &#125;); &#125;);&#125;当然以上是一种比较蠢的写法，当请求数量发生变化时的时候，这段代码就需要修改了。可以用递归优化下。function getData(url, callback)&#123; if(url instanceof Array) &#123; var i = 0, len = url.length, dataArr = [], eachLoad = function(url)&#123; $.get(url, function(data)&#123; dataArr.push(data); if(i++ &lt; len - 1) &#123; eachLoad(url[i]); &#125; else &#123; callback.apply(null, dataArr); &#125; &#125;); &#125;; eachLoad(url[i]); &#125; else &#123; $.get(url, function(data)&#123; callback(data); &#125;); &#125;&#125;使用 Promise 解决。var promiseA = $http('/List').get(&#123; id: 111 &#125;), promiseB = $http('/List').get(&#123; id: 222 &#125;);Promise.all([promiseA, promiseB]).then(function(data)&#123; // do...&#125;);使用Promise.all方法一次性处理多个操作。Promise 属于 ES6 特性，目前在 IE 中还不能用，不过各大框架也都有自己的实现。jQuery 中的 PromisejQuery 中很多异步操作都会返回一个延迟对象$.Deferred，该对象具有一系列的操作方法。// animate$('div').animate(&#123; width: '50%'&#125;, 300).done(function()&#123; // 当延迟成功时调用&#125;);// ajax$.get('/List').then(function()&#123; // succee&#125;, function()&#123; // error&#125;);// when$.when($.ajax('/List1'), $.ajax('/List2')).then(function()&#123; // succee&#125;, function()&#123; // error&#125;);// 还有很多，可以去 jQuery Api 中看。参考javascript标准库-Promise | MDNJavaScript异步编程的Promise模式JavaScript Promise迷你书","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://imys.net/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"http://imys.net/tags/Promise/"},{"name":"async","slug":"async","permalink":"http://imys.net/tags/async/"}]},{"title":"你以为你写的1px就是1px吗？","date":"2016-01-27T14:33:05.000Z","path":"20160127/mobile-1px.html","text":"“这一行的分割线高了一点。”好的，减小行高, 加点上下内边距。“这几个元素要两端对齐。”好的，flex没有解决不了的布局，justify-content: space-between;搞定。……“这个图标颜色不对，应该是#999。”好的，我改…等等，明明就是 #999 啊，这分明是想被打脸的节奏。打开页面，右键图标，审查元素，截图。是不是 999 ？是不是 999 ？？是不是 999 ？？？“所有的下边框都应该是1px。”我看到这个问题的瞬间，感觉像在侮辱我的智商。边框 1px 这么常用的样式，我还会写错不成？正当准备继续“打脸”时，突然我的好奇心上来了。关于 1px 边框在移动设备上看起来比较粗 这个问题，我也曾经想过。因为页面其他内容看起来都是正常的，所以我一直觉得这是移动设备浏览器的渲染问题，属于外部原因。也曾设置过 .5px ，但显然浏览器并不买账。搜索关键字1px border，找到了问题所在。devicePixelRatio说来惭愧，关于 devicePixelRatio，我也算是有使用经验的人了，怎么就没有想到呢。简单举例一下，我的 MX5 分辨率是 1920*1080，但是实际屏幕物理像素是 640*360，换算得出 devicePixelRatio = 3。也就是说屏幕中的1点 = 3px。设计师提出的图标颜色不对的问题也在于此，因为颜色也受益于分辨率。viewport这一切都是 viewport 在作怪！我们在开发手机页面时，都会这样设置。&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt;width=device-width: 设置浏览器内容宽度为设备物理像素宽度。initial-scale=1: 缩放比为1，后面两个属性为最大和最小缩放比。user-scalable=no: 禁止用户手动缩放。用 1920*1080 分辨率的手机打开一个没有添加 viewport 的PC站点，横屏状态是可以完整的出页面内容的。因为这个时候的 1px 就是 1px。还原分辨率知道了问题的原因就对症下药了。可以根据window.devicePixelRatio来动态修改屏幕缩放比，还原真实分辨率。还有一个问题。分辨率还原了，那岂不是所有元素的尺寸数值都需要重新计算了？如果你的 css 没有使用 em 和 rem 为单位的话，那么恭喜你，一个一个慢慢改吧。而使用 em 和 rem 为单位就简单多了，只需要动态修改根元素字体大小就行了。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;%=title %&gt;&lt;/title&gt;&lt;meta id=\"vp\" name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt;&lt;script&gt;(function () &#123; var vp = document.getElementById('vp'); dpr = window.devicePixelRatio, html = document.getElementsByTagName('html')[0], vpVlue = 'width=device-width, initial-scale=X, maximum-scale=X, minimum-scale=X, user-scalable=no'; if(dpr) &#123; vp.content = vpVlue.replace(/X/g, (1 / dpr)); html.style.fontSize = (14 * dpr) + 'px'; &#125;&#125;)();&lt;/script&gt;&lt;head&gt;这可以直接加到头部模版中。关于修改根元素字体大小也可以使用 css媒体查询的方式。@media (-webkit-min-device-pixel-ratio: 2) &#123; html &#123; font-size: 28px; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 3) &#123; html &#123; font-size: 42px; &#125;&#125;彩蛋本来 js 代码我是放到 body 闭合前的。viewport 初始缩放值是 1 ，根元素初始字体大小是 14px，我的手机 devicePixelRatio 是 3。按照浏览器加载顺序，等执行到 js 前，页面内容应该 1/3 的大小；执行完 js 后，页面恢复实际大小，整个页面居然出现了类似于transform: scale(1)般的过渡效果。为了让用户更早的看到页面内容，我还是决定放到头部了。问题更新以上的思路和代码确实解决了问题，至少我在手机浏览器上测试是OK的。之后在 APP 中嵌入后发现没有效果，页面内容都因为字号修改被放大了。我怀疑是安卓端的某些配置的原因，但是不了解的事又不好乱发言。最后抽了一个闲工夫，把安卓环境搭了起来，看着 WebView 的API，自己写了个测试DEMO。问题解决了。webview.getSettings().setUseWideViewPort(true); // 自适应手机屏幕从方法名就很容易理解这个配置项与 viewport 存在着关系。问题解决了，我要去安卓那边装逼了。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"devicePixelRatio","slug":"devicePixelRatio","permalink":"http://imys.net/tags/devicePixelRatio/"},{"name":"em","slug":"em","permalink":"http://imys.net/tags/em/"},{"name":"Mobile","slug":"Mobile","permalink":"http://imys.net/tags/Mobile/"},{"name":"Webview","slug":"Webview","permalink":"http://imys.net/tags/Webview/"},{"name":"Viewport","slug":"Viewport","permalink":"http://imys.net/tags/Viewport/"}]},{"title":"Hexo博客改版记录","date":"2016-01-18T01:02:18.000Z","path":"20160118/hexo-blog-update-log.html","text":"每当我把之前立下的 flag 执行的时候，都感觉是一件很骄傲的事，太多的计划被我用各种接口扼杀在摇篮中了。引言在 Android 更新到 5.0 后，我就对触摸反馈这一点很感兴趣。也尝试模拟过，但是最后的效果都不太满意。偶然的一次在 github上 看到了 Materialize 这个项目，才知道了谷歌的Material Design(原质化设计) 设计规范。而后在公司听到设计师提到这个东西时，突然有种跟上了潮流的感觉。就像一些文章中提到的，即使你不懂设计，但是照着样式去做，也不会太丑。这显然很对我的胃口。改版内容除了博客风格改版外，也改变了以下一些内容。Hexo toc在我刚使用 Hexo 不久时，还曾专门写了一篇文章介绍 hexo-toc 插件的使用。不过最近在我升级了 hexo-toc 插件后，发现已经不需要像我写的那么麻烦了。这还不是重点。因为博客布局结构要有很大变化，很多模版我都需要重写。所以就需要查阅 Hexo 文档寻找一些可利用的资料。就在这个过程中，我居然发现了 Hexo 居然有生成 toc 的辅助方法。好气好气，也不是第一次翻文档了，之前居然都没注意到。与 hexo-toc 插件比，这个辅助方法更加便利。文档链接hexo-toc 需要在编辑时插入&lt;!--toc--&gt;标记，且生成后的内容还在文章中占位。这对于想实现一些浮动式文章导航的同学十分不便。而&lt;%- toc(str, [options]) %&gt;方法就简单多了，只要是在文章页中，你放到什么地方，就在什么地方渲染。去 jquery仅仅是一个博客，也没有多少复杂的 Dom 操作。读者也都是程序猿，也不存在要考虑浏览器兼容。jquery 能不用则不用，当前的 js 也就写了100多行。去 fancyboxfancybox 是基于 jquery 的一个图片浏览插件，jquery 去了，它自然也就失效了。请求数挺多的,而且它本身的功能，我并不在意，没什么卵用的感觉。如果后续有需要，也可以用原生实现一个。去 stylus, 用 less这个纯粹是个人的习惯。html 和 css 还是喜欢原生的代码风格，stylus 和 jade 这种强缩进的都不太喜欢。替换时需要在配置文件中增加 less 插件的依赖和参数配置。plugins: - hexo-renderer-lessless: paths: - source/css/style.less安装 roboto 字体Roboto 字体是 Material Design 的推荐英文字体。英文字体文件字节小，毕竟只有26个字母。虽然写不了几个单词。中文推荐字体是 Note，但是要115.5MB。Google Note Fonts增加 Waves 效果这个也是 Material Design 提倡的响应式交互效果。Materialize 中使用的是 Waves。我也是顺藤摸瓜才知道了这个库。分享现在的文章分享是直接通过 JiaThis API 接口，不需要引用额外的js。这样DIY就更方便了。默认的分享样式，很难实现一些效果。像我现在的分享，有文章右侧的静态挂件和顶部浮动导航右侧的分享按钮。最后我不懂设计，所以关于 Material Design 的介绍，也就不多提。附上参考链接，有兴趣的可以去提高一下审美。Google Material designMaterial Design 中文版Material design的实现：Materialize一些小细节还会不断的调整，之后整理下再把主题发布到 github 上。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"Material Design","slug":"Material-Design","permalink":"http://imys.net/tags/Material-Design/"}]},{"title":"前端技术模拟移动端wheelview滑动选择器","date":"2015-12-31T01:59:48.000Z","path":"20151231/simulation-of-wheelview-selector.html","text":"公司进入APP改版阶段了，会基于原生安卓开发，感觉没自己什么事了。只能看看原型图，想想前端技术如何实现某某功能。。。滑动选择器在APP上是很常见的组件了，最初是 IOS 上的组件，之后就出现 Android 版的自定义实现，称为 WheelView。对于前端技术来讲，实现也并不困难。wheelview布局是解决复杂组件效果的关键，要充分结合css去思考。选中项和未选中项的样式不一致是首先要解决的问题，最终想到了两种解决方案。Plan A&lt;div class=\"wheelview\"&gt; &lt;div class=\"action\"&gt; &lt;a href=\"javascript:;\" class=\"fl\"&gt;取消&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"fr\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul class=\"backlist list\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"front\"&gt; &lt;ul class=\"list\" id=\"front\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;使用两个列表来显示，一个列表作为背景显示所有项；另一个列表置于顶层，固定为一行的高度显示选中项。需要处理两个列表的同步滚动。Plan B&lt;div class=\"wheelview\"&gt; &lt;div class=\"action\"&gt; &lt;a href=\"javascript:;\" class=\"fl\"&gt;取消&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"fr\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul class=\"list\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;单列表显示，再添加两个同级的遮罩层设置透明色渐变，分别覆盖于列表上下，保留中间一项的视区。根据不同应用场景，两种方案各有千秋。Plan A ：适用于选中项与普通项样式差别大的场景。比如选中项要求为蓝色，普通项为灰色，已经不在一个色系了。Plan B ：单列表结构更清晰，节省标签。亮点就是遮罩层的渐变背景色。最后只剩下实现滚动效果了，为防掉坑，引用了 iscroll.js。Code","tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://imys.net/tags/Mobile/"},{"name":"wheelview","slug":"wheelview","permalink":"http://imys.net/tags/wheelview/"},{"name":"component","slug":"component","permalink":"http://imys.net/tags/component/"},{"name":"iscroll","slug":"iscroll","permalink":"http://imys.net/tags/iscroll/"}]},{"title":"iconfont兼容与维护","date":"2015-12-23T05:47:34.000Z","path":"20151223/iconfont-maintained.html","text":"在扁平化网页设计中，字体图标有着很好的易用性。结合一年的实际运用，来做一下总结。使用可以直接引用开源的第三方字体样式文件，如Font Awesome等。或者你想要构建一套产品专属的图标，可以注册一个字体图标库，添加一个图标项目，进行创作和使用。我司使用的字体库是阿里的iconfont。设计图标我不懂，都是设计师负责产出的。产出后，可以看到图标的Unicode和font class。使用时，需要把字体引用@font-face复制到项目公共样式中，可以使用在线字体链接或者下载到本地服务器，然后可以选择两种方式引用。1.直接使用Unicode.icon &#123; display: inline-block; font-family: \"iconfont\"; font-style: normal; font-weight: normal; -webkit-font-smoothing: antialiased;&#125;&lt;i class=\"icon\"&gt;&amp;#xe74e;&lt;/i&gt;把Unicode直接写入页面内容中，渲染出图标。2.使用font class[class^=\"icon-\"]:before, [class*=\" icon-\"]:before &#123; text-decoration: inherit; display: inline-block; speak: none;&#125;.icon-search:before &#123; content: \"\\f002\";&#125;&lt;i class=\"icon-search\"&gt;&lt;/i&gt;利用伪元素的content属性，把Unicode写到 css 中，不过渲染后还是会在页面展示。维护由于要IE7不支持伪元素，所以我们这一直是直接使用Unicode的方式引用图标。随着图标的增加，使用极其不方便。写页面时每次引用图标就需要打开图标项目页面去复制 Unicode，这个真心记不住啊！领导抽风要修改图标，然后图标改过之后 Unicode 发生了变化，然后就需要苦逼的把所有使用这个图标的页面都改一遍 Unicode，还好有 gulp-replace。当我意识到这是一个大坑时，已经来不及了。。。在之后，我开始基于字符映射的方式去管理字体图标。在项目里加了一个图标配置文件。如：&#123; \"search\": \"xe74e\", // ...&#125;前端模版入口会直接把这个图标数据加入页面上下文。由于配置文件定义了语义化的命名，页面使用就方便多了。&lt;i class=\"icon\"&gt;&amp;#&lt;%=icon.search %&gt;;&lt;/i&gt;我这边后端是 .net，不管是什么语言，都只需要在公共类中加个读取图标的方法。这样前端的模版拿到后端也不需要进行什么修改。然而直接促使我发此文的原因是因为不小心点开了 Font Awesome 用于兼容 IE7 的 css 文件。.icon-file &#123; *zoom: expression( this.runtimeStyle['zoom'] = '1', this.innerHTML = '&amp;#xf016;' )&#125;expression 是 ie 特有的 css 属性，可以在其中写 js 脚本。这样又把图标的维护权交还 css 了。在 css 中写 js 这种做法肯定是不提倡的，而且一个页面上存在很多的图标，在 ie7 这么恶劣的环境中，渲染速度也是个大问题。我用 IE7 打开 Font Awesome 的页面，速度在30s左右。这是个问题，又不算问题。😏","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"iconfont","slug":"iconfont","permalink":"http://imys.net/tags/iconfont/"}]},{"title":"神奇的eval()与new Function()","date":"2015-12-22T05:07:00.000Z","path":"20151222/eval-with-new-function.html","text":"在需要兼容IE8以下的日子里，往往需要使用eval()来把后端传过来的JSON串转成可操作的JSON对象。直到昨天在翻看jQuery源码时，才发现jQuery.parseJSON的兼容实现用的是new Function()。马上Google了相关资料，寻找两者的区别。evaleval接受字符串参数，解析其中的js代码。如果编译失败，会抛出异常，否则执行其中的代码，计算返回值。eval('2+2'); // 4eval('console.log(\"ok\")'); // ok在实际应用中，通常这样转换JSON。var jsonStr = '&#123; \"age\": 20, \"name\": \"jack\" &#125;';eval('(' + jsonStr + ')');为什么要加括号呢？因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。console.log( eval('&#123;&#125;') ); // undefindconsole.log( eval('(&#123;&#125;)') ); // Object &#123;&#125;使用eval需要注意执行作用域var s = 1;function a() &#123; eval('var s=2'); console.log(s);&#125;a(); // 2console.log(s); // 1在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。var s = 'global';function a() &#123; eval('var s = \"local\"'); console.log(s); // local console.log(eval('s')); // local console.log(window.eval('s')); // global&#125;Function在之前我对于Function的了解只限于“定义方法的一种非主流方式”。却忽略了Function与eval相同的字符串参数特性。语法：var func = new Function(arg1, arg2, ..., functionBody);实例：var add = new Function('a', 'b', 'return a+b;');console.log( add(2, 3) ); // 5由于其形参使用字符串的方式表示，也可以使用1个字符串来描述多个形参。var add = new Function('a, b', 'return a+b;');console.log( add(2, 3) ); // 5在转换JSON的实际应用中，只需要这么做。var jsonStr = '&#123; \"age\": 20, \"name\": \"jack\" &#125;', json = (new Function('return ' + jsonStr))();eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。如果可以，请用更好的方法替代。在一些特殊的运用场合，也有一些合理运用的实践。比如模板解析等。那么为什么 jQuery 要用new Function而不用eval呢？看看老外做的两者以及原生方法的性能比较：JSON Performance comparison of eval, new Function and JSON","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://imys.net/tags/Function/"},{"name":"eval","slug":"eval","permalink":"http://imys.net/tags/eval/"}]},{"title":"优雅的模拟表单元素radio、checkbox","date":"2015-11-13T00:51:49.000Z","path":"20151113/simulation-of-native-radio-checkbox.html","text":"公司内部管理系统准备改版，最近几天把前端架子搭起来了。在规划底层元素时参考了Bootstrap和Amaze UI，一些组件的实现确实很优雅。比如Amaze UI 的单/复选框。之前我在模拟单/复选框时，都是很暴力的用 js 解决。绑定点击事件；更改 checked 属性值；切换 class 变更样式。而打开控制台观察Amaze UI的单/复选框，发现Elements状态是无更改的。更改checked属性值，并不会影响到标签字面量属性。但是想要切换选中和未选中的样式，如果不是通过切换class来实现，那便是直接修改DOM了，而这两种操作在控制台中的都能看到一个状态变化的响应。那么Amaze究竟是怎么实现的呢？我选中一个元素的图标，在Styles中观察样式变化。直到发现了伪类选择器:checked和相邻选择器+，才恍然大悟。实例&lt;label for=\"sex1\" class=\"form-check\"&gt; &lt;input type=\"radio\" id=\"sex1\" checked name=\"sex\" value=\"1\"&gt; &lt;span class=\"check-icons\"&gt; &lt;i class=\"icon icon-check\"&gt;&amp;#xe632;&lt;/i&gt; &lt;i class=\"icon icon-uncheck\"&gt;&amp;#xe634;&lt;/i&gt; &lt;/span&gt; 男&lt;/label&gt;&lt;label for=\"sex2\" class=\"form-check\" &gt; &lt;input type=\"radio\" id=\"sex2\" name=\"sex\" value=\"0\"&gt; &lt;span class=\"check-icons\"&gt; &lt;i class=\"icon icon-check\"&gt;&amp;#xe632;&lt;/i&gt; &lt;i class=\"icon icon-uncheck\"&gt;&amp;#xe634;&lt;/i&gt; &lt;/span&gt; 女&lt;/label&gt;图标使用的iconfont，然后添加一些样式，我使用less作为css预处理语言。.form-check &#123; display: inline-block; position: relative; margin-right: 1em; padding-left: 24px; line-height: 28px; cursor: pointer; input &#123; display: none; &amp;:checked+.check-icons &#123; .icon-check &#123; display: inline-block; &#125; .icon-uncheck &#123; display: none; &#125; &#125; &#125; .check-icons &#123; position: absolute; top: 5px; left: 0; width: 18px; height: 18px; text-align: center; .icon &#123; position: absolute; top: 0; left: 0; line-height: 18px; font-size: 18px; &#125; .icon-uncheck &#123; color: #d7d7d7 &#125; .icon-check &#123; color: #4776c8; display: none; &#125; &#125;&#125;通过label:for属性来触发input:checked属性值更改。设置相邻选择器，由:checked状态变化影响对应的icon显示和隐藏。兼容性相邻选择器+兼容IE7+，而伪类选择器:checked和label:for属性兼容IE9+（又是这一道坎…）。IE7、8的兼容由选择器的妙用，让我想到了属性选择器[checked]，兼容性为IE7+。.ie8 [checked]+.check-icons .icon-check,.ie7 [checked]+.check-icons .icon-check &#123; display: inline-block;&#125;.ie8 [checked]+.check-icons .icon-uncheck,.ie7 [checked]+.check-icons .icon-uncheck &#123; display: none;&#125;我针对IE7、8应用了这些样式，for属性失去了作用，就需要绑定点击事件来更改checked值。做完之后发现并没有什么卵用。因为属性选择器是针对标签字面量属性启作用，而如input.checked = true;这种修改方式是不会影响到标签上定义的属性。这就牵扯到了attribute和property的区别。var ck = document.createElement('input');ck.type = 'checkbox';document.body.appendChild(ck);ck.checked = true;ck.getAttribute('checked'); // nullck.checked = false;ck.setAttribute('checked','checked');ck.checked // falseattribute 是 html 标签的属性property 是 Dom 标准属性也许是因为标签自定义属性的存在，这两个属性值是不同步的。如果想要使[checked]选择器生效，势必要在点击事件中同步修改attribute和property。实验后发现在IE7、8下正确运行了，对应的icon的display属性确实变化了，但是肉眼看不到样式更改。不知道是不是渲染能力差的原因，总是需要在控制台里点击对应的标签后才看得到更改后的样式。思前思后，既然总归是需要用 js 去兼容，那在IE7、8下还是使用切换class来控制样式。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"iconfont","slug":"iconfont","permalink":"http://imys.net/tags/iconfont/"},{"name":"radio","slug":"radio","permalink":"http://imys.net/tags/radio/"},{"name":"checkbox","slug":"checkbox","permalink":"http://imys.net/tags/checkbox/"}]},{"title":"移动端页面开发关键—尺寸和布局","date":"2015-11-07T15:02:29.000Z","path":"20151107/mobile-page-size-and-layout.html","text":"早上去公司加了半天班（带薪的），为APP上线做了个专题介绍页。当然现在的主题不是介绍在这个专题中我用了哪些技术、实现了何种酷炫的特效。实际上我为了赶时间，我破天荒的没有贯彻自己的一贯作风—造轮子，而是直接引了一个第三方库。在这个APP开发中，我负责内嵌网页的开发，这也是我第一次涉足一个完整的移动端开发项目，以往只写过一些活动分享页、专题页。对于页面兼容性影响最大的两个因素就是“尺寸”和“布局”。好在之前通过社区、博客等看过此类文章，已有了足够的认识，这次项目“实践”的成分更多。尺寸在移动端页面，我用到的尺寸单位有em、rem、vw。px基本不用，但我会设置Dom根元素html字体大小为14px，一来方便em和rem的尺寸计算，二来14px是最常用的字体大小。常规浏览器默认字体大小为16px，最小字体为12px。em首先你要有这样一个基础的认知：假如一个元素没有重设字体大小，那么它的字体大小会继承父级元素，如果父级也没有设置大小，那么依次类推一直追溯到body、html。em是相对于当前元素字体大小计算像素值的，计算方法是em值 * 字体大小。举例：一个元素设置了高度为2em，那么实际像素值为2 * 14px = 28px，而一旦这个元素重设了字体大小为2em，那么该元素高度值为2 * 28px = 56px。另外，其后的子元素的计算基数都会改变。使用em时一旦有设置字体大小的样式出现就需要注意重新计算一些属性值大小了。rem与 em 相比，这货看起来多了一个字母，显然是属于升级版本。rem是始终相对与 Dom 根元素html来计算像素值的。不管当前元素字体如何设置，计算时字体大小仍然以html的字体设置为基准。vwvw指的的当前屏幕宽度，与之对应的还有 vh，表示屏幕高度。如果屏幕宽为 360px，那么 100vw = 360px。是否感觉并没有什么卵用？别着急，下面说一下我的一次适用经历。html：&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;cont cont-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; css：.box { width: 100%; overflow: hidden; } .inner { width: 300%; } .cont { float: left; width: 100%; } 以上代码用以实现三屏的左右切换效果，外层容器.box和三个内容块宽度为屏幕宽度，三个内容块设置了左浮动样式。此时，内层容器.inner需要有3倍的屏幕宽度以承载三个内容块。但是由于宽度继承的关系，在内层容器.inner宽度改变后，内容块的宽度计算基数也改变了。此时设置的100%是等于父级元素宽度的，也就是三倍屏宽。使用js是很容易解决这个问题的，不过vw显然是可以适用这个场景的。只需要如下设置便可解决问题。.cont { width: 100vw; } 该属性在兼容性为android 4.4+，谨慎使用。devicePixelRatio在一个图表页中，我用canvas画了个饼图。发现在手机屏幕中区块颜色显得模糊。于是搜索资料就找到了这个属性，window.devicePixelRatio。目前我对这个属性的理解还不深，基本的理解为：屏幕缩放比。传送门：张鑫旭：设备像素比devicePixelRatio简单介绍我们通过写的css中像素仅为逻辑像素，就是你看到的宽度，而实际上手机屏幕单个点是可能存在多个像素的。如果是常规页面元素是用不到这个属性的，而canvas的真实宽度和css宽度是不一致的。计算方法为：canvas.width = canvas.style.width * devicePixelRatio。需要注意：一旦重设了canvas的真实宽度，那么canvas之上的一切元素都需要乘以devicePixelRatio进行缩放。布局在PC上为了兼容可恶的IE不得不使用大量的浮动来进行块级元素的并行排行。而在移动端我们有了更好的选择，但不是inline-block，而是flex。使用flex可以轻易的实现等宽、散列、垂直居中、多行排列、底部对齐等等各种布局。定义一个flex容器.flex-row { display: flex; } 通过设置容器属性，可以呈现不同的排列对齐方式。flex-wrap定义容器换行方式，默认不换行。可设置换行和反向换行。flex-direction排列方向，默认子元素从左到右顺序排列。通过设置该值可以实现反向排列或垂直方向的上下排列。justify-content主轴（水平方向）对齐方式，默认左对齐。可以实现居中、右对齐、等宽间隔等排列。align-items侧轴（垂直）对齐方式。可实现垂直居中、底部对齐、基线对齐等。align-content多轴垂直对齐方式。最后附上Demo：flex常用布局参考：大漠：Flexbox——快速布局神器阮一峰：Flex 布局教程：语法篇阮一峰：Flex 布局教程：实例篇","tags":[{"name":"移动端","slug":"移动端","permalink":"http://imys.net/tags/移动端/"},{"name":"devicePixelRatio","slug":"devicePixelRatio","permalink":"http://imys.net/tags/devicePixelRatio/"},{"name":"em","slug":"em","permalink":"http://imys.net/tags/em/"},{"name":"rem","slug":"rem","permalink":"http://imys.net/tags/rem/"},{"name":"vw","slug":"vw","permalink":"http://imys.net/tags/vw/"},{"name":"flex","slug":"flex","permalink":"http://imys.net/tags/flex/"}]},{"title":"实现一个简单的模块加载器","date":"2015-10-23T12:41:39.000Z","path":"20151023/simple-module-loader.html","text":"最近大半年也写了不少通用模块，却从来没使用过一种通过书写格式。目前公司的前端通用库还是jQuery, 但也不是所有的模块都适合以jQuery 插件的形式开发。平时写的时候一般以立即执行函数或 OO 形式开发，以目前项目情况来看也不是很需要用require.js或sea.js之类的加载器。其实我的需求很简单，就是抹去模块在全局作用域的定义，以通用的形式定义和引用。最终目标从结果出发分析需求，先列出来最终想要的代码形式。// 形式1：匿名模块，只有一个注入exports参数的函数体module(function (exports) &#123; console.log(require('m1').msg);&#125;);// 形式2：具名模块，包含一个模块名称参数和一个注入exports参数的函数体module('m1', function (exports) &#123; exports.msg = 'hello';&#125;);// 形式3：具名模块，包含一个模块名称参数、依赖模块数组、和一个注入依赖模块、exports参数的函数体module('m2', ['m1'], function (m1, exports) &#123; exports.msg = m1.msg + \"World\";&#125;);// 形式4：匿名模块，与形式3相比没有模块名称module(['m2'], function (m2, exports) &#123; console.log(m2.msg);&#125;);使用module定义一个模块，拥有一个函数上下文，可以定义模块名称和引用其他模块，也可以通过注入的exports参数输出模块开放接口。某些时候也许需要require(&#39;模块名&#39;)这种形式来直接引用模块。1. 注入环境变量从以上四种模块形式来看，module和require两个变量的作用域是全局，需要注入到window中。(function(w, f)&#123; w.module = function () &#123; &#125; w.require = function (namne) &#123; &#125; &#125;(window, undefined));一个简单的立即执行函数就可以做到。2. 解析 module 参数module参数的数量是不固定的，最少1个（形式1）、最多3个（形式3）。可以需要通过判断参数数量和类型加以区分。w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125;&#125;参数数量不固定，也就不必定义形参了，直接从arguments中获取。arguments[0]是模块名，模块名存在时永远是参数第一位；arguments[1]是引用模块，模块名不存在时arguments[0]为引用模块，所以判断模块名是数组类型时重新赋值；不管何种形式模块函数都是最后一个参数，直接使用arguments[arguments.length - 1]获取；3. 实现 module模块函数的参数数量也是不固定的，但至少需要注入exports来输出开放接口。每多引用一个模块，就需要向模块函数中注入一个对应参数。var modules = &#123;&#125;; // 模块容器w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125; // 1. 取出模块 var args = []; if(mods instanceof Array) &#123; for(var i = 0; i &lt; mods.length; i++) &#123; args.push(modules[mods[i]]); &#125; &#125; // 2. 注册模块 if(typeof modName === 'string') &#123; modules[modName] = &#123;&#125;; args.push(modules[modName]); &#125; // 3. 注入参数，执行模块 context.apply(this, args);&#125;遍历mods取出模块：定义了一个变量modules存放模块，那么假如一个模块引用了模块a、b，则mods = [&#39;a&#39;, &#39;b&#39;];，a、b两个模块的真值即为modules[&#39;a&#39;]、modules[&#39;b&#39;]。当模块为形式2时，参数有两个，参数2为模块函数。此时 arguments[1] === arguments[arguments.length - 1]，引用模块(mods)也指向了模块函数，所以要判断mods类型。注册模块：每一个具名模块都需要注册到modules中，以备其他模块引用。当模块为匿名模块时，不需要注册，所以要判断modName类型。注入参数，执行模块：对于不定数量的参数注入，显然是使用apply最简单。4. 实现 requirevar modules = &#123;&#125;; // 模块容器w.module = function () &#123; //...&#125;w.require = function (namne) &#123; return modules[namne];&#125;暂时不考虑异步加载、加载路径解析等各种情况了，直接从容器中取到模块…5. 完整代码(function(w, f)&#123; var modules = &#123;&#125;; // 模块容器 w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125; var args = []; if(mods instanceof Array) &#123; for(var i = 0; i &lt; mods.length; i++) &#123; args.push(modules[mods[i]]); &#125; &#125; if(typeof modName === 'string') &#123; modules[modName] = &#123;&#125;; args.push(modules[modName]); &#125; context.apply(this, args); &#125; w.require = function (namne) &#123; return modules[namne]; &#125; &#125;(window, undefined));// 形式1：匿名模块，只有一个注入exports参数的函数体module(function (exports) &#123; console.log(require('m1').msg);&#125;);// 形式2：具名模块，包含一个模块名称参数和一个注入exports参数的函数体module('m1', function (exports) &#123; exports.msg = 'hello';&#125;);// 形式3：具名模块，包含一个模块名称参数、依赖模块数组、和一个注入依赖模块、exports参数的函数体module('m2', ['m1'], function (m1, exports) &#123; exports.msg = m1.msg + \"World\";&#125;);// 形式4：匿名模块，与形式3相比没有模块名称module(['m2'], function (m2, exports) &#123; console.log(m2.msg);&#125;);执行以上代码会报错，代码是自上而下同步执行的，形式1运行阶段模块m1还未定义。把形式1放到形式4之后执行，输出：helloWorldhello","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"}]},{"title":"gulp改善工作流记录","date":"2015-10-22T02:37:53.000Z","path":"20151022/use-gulp-front-building-exp.html","text":"上个月向领导提出的使用gulp+ejs模块化html最近得到了实施，大概记录下此次改造工作。目录结构html -dest --Folder --index.html --... -src --Folder --Modules ---header.html ---... --index.html --... static -dest --css --js --img -src --css --js --img --less node_modules gulpfile.js package.json gulp模块var gulp = require('gulp'), less = require('gulp-less'), minifycss = require('gulp-minify-css'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), pngquant = require('imagemin-pngquant'), rename = require('gulp-rename'), notify = require('gulp-notify'), browserSync = require('browser-sync'), ejs = require('gulp-ejs'), changed = require('gulp-changed'), replace = require('gulp-replace');html选择了ejs来管理，css预处理选择了less。简单、实用！对于浏览器同步工具，本来使用的是live-reload，在初次使用中感觉不是很顺畅，之后换成了browserSync。browserSync 除了文件更改实时刷新浏览器外，还有多设备同步功能，通过可视化控制台可以实时测试移动端代码。对比而言，live-reload 依赖 Chrome 及 LiveReload 插件，应该是借助 Chrome 的某种开放接口实现的。而 browserSync 是基于虚拟服务器的，所有可以实现多设备的控制。工作流编写html、less、js =&gt; 浏览器访问（URL对应html文件目录） =&gt; 浏览器显示编译后的html、css、js =&gt; html已经过模板合并，include等关键字是没有的 =&gt; css是less编译生成的，页面从始至终引用的都是 css 文件，不过会有一个对应的同名 less 文件。改造进行阶段也没遇到什么太大问题，能遇到的问题也都能在github中找到答案。不过还是要根据各自团队的项目情况因地制宜，合理配置。","tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://imys.net/tags/Gulp/"},{"name":"前端构建","slug":"前端构建","permalink":"http://imys.net/tags/前端构建/"}]},{"title":"Node.js命令行玩法","date":"2015-09-19T12:20:13.000Z","path":"20150919/nodejs-shell.html","text":"Node.js 的热门之处就在于其命令行开发能力。一个在 shell 下编码的程序员绝对要比在常规编辑器上编码的程序员酷！基础环境win10 x64node.jsnpmhello world一切从 hello world 开始！#!/usr/bin/env nodeconsole.log('hello world');普通的 node.js 脚本需要使用node 文件名的形式执行，在脚本首行加上#!/usr/bin/env node可以在linux环境中指定脚本的解释程序。&gt; hello.jshello world全局命令以上的做法只能在特定的目录下执行该脚本文件，如果想做到如node般的无处不在，需要借用npm了。在当前目录新建package.json，如下编码：&#123; \"name\": \"hello\", \"bin\": &#123; \"hello\": \"hello.js\" &#125;&#125;然后执行npm link命令，将会把以上配置注册到全局，这样在任何一个目录都可以调用hello输出hello world了。命令行参数光有特定命令名也只能执行一项特定任务，现在该实现多态了。写一个小工具吧。需求很简单，执行run name打开对应的应用程序。新建文件config.json、run.js，config.json用于配置应用程序的路径。&#123; \"qq\": \"D:\\\\qq\\\\Bin\\\\QQ.exe\"&#125;先拿企鹅开刀，在config.json文件中配置qq.exe的绝对路径。另外别忘了在package.json中添加run.js。#!/usr/bin/env nodevar name = process.argv[2], exec = require('child_process').exec, fs = require('fs');var cfg = JSON.parse(fs.readFileSync(__dirname + '/config.json'));var child = exec('start ' + cfg[name], function(err, stdout, stderr) &#123; if (err) throw err;&#125;);使用系统变量process.argv获取输入参数，引用fs模块用于读取配置文件，child_process模块用于执行系统命令。可为什么参数索引是 2 呢？难道命令行索引从 1 开始吗？其实是因为我们实际执行的命令还是node run name，node索引为 0。开始测试。run qq企鹅登录窗口应声而出。如果还需要其他应用程序的命令行启动可以在config.json中添加新的配置项。以上代码使用的是 node.js 原生的命令行模块，还有一些更方便的包装模块，参考：阮一峰 - Node.js 命令行程序开发教程。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"cmd","slug":"cmd","permalink":"http://imys.net/tags/cmd/"}]},{"title":"Html5调用手机相机并压缩、上传","date":"2015-09-16T08:21:28.000Z","path":"20150916/webapp-input-use-camera.html","text":"近日刚做的一个功能，要在app里使用内嵌页面进行图像的上传。从功能上看，原生的实现应该是最好的。毕竟页面上所有的东西都隔着一个浏览器，所有的实现都要依赖浏览器提供的接口，不同的浏览器对接口的实现又有差异……到最后又会陷入兼容性的大坑!吐槽归吐槽，但是折腾的劲头不能丢！使用input file[camera]属性调用相机简直So easy！&lt;input type=\"file\" accept=\"image/*;\" capture=\"camera\" &gt;只需要这么一条简单的代码，在手机浏览器点击就可以打开相机了。capture是什么？其实就是对打开方式的设置。&lt;!-- capture=camcorder，调用手机摄像功能 --&gt;&lt;input type=\"file\" accept=\"video/*\" capture=\"camcorder\" &gt; &lt;!-- capture=microphone，调用手机录音功能 --&gt;&lt;input type=\"file\" accept=\"audio/*\" capture=\"microphone\" &gt;魅族MX5测试结果：谷歌浏览器可以打开相机和摄像功能，其他方式均为相机、图库、文件管理器等混合选择项。自带浏览器打开均为文件管理器。由此说明此属性兼容性还是个问题。不过这并不能阻止我继续折腾下去！图片压缩在如今这个手机普遍千万像素的时代，一张照片动辄5M的大小。作为一个良心的开发者，我们是要为用户的流量负责的。document.getElementById('file').addEventListener('change', function() &#123; var reader = new FileReader(); reader.onload = function (e) &#123; compress(this.result); &#125;; reader.readAsDataURL(this.files[0]);&#125;, false);不管文件域是用何种方式打开的，都可以在 change 事件中获取到选择的文件或拍摄的照片。创建一个FileReader对象，我们需要调用readAsDataURL把文件转换为base64图像编码，如data:image/jpeg;base64……这种格式。onload是一个异步回调，当文件读取完执行该方法内代码。this.result记录读取结果，如果读取失败，该值为null。在这里进行图片压缩的具体操作。var compress = function (res) &#123; var img = new Image(), maxH = 160; img.onload = function () &#123; var cvs = document.createElement('canvas'), ctx = cvs.getContext('2d'); if(img.height &gt; maxH) &#123; img.width *= maxH / img.height; img.height = maxH; &#125; cvs.width = img.width; cvs.height = img.height; ctx.clearRect(0, 0, cvs.width, cvs.height); ctx.drawImage(img, 0, 0, img.width, img.height); var dataUrl = cvs.toDataURL('image/jpeg', 0.6); // 上传略 &#125; img.src = res;&#125;创建一个Image对象，给src属性赋值为读取结果，同样在onload异步回调中编写处理图片的代码。这里就要开始使用canvas进行图片压缩了。首先是尺寸按比例缩放，然后把图片绘到画布上，最后调用toDataURL方法压缩图像质量。context.toDataURL('MIME类型', 图像质量0-1); // 该方法返回base64图像编码代码里省略了一些校监操作，如文件类型约束和文件大小判断（小于一定值可以不压缩）。最后就是把数据发送到后端的操作，这里就不说了。Html5调用摄像头通过以上的代码已经可以实现调用手机相机拍照、压缩、上传这一整套流程了。不过在折腾的过程中也发现了一种调用摄像头的方法。注意，是摄像头！使用input调用的是相机。其中的差别就是摄像头是只捕获画面，相机还包括原生的一些拍照、设置等控件。通过对摄像头的调用可以做很多有趣的事，比如拍照美化、滤镜等。可以说实现一个第三方相机是没问题的。之前下载过一款安卓相机APP，不到100K的大小，可以实现拍照的一些风格化，也许就是Html5实现的呢。需要用到的是 getUserMedia API，具体的实现这里就不贴了。","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"Webapp","slug":"Webapp","permalink":"http://imys.net/tags/Webapp/"},{"name":"File","slug":"File","permalink":"http://imys.net/tags/File/"}]},{"title":"使用gulp+ejs模块化html","date":"2015-09-08T10:04:47.000Z","path":"20150908/gulp-ejs-module.html","text":"在静态页面目录中，同子目录下的页面往往有很多通用的模块。平常的编码一般是通用的代码直接复制到各个页面，样式写成公用，然后在各个需要的页面引用。而一个产品在实地运行中往往要经历无数次的迭代，于是页面文档结构和样式也在不断的变化。独立性的页面比较轻松，一个页面修改就好了，而一些公用的页面模块往往需要在各个页面逐个修改。这显然是一种极其枯燥的重复性动作！在此之前我用 C# 写了一个文件批量替换的工具，用于批量替换某个目录下的某个模块代码。虽然效率提高了一些，但是从方法学角度看绝对不是最好的。很久之前就想过使用前端模块拼装 html。以 ejs 为例，则需要在页面中引入模版解析文件 ejs.js，页面中还需要写一些 ejs 相关的配置代码。而这些东西对于后端套用页面来说是无用的，可能还会造成一些混乱。还有一种引用方式是使用 nodeJs 调用 ejs 去解析模版文件，这样在预览静态页面时则需要建立 node 服务器。而当前团队中并不是每个人都装有 node 环境。最近工作闲暇了又想到这个问题，其实要解决的最根本问题就是：模块化开发页面，开发完成后可以一条指令合并成可直接预览的静态页面。我早该想到 gulp 了，既然 gulp 是一个基于流的前端构建工具，那么对于这个问题应该是可以解决的。起初我是这样想的：模板中使用相对路径标记模块引用读取文件把这些标记还原为路径读取这些路径的文件内容插入到模板中生成到对应目标目录这样做等于实现了一套模版解析合并的过程，并不困难。在探索的过程中，我发现了一个基于 gulp 和 ejs 的插件 gulp-ejs，并按照示例实验后达成了我的想法。随后新的问题便来了。每个页面有着不同标题和样式、脚本引用，虽然可以在执行 gulp 任务时指定参数，但是不可能每个页面的参数配置都一样。难道要为每个页面编写一个任务？你会甘心用这么傻的办法吗？从设计模式角度讲，这个任务应该是唯一的，但是可以根据一些参数配置达到多态！之后我改造了 gulp-ejs：在模板文件同级目录下添加同名的 .json 配置文件在其对模板渲染时获取模板路径，再转换后缀为 json，这样就匹配到了对应的配置文件解析 json 文件为 json 对象，作为参数传入 ejs 中，这样模版内就可以访问配置文件的数据了之后便可以根据配置文件随心所欲的插入当前页面的特定项目这样标题、样式、脚本，神马都解决了！就在刚才我又想到了另外一个主意。如果你觉得每个模板对应一个 json 文件麻烦的话，可以只建立一个配置文件。假如你有 index 、product 、service 三个模版，那么你的配置文件可以这样写：&#123; \"index\": &#123; \"title\": \"首页\" &#125;, \"product\": &#123; \"title\": \"产品页\" &#125;, \"service\": &#123; \"title\": \"服务页\" &#125;&#125;那么在 index 模版中输出 title，就可以写成 &lt;%=index.title %&gt; 这种格式。长久下去配置文件一定会越来越大，而且每个模版中都被注入了整站的配置项，真的好吗？为了使每个页面只注入当前页面的数据，可以在模版渲染前拿到模版名称，如 index ；向 ejs 传入的数据就变成了 config[&quot;index&quot;]；这样在每个模版中依然可以直接用 &lt;%=title %&gt; 这种格式调用了不管采取哪种办法，最终的结果是一致的。哪怕是每个模版注入整站配置的做法，也只是在 gulp 任务阶段执行效率低点，并不会上升到影响性能的高度。不过，我还是倾向于一个页面对应一个配置文件的办法，谁让我是处女座。以下是对该方案的简单描述。目录结构├ templates 模版 ├──── _partial 模块 ├──────── header.ejs ├──────── footer.ejs ├──────── nav.ejs ├──────── left.ejs ├──────── right.ejs ├──── index.ejs 布局页 ├──── index.json 布局页配置文件 ├ html 页面 ├──── index.html 生成的静态页面 ├ node_modules node模块 ├ gulpfile.js gulp 工作流程模板编码，即 templates/ 目录，一个布局页对应一个同名静态页面，按需引入或编写新的页面模块。在这个阶段可以使用express建立node服务器进行实时页面预览。编写配置文件，使用通用的 json 格式，一个页面对应一个同名的配置文件。目前预想的配置信息有： title：页面标题 、styles：依赖的样式文件路径、 scripts：依赖的脚本文件路径 ，随时可以根据实际情况添加新的配置。执行 gulp 任务，生成页面到 html/ 目录。未模块化页面的处理之前未模块化的静态页面，保持原样即可，因为在这个流程中与之前的页面是没有任何冲突关系的。一些频繁修改的页面，可以按需抽取出模块，进行页面分割。完整Demohttps://github.com/yscoder/gulp-ejs-demo写在最后可能我所做的这些对于国内一些优秀的前端团队来说很土，但是适合的才是最好的！目前我所在的公司前端的职能还仅限于页面编码、交互实现和一些通用插件开发，起点真的很低。不过，这也让我有了更多的机会去改革和实践新技术。","tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://imys.net/tags/Gulp/"},{"name":"Ejs","slug":"Ejs","permalink":"http://imys.net/tags/Ejs/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"}]},{"title":"前端文字的截断处理","date":"2015-09-06T09:37:32.000Z","path":"20150906/text-truncation.html","text":"关于前端页面的文字溢出截断的招数已经很常见了。通常的实现有，前端css控制、后端字数输出控制或者前端js字数处理等。单行文字单行文字的溢出处理很简单，我通常是使用css来控制，在文字末尾加上...。.ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;给需要文字截断的节点增加一个这样的基础类，然后设置该节点的宽。同时注意给未来可能会出现溢出的节点也加上此类，再设置最大宽度max-width，因为很多奇葩用户的输入是你无法掌控的。 - -！多行文字我希望在一个的固定高度的容器中，内容超出后，最后一个文字显示...。如法炮制给多行文字的容器添加ellipsis类后，你会发现的确是显示...，不过此时文字是一行的。因为在该类中添加了属性white-space，用来定义一个段落如何换行。属性值nowrap：禁止文本换行，除非遇到&lt;br&gt;。一番思考后，确定了一个方案。给固定高度的容器添加overflow: hidden；给容器添加相对定位；添加伪元素样式，content:&#39;...&#39;，绝对定位，然后位置定位在容器末尾。伪元素的兼容性为IE8，如果需要兼容IE7的可以使用标签代替。带显示全部的多行文字类似 QQ 空间、微信、微博那种。使用 2 个伪元素加 1 个 a 链接实现。精妙之处在于使用伪元素遮挡一行文字，让 a 链接位于伪元素之上显示。","tags":[{"name":"Html","slug":"Html","permalink":"http://imys.net/tags/Html/"},{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"Ellipsis","slug":"Ellipsis","permalink":"http://imys.net/tags/Ellipsis/"}]},{"title":"html5上传进度实现","date":"2015-09-02T08:26:13.000Z","path":"20150902/h5-upload-progress.html","text":"博客一个月没更新了，着实是有点忙。目前公司新版上线也到最后一波了，部分人员转战了一个新的APP产品的开发。主体还是原生APP，也会有部分页面需要嵌入WEB页面，我也有幸作为唯一的前端人员加入了。不过这次讲的内容跟这个APP没有半毛钱关系，是公司内部工作系统的一个扫码上传功能。好吧，我参与的确实有点多！要实现实时的进度展示，需要以下几个关键：异步上传文件总大小文件已上传大小基本HTML结构&lt;input type=\"file\" id=\"upload\" accept=\"image/*\" &gt;异步上传XHR是必须的，此外还需要一个FormData对象。FormData，译为表单数据，也就是一个保存表单数据的容器。可以利用这个对象写入键值对的数据项，再用xhr发送到处理接口。var data = new FormData();data.append('id', 9527);data.append('name', '张三');data.append('sex', '男');不仅可以像以上简单的添加值类型，文件类型也不例外。这样就可以直接使用xhr的send方法发送到后端。document.querySelector('#upload').addEventListener('change', function() &#123; var file = this.files[0], data = new FormData(); data.append('photo', file); var xhr = new XMLHttpRequest(); xhr.addEventListener('load', function(event)&#123; // Success or Error &#125;, false); xhr.open('post', '/doLoad'); xhr.send(data); &#125;);上传进度与FormData相对应的上传状态监听事件xhr.upload.addEventListener('progress', function(event)&#123; // do...&#125;, false);该事件可以通过event对象获取上传状态。event.loaded: 已上传大小event.total: 文件总大小这样计算进度就不在话下了，具体实现也就不废话了，众大侠各展神通吧！","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"文件上传","slug":"文件上传","permalink":"http://imys.net/tags/文件上传/"}]},{"title":"Require.js入门--用面向对象语言来理解js模块化","date":"2015-08-07T02:33:25.000Z","path":"20150807/js-module-requirejs.html","text":"作为一个曾经的后端开发者，当我第一眼看到一些javascript模块化的代码案例时，我就想到了java、c#这些天生的模块化语言。今天就拿 require.js 来捋一捋这其中的异同。模块化一个基本的javascript模块，应该是隐藏私有成员及方法，暴漏外部调用的所需的接口。常见的写法有：var module = (function()&#123; var prop = ''; var tool = function(p)&#123; &#125;; //... return &#123; fn: function()&#123; tool(prop); &#125; &#125;;&#125;)();在以上代码中，外部环境无法读取和修改变量prop和方法tool，但是该模块返回了一个公开的对象，并有一个可执行的方法fn。这不就相当于面向对象编程中的封装吗？在以上代码中使用了闭包来隔离变量作用域，而像java中可以使用public、private这样的关键字来定义成员。require.js入门刚才通过一段简单的代码理解了模块化的作用，下面来看看require.js是如何定义和调用模块的。页面加载&lt;script data-main=\"main\" src=\"http://cdn.bootcss.com/require.js/2.1.20/require.min.js\"&gt;&lt;/script&gt;在页面中插入了require.js文件，使用data-main指定主模块或者叫入口模块，我理解为java中的main()方法。data-main属性可以写模块文件的路径，在require.js中默认的后缀.js可省略。入口模块如果我们的页面非常简单的话，在入口模块中可以写我们的js代码。比如：console.log('Hello require.js!');此时刷新页面就会直接在控制台输出Hello require.js!。当然如果是这样的话，也就没必要用require.js了。正常的写法一般是这样的：require(['module1', 'module2'], function (module1, module2)&#123; //...&#125;);第一个参数数组表示依赖的模块名，然后在其后的回调函数中就可以使用这些模块。加载模块当然，不可能凭空使用模块，按照常规肯定需要某个地方指定模块加载路径吧。在主模块头部可作以下配置：require.config(&#123; paths: &#123; 'module1': 'js/module1', 'module2': 'js/module2' &#125;&#125;);如果所有模块都在同一个目录则可以配置baseUrl。require.config(&#123; baseUrl: 'js', paths: &#123; 'module1': 'module1', 'module2': 'module2' &#125;&#125;);也可以直接使用URL配置远程文件链接。require.config(&#123; paths: &#123; 'jquery': 'http://cdn.bootcss.com/jquery/2.1.4/jquery' &#125;&#125;);与java中的导包的作用类似，import xxx.xxx.xxx;。定义模块目前常见的的js模块规范有CMD、AMD、CommonJS以及兼容性写法的UMD，require.js是实现了AMD规范的js库。定义一个模块tool，如下写法：define(function ()&#123; var msg = 'The Hello at tool.'; return &#123; hello: function()&#123; console.log(msg); &#125; &#125;;&#125;);如果该模块依赖其他模块，如jquery，就需要定义模块依赖。如入口模块的定义一样，第一个参数写成模块名数组。define('[jquery]', function ($)&#123; var msg = 'The Hello at tool.'; return &#123; hello: function()&#123; console.log(msg); console.log($ === undefined); &#125; &#125;;&#125;);依赖的模块依然需要在入口模块中配置加载路径，但不是必须要在入口模块中注入。在这个模块中我们发现了这段代码与一开始的基本模块写法类似，一样是只暴漏必须的调用接口。现在可以在入口模块中调用这个模块：require(['tool'], function (t)&#123; t.hello();&#125;);如果jquery加载正确的话，控制台会输出：The Hello at tool.false好了，现在可以去更新简历在技能上加上require.js了！结束各种模块化规范殊途同归，都是为了解决同样的问题。理解了其中一种，都可以轻松掌握其他规范的写法。未来我们还有天然支持类和模块的ES6，期待吧？我一直认为好的开发人员不应该局限于一个技术栈，因为这样会阻碍你对一个问题的全面认知和对新知识的快速领会。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"},{"name":"Require.js","slug":"Require-js","permalink":"http://imys.net/tags/Require-js/"}]},{"title":"canvas实践--图表组件仪表盘、雷达图","date":"2015-07-31T01:14:34.000Z","path":"20150731/canvas-chart-demo.html","text":"大数据概念的到来，图表的运用越来越广泛，不搞搞数据，都不好意思说是互联网公司。最近公司又有一块图表展示的栏目要做，由于之前的图表栏目都是我完成的，这次不出意料又落在我身上。之前的图表展示我用的是echarts，按格式封装数据调用就行了。这次领导突然对图表样式有了一些要求，虽然echarts的配置够OP，也不可能完完全全跟设计图搞成一样的。暨于上次的canvas的使用，我决定自己动手实现所需要的图表组件。这是最终的完成样式：canvas实践--图表组件仪表盘、雷达图首先根据效果图来划分出各个图层，以及图层层级位置。然后按照层级关系由下向上依次绘制。整个编码过程还是很顺利的，一些问题都得到了很好的解决。查看github踩过的坎确定圆上任意一点的位置此次绘制的图表分别是仪表盘和雷达图，很多图形或点的位置都需要进行一定的计算。比如仪表盘上的指针坐标、雷达图各个角的位置等。而两个图表都是基于圆心角绘制的图形，所以可以使用 圆的参数方程 来轻松解决。x = cx + r &times; cos(π &times; e)y = cy + r &times; sin(π &times; e)cx: 圆心点横坐标r: 半径e: 结束角cy: 圆心点纵坐标绘制渐变色圆环原本看到仪表盘样式图时，预想的这个渐变圆环需要一节一节用不同的颜色画上去的。实际的实现要简单太多了！可以直接使用绘制渐变色的方法。canvas支持线性渐变和放射形渐变，这里使用的是线性渐变。方法描述createLinearGradient(x0, y0, x1, y1)创建线性渐变，参数分别表示起始点x坐标和y坐标、结束点x坐标和y坐标。addColorStop(stop, color)规定渐变对象中的颜色和停止位置，stop表示一个颜色的渐变结束位置0-1之间，color表示渐变色。具体的使用可以点这里。顺便说说如何根据设计图确定渐变的位置和颜色。用ps打开美工给的psd文件；找到渐变的图层样式设置；照着上面的设置来就行了。绘制虚线HTML5规范中已有绘制虚线的方法，支持的浏览器有Chrome, Safari, IE 11 和 Opera。context.setLineDash()使用参考开场动画canvas本身没有这方面的支持，需要使用定时器来进行一定时间的重绘来实现。整个逻辑大概是这样的：// 1. 设置最小初始值，获取最终值var value = 0, endValue = 668;// 2. 启动定时器根据value动态绘制var timer = setInterval(function()&#123; // 3. value累加，如果小于最终值就加一定值，否则等于最终值 value = value + 1 &gt; endValue ? endValue : value + 1; // 4. 清空画布 context.clearRect(0, 0, 500, 300); // 5. 根据value来进行此次绘制 // 具体步骤省略... // 6. 判断value是否等于最终值来结束定时器 if(value === endValue) &#123; clearInterval(timer); &#125;&#125;, 10);可以通过调整累加数和定时器时间来控制动画速度。其他说起来这两个组件的封装和调用也是凭着echarts的使用经验来设定的，感谢百度前端大大们为此作出的贡献！","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"Canvas","slug":"Canvas","permalink":"http://imys.net/tags/Canvas/"},{"name":"Chart","slug":"Chart","permalink":"http://imys.net/tags/Chart/"}]},{"title":"Canvas初试--环形进度条的实现","date":"2015-07-22T00:21:53.000Z","path":"20150722/canvas-annulus-process.html","text":"起初想这么做既是css3不易实现圆环，而且也有低版本兼容问题，也想借此机会学习下canvas(虽然最后还是难逃兼容性 &gt;_&lt; )。做的过程中发现canvas跟C#中gdi绘图的步骤其实是差不多的。先大概看了下canvas的相关API，有个可以画弧的方法arc。通过合理的参数设置就能实现各种角度的圆弧，或者满圆。Canvas初试--环形进度条的实现定义canvas&lt;canvas id=\"process\" width=\"200\" height=\"200\" data-process=\"85\"&gt;&lt;/canvas&gt;在基本的HTML5文档中添加一个canvas，定义了id宽高以及一个自定义属性表示要显示的进度值。画背景圆（灰色）首先了解下arc方法：context.arc(x,y,r,sAngle,eAngle,counterclockwise);参数描述x圆的中心的 x 坐标。y圆的中心的 y 坐标。r圆的半径。sAngle起始角，以弧度计（弧的圆形的三点钟位置是 0 度）。eAngle结束角，以弧度计。counterclockwise可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。var c = document.getElementById('process');var process = c.getAttribute('data-process');var ctx = c.getContext('2d');// 画灰色的圆ctx.beginPath();ctx.arc(100, 100, 80, 0, Math.PI*2);ctx.closePath();ctx.fillStyle = '#F6F6F6';ctx.fill();以上代码中设置了圆心为100,100，正好的画布中心，圆半径为80，起始角度0表示3点钟方向，结束角度Math.PI*2其实是个满圆。下一步会说明起始角度和结束角度具体算法。画进度环（橙色）// 画进度环ctx.beginPath();ctx.moveTo(100, 100);ctx.arc(100, 100, 80, Math.PI*1.5, Math.PI*(1.5+2*process/100));ctx.closePath();ctx.fillStyle = '#FF9600';ctx.fill();与上一步比较，多了一句ctx.moveTo(x,y);，意为把路径移动到画布中的指定点，如果没有这一步画出来的就不是弧了。起始角度和结束角度也发生了变化，要想真正理解这两个角度，看下图。Canvas初试--环形进度条的实现3点钟方向用0(0PI)表示，6点钟是0.5PI，9点钟1PI，12点钟1.5PI，这样转一周回到3点钟即为2PI。所以满圆可以用起始角度0(0PI)和结束角度2PI表示。我们要画的圆环是需要从12点钟方向开始的，所以设置起始角度1.5PI。process在第一步中获取了要显示的进度85，即为85/100的圆，按原来3点钟开始，那么结束角度可以计算为Math.PI*2*85/100。因为起始角度的变更，结束角度也要进行相应的变化，各在原来的基础上加了1.5的基数。起始角度0 -&gt; Math.PI &times; 0 -&gt; Math.PI &times; (0+1.5) -&gt; Math.PI &times; 1.5结束角度Math.PI &times; 2 -&gt; Math.PI &times; 2 &times; 85/100 -&gt; Math.PI &times; 2 &times; process/100 -&gt; Math.PI &times; (1.5+2 &times; process/100)画内填充圆（白色）// 画内填充圆ctx.beginPath();ctx.arc(100, 100, 60, 0, Math.PI*2);ctx.closePath();ctx.fillStyle = '#fff';ctx.fill();半径减少20，进行内圆填充。填充显示文字（数字百分比）// 填充文字ctx.font = \"bold 20pt Microsoft YaHei\";ctx.fillStyle = '#333';ctx.textAlign = 'center';ctx.textBaseline = 'middle';ctx.moveTo(100, 100);ctx.fillText(process+'%', 100, 100);完成！关于canvas在IE7、8下的兼容需要引用google的 excanvas.js ，并把画图的相关的代码放到window.onload下。不过这个文件有些大，40K+，压缩后17K。","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"Canvas","slug":"Canvas","permalink":"http://imys.net/tags/Canvas/"},{"name":"Process","slug":"Process","permalink":"http://imys.net/tags/Process/"}]},{"title":"用户体验--WEB站点快捷键实现方案","date":"2015-07-16T07:06:58.000Z","path":"20150716/ue-shortcut-key.html","text":"今天一大早就被头儿派了任务，让我整理一份可用快捷键操作的可行性方案。不敢懈怠，遂出此文。分析对于WEB站点的多数操作也就是鼠标点点罢了，多数普通用户都是不愿意记那么多东西的，所以首先要考虑用户可接受性。可以从以下几个方向考虑快捷键：通用、易用、习惯，常用功能使用，可快速接受，习惯性按键方便、快捷，有效提升操作效率专用，针对特殊功能、特殊人群和特殊需求计划可用键从语义化来讲，专门的键做专业的事。增加用户便利的前提下不能滥用一些系统和浏览器规划好的按键，如常用的复制和粘贴。此类按键很多，这就导致可被我们利用的键很少。最好的当然是设置1个键，不过在多数人习惯了office、QQ等软件后也习惯了一些快捷键操作。所以可以从这些习惯中推导出一些可用键，2-3个组合键也未尝不可，还可以考虑双击。单键：Esc,Enter,Tab,Delete,Home,方向键等。组合键：Ctrl+*,Ctrl+alt+*。可入手项全局或局部的Tab焦点切换，特别是表单；任何搜索和提交的地方都应该绑定Enter键；表单文本框点两下backspace全部删除；Esc取消输入焦点或取消操作；Home跳转个人中心或企业中心；Del删除选中的项；主导航或重要栏目的访问键；用户的自定义快捷键；标签页切换；一键注销登陆用户；站内搜索;一键返回顶部；容我三思……实现在上述项都需要实施的前提下，整个实现必然是需要贯穿整站的。会有全局的按键绑定，也会有针对性的某个功能或页面的实现。最后我的想法如下：添加全局Hook模块，捕获按键并执行对应的操作。全局性的绑定可以写到全局js文件中，特殊情况特殊对待。","tags":[{"name":"用户体验","slug":"用户体验","permalink":"http://imys.net/tags/用户体验/"},{"name":"WEB","slug":"WEB","permalink":"http://imys.net/tags/WEB/"},{"name":"快捷键","slug":"快捷键","permalink":"http://imys.net/tags/快捷键/"}]},{"title":"造个轮子-基于jquery的文字提示插件jtip","date":"2015-07-15T07:21:58.000Z","path":"20150715/jqplugin-jtip.html","text":"最近工作不是很忙，看到站里一些纯图标的按钮还是使用的默认的title属性作文字提示，就造了这个轮子。jtipjtip介绍目前功能位置自动居中对齐；支持上下两个方向的的显示；宽度自适应（超出长度限制自动换行）；自定义显示场景（常态、警告、错误）；可设置位置偏移量。兼容性IE7+(包括IE7)，等现代浏览器。使用可用于任何具有title属性的DOM元素。 如：&lt;a href=&quot;&quot; title=&quot;your title&quot;&gt;text&lt;/a&gt; &lt;div title=&quot;your title&quot;&gt;&lt;/div&gt; 依赖文件jtip.cssjquery.jsjtip.js调用$(selector).jtip({ direction : &apos;top&apos;, // 显示方向，可选值 top、bottom className: &apos;jtip&apos;, // 可自定义CSS类名 type: &apos;&apos;, // 显示类型，可选值 &apos;&apos;(缺省为空)、warning、danger skewing: 0 // 位置偏移量 }); 源码已上传github，https://github.com/yscoder/jtip 。遇到的问题1.获取DOM节点基于文档的位置某些情况下jQuery.offset()在IE8下无法获取准确数值，可以使用原生DOM属性offsetLeft、offsetTop获取，IE7仍需使用jQuery.offset()获取。2.IE7容器宽度自适应单行内容设置display:inline；多行内容设置min-width和overflow:visible。","tags":[{"name":"jQuery插件","slug":"jQuery插件","permalink":"http://imys.net/tags/jQuery插件/"}]},{"title":"ie不显示iconfont字体图标","date":"2015-07-09T02:12:33.000Z","path":"20150709/ie-nodisplay-iconfont.html","text":"昨天助理妹子收到客户的反馈，说浏览器不显示按钮了。经过远程查看，发现是iconfont(字体图标)不显示了。新版网站上线后整站使用iconfont替代了图片图标，一些小按钮都是直接使用的iconfont。查看过后一时半会也是找不到原因，只是在脑海中一遍一遍的咒骂万恶的IE(客户使用的是IE8)！因为接触不到真实客户环境的关系，暂时先让客户使用其他浏览器登陆。直到今天公司销售部门也反馈了类似的问题，可以去实地排查原因了。系统环境 win7 sp1 32位浏览器 世界之窗极速版在浏览器极速模式下是没有问题的，切换到兼容模式后字体图标就失踪了！所有双模式切换的浏览器的兼容模式归根结底还是调用的本机的IE，所以这还是IE的问题。我们先是找到IE浏览器，因为是win7，所以最低也是IE8了。更改Internet选项里的配置，无果！测试了链接字体图标库文件，也是正常的！Win7视觉效果全开也没用！F12添加行内字体样式也没作用！最后得出结论，这货就是根本不识别字体样式啊！这货打开的任何一个网页都是宋体，难道字体库只有宋体吗？可为什么极速模式字体就正常呢？win+R -&gt; fonts 发现所有系统自带字体都安安静静的躺着呢。再次打开 Internet选项 -&gt; 外观 -&gt; 字体 -&gt; 微软雅黑，所有页面字体都变成微软雅黑了。然并卵！不经意间 Internet选项 -&gt; 外观 -&gt; 辅助功能…我滴个神！我看到什么了？ie不显示iconfont字体图标原来是把网页字体忽略了！也是第一次知道IE还是这些设置选项，还可以定义用户样式。这次也算是长见识了。","tags":[{"name":"Html","slug":"Html","permalink":"http://imys.net/tags/Html/"},{"name":"iconfont","slug":"iconfont","permalink":"http://imys.net/tags/iconfont/"}]},{"title":"css3选择器(:target)用法","date":"2015-06-29T00:57:17.000Z","path":"20150629/css3-target-selector.html","text":"target译为“目标”，加冒号即为伪类选择器。此选择器便是用于给目标元素添加额外样式，类似于hover。使用该选择对应的目标元素为锚点触发。以下代码定义了两个a元素，其中一个为链接元素，另一个使用样式定义为块元素。块元素设置了透明度为0，并设置其被链接时透明度为1和过度效果。最终的效果为点击链接元素时，div1从透明到不透明过度。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;target选择器&lt;/title&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;style&gt; .link &#123; display: block; text-decoration: none; text-align: center; color: #fff; background: #ff0000; line-height: 30px; &#125; .a-block &#123; display: block; opacity: 0; &#125; .a-block:target &#123; opacity: 1; transition: all .3s; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#div1\" class=\"link\"&gt;显示&lt;/a&gt; &lt;a id=\"div1\" class=\"a-block\"&gt; :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;注意起初我写下这段Demo时目标元素是用的div，后来发现该选择器不能像:hover一样作用于a以外的元素。另外该选择器的兼容性为IE8以上（不包括IE8）。适用场景结合这个Demo可以发现该选择器又一次实现之前需要JS才能实现的功能，比如点击链接显示元素。另外在全屏滚动动画页面时也可以用在导航之上，比如点击导航给对应的块添加动画效果。更多使用方法也待慢慢摸索了！","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"},{"name":"selector","slug":"selector","permalink":"http://imys.net/tags/selector/"},{"name":"target","slug":"target","permalink":"http://imys.net/tags/target/"}]},{"title":"HTML5页面可见性改变事件","date":"2015-06-15T03:01:53.000Z","path":"20150615/js-page-visible.html","text":"通过该事件可以判断当前页面对于用户的可见性，即返回用户当前浏览的页面或标签的状态变化。visibilitychange（页面可见性改变事件）该事件属于HTML5新API，兼容性IE10+，以及其他现代浏览器等。以下是一个简单的案例，当用户离开当前页面时改变页面标题。var pageVisible = (function()&#123; var title = ''; var change = function() &#123; document.addEventListener('visibilitychange', function() &#123; var temp = this.title; this.title = title; title = temp; &#125;) &#125; return &#123; init: function(tit)&#123; title = tit || '好好学习，天天向上！'; change(); &#125; &#125;;&#125;)();pageVisible.init();此外，还可以在事件内对页面可见性属性判断可见性状态。document.hidden: Boolean值，表示当前页面可见还是不可见。适用场景，如：1.用户离开媒体页面停止播放媒体；2.用户离开游戏页面暂停游戏；3.等等……","tags":[{"name":"Html5","slug":"Html5","permalink":"http://imys.net/tags/Html5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"}]},{"title":"js阻止子元素响应父元素事件","date":"2015-05-27T12:44:34.000Z","path":"20150527/js-cancel-event.html","text":"今天同事遇到这样一个问题，找我解决。他希望点击整个DIV都可以响应点击事件，但是有些交互元素需要排除掉。如：点击链接页面跳转、点击按钮响应事件等）。这是一个关于事件冒泡的问题，那便从事件冒泡写起。事件冒泡在一个元素上触发事件，如果此元素定义了处理程序，那么此次事件就会被捕获，根据程序进行该事件的处理。否则这个事件会根据DOM树向父节点逐级传播，如果从始至终都没有被处理，那么最终会到达document或window根元素。阻止事件冒泡W3C标准调用事件对象的stopPropagation()方法，IE可以设置对象的cancelBubble属性为true;在Jquery中的事件方法都带有event参数，这是一个符合W3C标准的事件对象，且兼容IE，可以使用event.stopPropagation()阻止冒泡。更简单的，直接return false;，等价于event.stopPropagation()加上event.preventDefault()。在原生JS中，事件对象要区别对待。function cancelEvent(e) &#123; if(e) &#123; e.stopPropagation(); //非IE &#125; else &#123; window.event.cancelBubble = true; //IE &#125;&#125;阻止多个子元素的事件综上所述，想要链接和按钮元素不响应父节点事件，便要为所有这些元素注册事件，编写阻止事件冒泡的代码。现在的代码可以这样写：var div = $('#div');div.click(function()&#123; // do...&#125;);div.on('click', 'a,button,input', function(event)&#123; event.stopPropagation(); // 或 return false;&#125;);这当然是可以解决问题的。可对于处女座的我完全无法接受平白无故多写了一段莫名奇妙的代码。于是我想到了event对象。event.target 返回事件的目标节点（触发该事件的节点）。event.target.tagName 目标节点的标签名把上面两个事件合并处理之：$('#div').on('click', function(event)&#123; var tag = event.target.tagName; if(tag!='A' &amp;&amp; tag!='BUTTON' &amp;&amp; tag!='INPUT')&#123; // do... &#125;&#125;);","tags":[{"name":"Event","slug":"Event","permalink":"http://imys.net/tags/Event/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"}]},{"title":"Hexo添加Toc支持，生成文章目录","date":"2015-05-14T07:25:47.000Z","path":"20150514/hexo-toc.html","text":"Hexo提供了诸多插件来增强博客体验，地址http://hexo.io/plugins/。在博客搬迁的时发现一个生成文章目录的插件，hexo-toc。hexo-toc为防插件误认标记，文章以下出现的 ttoc 实际为 toc。使用方法跟显示文章摘要类似，在Markdown中需要显示文章目录的地方添加 &lt;!-- ttoc --&gt;。安装npm install hexo-toc --save配置在博客根目录下的 _config.yml 中如下配置：toc: maxDepth: 3maxDepth 表示目录深度为3，即最多生成三级目录。好了，现在重启Hexo预览下效果吧。Toc文章目录然后你会发现点击目录链接，没反应！F12查看生成的HTML代码：Toc生成代码标题id生成没问题，锚链接中的中文都被转义为 - 了。看了该插件的issues中已经提到了这个问题，不过好像是没解决。也没用搜索到其他人有关该插件的使用经验。没办法，自己动手丰衣足食！解决锚链接中文被转义也没什么好的办法，只凭着入门级的Node水平，顺藤摸瓜！从插件下的index.js开始，一路跟踪代码调试，在感觉可能出现问题的地方console输出内容，最终让我给找到了。文件位置：Hexo根目录\\node_modules\\hexo-toc\\node_modules\\markdown-toc\\index.js。找到如下方法，把原来返回值注释掉，直接 return str; 。function slugify(str, opts) &#123; if (opts &amp;&amp; opts.slugify === false) return str; if (opts &amp;&amp; typeof opts.slugify === 'function') &#123; return opts.slugify(str, opts); &#125; str = str.split('.').join(''); //return str.toLowerCase().replace(/[^a-z0-9]/g, '-'); return str;&#125;现在重启Hexo后链接都正常可用了。更好的方法是不改变插件源代码的情况下进行配置。在以上方法中可以发现，插件有个slugify的配置项，当此项配置为false时即直接return str;。所以，我们可以到_config.yml添加toc配置：toc: maxDepth: 3 slugify: false 给Toc添加样式如本文中文章目录样式，置于文章右侧，又加了个背景等。hexo-toc插件是生成的文章目录最终还是Markdown格式的，最后被Hexo的marked模块解析为HTML。要添加样式先加选择器。想通过修改插件代码增加选择器是行不通的，也不能直接在 &lt;!-- ttoc --&gt;标记外包裹 &lt;div&gt;。因为添加了HTML标签的地方就不会在被marked模块解析。那就只能在HTML生成之后增加，用js。hexo-toc插件生成文章目录时还在其前后增加了 &lt;!-- ttoc --&gt; 和 &lt;!-- ttocstop --&gt; 注释。解决办法就是把这两个注释替换为可控的 &lt;div&gt;。找到主题下的文章模版，我的是themes\\yilia\\layout\\_partial\\article.ejs。在其末尾增加代码：&lt;% if (!index &amp;&amp; theme.toc)&#123; %&gt;&lt;script&gt; var tocEx = function(el)&#123; var toc = document.querySelector(el), content = toc.innerHTML; content = content.replace(&apos;&lt;!-- ttoc --&gt;&apos;, &apos;&lt;div class=&quot;toc&quot;&gt;&apos;).replace(&apos;&lt;!-- ttocstop --&gt;&apos;, &apos;&lt;/div&gt;&apos;); toc.innerHTML = content; &#125;(&apos;.article-entry&apos;);&lt;/script&gt;&lt;% &#125; %&gt;这样我们就为文章目录外包裹了一对&lt;div&gt;标签和一个toc类。再写这个类的样式，放到主题下的相关css文件中。.toc &#123; float: right; margin-left: 40px; padding: 10px 20px; background: #f1f1f1; border-radius: 10px; box-shadow: 0 0 3px #bbb;&#125;这些都做完再次重启Hexo，成功！2016年更新Hexo 已经有生成文章目录的辅助函数了，使用更方便。我现在博客中的文章目录就是使用辅助函数生成的。Hexo辅助函数#toc不需要安装额外插件！不需要在文章中插入标记！不需要在配置文件添加配置！仅仅是在你的文章页模版中，插入调用辅助函数的代码即可。&lt;%- toc(page.content, &#123; class: 'post-toc', list_number: true &#125;) %&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"TOC","slug":"TOC","permalink":"http://imys.net/tags/TOC/"}]},{"title":"博客搬迁记 - 从WordPress到Hexo","date":"2015-05-13T01:50:02.000Z","path":"20150513/wordpress-to-hexo.html","text":"今天早上打开电脑第一件事就是把pages绑定了域名，从此便可以使用http://imys.net进行访问了。至此已经折腾的差不多了，在此记录下搬迁过程中遇到的一些问题及解决办法。Hexo3本地部署现在node下安装的hexo一般都是最新版本，网上搜索到的一些教程不乏是老版本的，要特别留意。参考用Hexo 3 搭建github blogHexo 3.0 静态博客使用指南以上两篇文章应该能使你顺利的在http://localhost:4000/看到自己的新博客，并且你也熟悉了Hexo的常用命令。Hexo无法解析模板文件本地预览页面显示：&lt;%- partial(&apos;_partial/head&apos;) %&gt;&lt;%- partial(&apos;_partial/header&apos;) %&gt;&lt;%- body %&gt;&lt;% if (theme.sidebar &amp;&amp; theme.sidebar !== &apos;bottom&apos;)&#123; %&gt; &lt;%- partial(&apos;_partial/sidebar&apos;) %&gt; &lt;% &#125; %&gt;&lt;%- partial(&apos;_partial/footer&apos;) %&gt;&lt;%- partial(&apos;_partial/mobile-nav&apos;) %&gt; &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt;在工程目录执行下面3个命令，高版本的hexo移除默认的ejs。$ npm install hexo-renderer-ejs --save$ npm install hexo-renderer-stylus --save$ npm install hexo-renderer-marked --save上传到GitCafe注册GitCafe创建Page项目安装和设置 Git以上两篇内容结合着看，不过对第一次操作这些的人来说可能会遇到一些问题。生成SSH当命令窗口出现以下信息时，需要你输入passphrase口令。不过在我操作时输入口令的话是无法生成成功的，直接按enter即可。Enter passphrase (empty for no passphrase):设置git第一次在本地设置git时，需设置用户标识。$ git config --global user.name \"yourname\" # gitcafe上的用户名$ git config --global user.email \"yourmaill@yourmaili.com\" # 填写自己的邮箱设置本地gitcafe-pages版本库GitBash进入本地Hexo目录git checkout -b gitcafe-pages 创建Gitcafe-Pages分支，并切换到该分支。git add . （.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。上传到gitcafe修改hexo配置文件，即config.yml，如下配置：deploy: type: git repository: git@gitcafe.com:yourname/yourname.git branch: gitcafe-pagesyourname 修改成你的用户名，如我的是：git@gitcafe.com:justgo/justgo.git保存后直接在GitBash中hexo g &amp;&amp; hexo d上传即可（我在这一步折腾了很久，在cmd下运行hexo d命令会出错）。稍等片刻，打开 http://youname/gitcafe.io 便可以看到自己的博客了。WordPress文章迁移WordPress 后台可以直接导出wordpress.xml文件，把这个文件放入你的本地Hexo目录下，然后安装一个插件可以直接生成每篇文章的Markdown文件。npm install hexo-migrator-wordpress --save # 安装插件hexo migrate wordpress wordpress.xml # 生成Markdown生成后的文件稍微修改一下格式就可以上传了。庆幸的是我博客里的图片不多，不需要太多的链接修改。不过以后我也开始使用七牛存储了，免得以后搬迁麻烦。Hexo配置优化参考hexo博客的配置、使用hexo博客的优化技巧hexo博客的优化技巧续Hexo 优化与定制(一)Hexo 优化与定制(二)无法开启RSS和sitemap打开http://localhost:4000/atom.xml 页面显示 Cannot GET atom.xml，http://localhost:4000/sitemap.xml 页面显示 Cannot GET sitemap.xml。这个问题困扰了我很长的时间，因为我的插件安装和配置都是照着示例分毫不差的进行的，可是google了几个小时都没解决！插件也重装更新了几次，想过重新初始化Hexo，怕会丢失原来的一些配置，最后在 hexo/package.json 中找到了原因。package.json：&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"3.0.1\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-admin\": \"^0.3.0\", \"hexo-deployer-git\": \"0.0.4\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-generator-feed\": \"^1.0.1\", \"hexo-generator-sitemap\": \"^1.0.1\", \"hexo-migrator-wordpress\": \"^0.1.2\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-server\": \"^0.1.2\" &#125;&#125;检查此文件中是否包括了hexo-generator-tag和hexo-generator-sitemap，没有的话添加一下。插件版本号查看对应插件下的package.json文件，其他插件的类似问题应该也可以尝试这样解决。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"WordPress","slug":"WordPress","permalink":"http://imys.net/tags/WordPress/"},{"name":"Gitcafe","slug":"Gitcafe","permalink":"http://imys.net/tags/Gitcafe/"}]},{"title":"jQuery.proxy方法原理与使用","date":"2015-05-09T16:25:13.000Z","path":"20150510/jquery-proxy.html","text":"在写一些jq插件时，往往需要在回调函数上下文中注入调用者对象，也就是改变函数上下文中 this 的引用。从jQuery 1.4 开始便可以使用 jQuery.proxy 方法解决这个问题。定义和用法$.proxy 方法接受一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文指向不同对象的元素添加事件。提示：如果您绑定从 $.proxy 返回的函数，jQuery 仍然可以通过传递的原先的函数取消绑定正确的函数。语法// 1$(selector).proxy(function,context);// 2$(selector).proxy(context,name);实例// 用例1var obj1 = function()&#123; this.txt = \"helloWorld\"; $(document).click(this.fn);&#125;;var obj2 = function()&#123; this.txt = \"helloWorld\"; $(document).click($.proxy(this.fn, this));&#125;;obj1.prototype.fn = obj2.prototype.fn = function() &#123; console.log(this.txt);&#125;;var a = new obj1(); // undefinedvar b = new obj2(); // helloWorld// 用例2var dialog = &#123; msg: 'helloWorld', show: function () &#123; console.log(this); console.log(this.msg); &#125;&#125;$(document).click(dialog.show); // #document// undefined$(document).click($.proxy(dialog, \"show\")); // Object &#123;msg: \"helloWorld\", show: function&#125;// helloWorld未使用 jQuery.proxy 方法时，click 方法中 this 指向为执行 click 方法的 jQuery 对象；使用 jQuery.proxy 方法时，click 方法中 this 指向为你所期望的对象。原理不难猜出其底层实现应该是原生 js 中的 call 或 apply 方法。jquery1.9 中的源码片段：proxy: function( fn, context ) &#123; var args, proxy, tmp; if ( typeof context === \"string\" ) &#123; tmp = fn[ context ]; context = fn; fn = tmp; &#125; // Quick check to determine if target is callable, in the spec // this throws a TypeError, but we will just return undefined. if ( !jQuery.isFunction( fn ) ) &#123; return undefined; &#125; // Simulated bind args = core_slice.call( arguments, 2 ); proxy = function() &#123; return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) ); &#125;; // Set the guid of unique handler to the same of original handler, so it can be removed proxy.guid = fn.guid = fn.guid || jQuery.guid++; return proxy;&#125;","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://imys.net/tags/jQuery/"},{"name":"proxy","slug":"proxy","permalink":"http://imys.net/tags/proxy/"}]},{"title":"javascript中with语句用法","date":"2015-05-08T03:16:52.000Z","path":"20150508/javascript-with.html","text":"with 语句可以方便地用来引用某个特定对象中已有的属性或方法，但是不能用来给对象添加新的属性或方法。要给对象创建新的属性，必须明确地引用该对象。用法function Student()&#123; this.name = &apos;jeck&apos;; this.age = 20; this.gender = &apos;men&apos;;&#125;var stu = new Student();with(stu) &#123; console.log(&apos;姓名：&apos; + name + &apos;，性别：&apos; + gender + &apos;，年龄：&apos; + age); // 姓名：jeck，性别：men，年龄：20&#125;总结with 语句使代码更简洁、易读。由于 with 会根据目标对象产生一个新的可变对象，推入作用域链的头部，这样原有的可访问对象都被往后推了一个层次，这使得它们的访问代价更高了。因此对于 with 语句最好避免使用。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"with","slug":"with","permalink":"http://imys.net/tags/with/"}]},{"title":"图片上传本地预览jquery插件","date":"2015-05-07T10:11:00.000Z","path":"20150507/jqplugin-uploadpreview.html","text":"网上找到的一段代码，经过一番测试修改，兼容了IE7+、火狐、谷歌。并且扩展了多尺寸预览功能，可完美搭配 jquery.Jcrop 插件进行图像裁剪。插件代码(function($) &#123; jQuery.fn.extend(&#123; uploadPreview: function(opts) &#123; opts = jQuery.extend(&#123; width: null, height: null, imgDiv: \"#imgDiv\", anyTarget: null, maxSize: 300, imgType: [\"gif\", \"jpeg\", \"jpg\", \"bmp\", \"png\"], callback: function() &#123; return false; &#125; &#125;, opts || &#123;&#125;); var _this = $(this); var imgDiv = $(opts.imgDiv); opts.width &amp;amp;&amp;amp; imgDiv.width(opts.width); opts.height &amp;amp;&amp;amp; imgDiv.height(opts.height); var isIE = navigator.appName == 'Microsoft Internet Explorer', brVersion = navigator.appVersion, version; isIE &amp;amp;&amp;amp; (version = brVersion.split(';')[1].replace(/MSIE[ ]/g,'').replace('.0','')); handle = function() &#123; var img = imgDiv.find('img'); opts.anyTarget &amp;amp;&amp;amp; $.each(opts.anyTarget.split(','), function(index, val) &#123; $(val).html(img.clone()); &#125;); img.width(opts.width).height(opts.height); opts.callback(img); &#125;, createImg = function()&#123; imgDiv.html(''); var img = $(\"&lt;img /&gt;\"); imgDiv.append(img); return img; &#125;, _this.change(function() &#123; if (this.value) &#123; if (!RegExp(\"\\.(\" + opts.imgType.join(\"|\") + \")$\", \"i\").test(this.value.toLowerCase())) &#123; alert(\"图片类型必须是\" + opts.imgType.join(\"，\") + \"中的一种\"); this.value = \"\"; return false; &#125; if (isIE &amp;amp;&amp;amp; version &lt; 10) &#123; if (version == 6) &#123; var image = new Image(); image.onload = function()&#123; if( (image.fileSize/1024) &gt; opts.maxSize) &#123; alert('图片大小不能超过'+opts.maxSize+'K'); return false; &#125; &#125; image.src = 'file:///' + this.value; createImg().attr('src', image.src); handle(); &#125; else &#123; var img = document.selection.createRange().text || $(this).val(); var image = $('&lt;img /&gt;') image.load(function()&#123; if( (image.fileSize/1024) &gt; opts.maxSize) &#123; alert('图片大小不能超过'+opts.maxSize+'K'); return false; &#125; &#125;); image.attr('src', img); imgDiv.html(''); image.css(&#123; filter: \"progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod='scale',src='\"+img+\"')\" &#125;); imgDiv.append(image); setTimeout(handle, 100); &#125; &#125; else &#123; var img; try&#123; var file = null; var size = 0; if(this.files &amp;amp;&amp;amp; this.files[0] )&#123; file = this.files[0]; size = file.size; &#125;else if(this.files &amp;amp;&amp;amp; this.files.item(0)) &#123; file = this.files.item(0); size = file.fileSize; &#125; if((size/1024) &gt; opts.maxSize)&#123; alert('图片大小不能超过'+opts.maxSize+'K'); return false; &#125; img = createImg(); //Firefox 因安全性问题已无法直接通过input[file].value 获取完整的文件路径 try&#123; //Firefox7.0 以下 img.attr('src', file.getAsDataURL()); &#125;catch(e)&#123; //Firefox8.0以上 img.attr('src', window.URL.createObjectURL(file)); &#125; img.css(&#123; \"vertical-align\": \"middle\" &#125;); setTimeout(handle, 100); &#125;catch(e)&#123; //支持html5的浏览器,比如高版本的firefox、chrome、ie10 if (this.files &amp;amp;&amp;amp; this.files[0]) &#123; if((this.files[0].size/1024) &gt; opts.maxSize)&#123; alert('图片大小不能超过'+opts.maxSize+'K'); return false; &#125; var reader = new FileReader(); reader.onload = function (e) &#123; imgDiv.attr('src', e.target.result); &#125;; reader.readAsDataURL(this.files[0]); setTimeout(handle, 100); &#125; &#125;; &#125; &#125; &#125;); &#125; &#125;);&#125;)(jQuery);参数width: 图片容器宽度；height: 图片容器高度；imgDiv: 图片预览容器；anyTarget: 其他关联容器，多个容器逗号隔开；maxSize: 图片大小限制，单位KB；imgType: 图片类型限制；callback: 预览成功后的回调，参数 img(预览的图片节点，jquery类型)。实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;图片上传预览&lt;/title&gt;&lt;link href=\"http://cdn.bootcss.com/jquery-jcrop/0.9.12/css/jquery.Jcrop.css\" rel=\"stylesheet\"&gt;&lt;style type=\"text/css\"&gt; .fl &#123; float: left; &#125; .fr &#123; float: right; &#125; .logo-wrap &#123; overflow: hidden; margin: 30px 0; &#125; .logo-350, .logo-350 img &#123; width: 350px; height: 350px; &#125; .logo-350 &#123; margin-right: 30px; &#125; .logo-200, .logo-200 img &#123; width: 200px; height: 200px; &#125; .logo-200 &#123; margin-bottom: 30px; &#125; .logo-200-wrap &#123; width: 200px; &#125; .logo-100, .logo-100 img &#123; width: 100px; height: 100px; &#125; .logo-60, .logo-60 img &#123; width: 60px; height: 60px; &#125; .logo-350, .logo-200, .logo-100, .logo-60, .qrcode &#123; border: 1px solid #ddd; overflow: hidden; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"file\" value=\"上传文件\" id=\"file\"&gt; &lt;div class=\"logo-wrap\"&gt; &lt;div class=\"fl logo-350\"&gt;&lt;/div&gt; &lt;div class=\"fl logo-200-wrap\"&gt; &lt;div class=\"logo-200\"&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=\"fl logo-100\"&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"fr logo-60\"&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://ysdn-wordpress.stor.sinaapp.com/js/jquery.uploadPreview.js\"&gt;&lt;/script&gt;&lt;script src=\"http://cdn.bootcss.com/jquery-jcrop/0.9.12/js/jquery.Jcrop.min.js\"&gt;&lt;/script&gt;&lt;script&gt; //&lt;![CDATA[ $(\"#file\").uploadPreview(&#123; width: 350, height: 350, imgDiv: '.logo-350', anyTarget: '.logo-200 .content, .logo-100 .content, .logo-60 .content', maxSize: 1024 * 2, callback: function(el) &#123; var jOption = &#123; setSelect: [75, 75, 275, 275], minSize: [200, 200], onChange: updatePreview, onSelect: updatePreview, aspectRatio: 1 &#125;; var isIE = navigator.appName == 'Microsoft Internet Explorer', brVersion = navigator.appVersion, version; isIE &amp;amp;&amp;amp; (version = brVersion.split(';')[1].replace(/MSIE[ ]/g,'').replace('.0','')); if (isIE &amp;amp;&amp;amp; version &lt; 10) &#123; var api = $.Jcrop(el.selector, jOption); &#125; else &#123; el.Jcrop(jOption); &#125; &#125; &#125;); function updatePreview(c) &#123; if (parseInt(c.w) &gt; 0) &#123; $('.logo-200, .logo-100, .logo-60').each(function(index, el) &#123; var box = $(el), content = box.find('.content'), img = content.find('img'); content.width($('.logo-350').outerWidth()).height($('.logo-350').outerHeight()); var rx = box.width() / c.w; var ry = box.height() / c.h; img.css(&#123; width: Math.round(rx * 350) + 'px', height: Math.round(ry * 350) + 'px', marginLeft: '-' + Math.round(rx * c.x) + 'px', marginTop: '-' + Math.round(ry * c.y) + 'px' &#125;); &#125;); &#125; &#125;//]]&gt;&lt;/script&gt; &lt;/html&gt;","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://imys.net/tags/jQuery/"},{"name":"jQuery插件","slug":"jQuery插件","permalink":"http://imys.net/tags/jQuery插件/"}]},{"title":"javascript之arguments对象","date":"2015-04-29T03:55:20.000Z","path":"20150429/javascript-arguments.html","text":"在javascript中函数调用时，会自动在函数内产生一个arguments的隐藏对象。arguments类似于数组，但又不是数组。可以使用[]操作符获取函数调用时传递的实参。其类型function test1()&#123; console.log(typeof arguments); // object&#125;test1();其属性length：获取函数内传入实参个数。适用场景：模拟函数重载。function test2(a,b)&#123; console.log(arguments.length); // 获取函数内传入实参个数：4 console.log(test2.length); // 可以通过 函数名.length 获取形参个数：2&#125;test2(1, 'a', 5, 'gg');callee：引用当前正在执行的函数。适用场景：递归。// 求1到n的自然数之和function add(n)&#123; if(n == 1) return 1; else return n + arguments.callee(n-1);&#125;转换成真正的数组Array.prototype.slice.call(arguments)// 任意数量的一组数字排序function mySort(a,b,v) &#123; var tags = new Array(); tags = tags.concat(tags.slice.call(arguments)).sort(function(a, b)&#123; return a - b; &#125;); return tags;&#125;var result = mySort(50,11,16,32,24,99,57,100);console.log(result); // [11, 16, 24, 32, 50, 57, 99, 100]","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"},{"name":"arguments","slug":"arguments","permalink":"http://imys.net/tags/arguments/"}]},{"title":"jQuery扩展 - 延迟执行hover事件","date":"2015-04-28T09:15:57.000Z","path":"20150428/jquery-delayHover.html","text":"适用场景如：鼠标随便一滑，无数个下拉菜单出来了，用户可能只是鼠标“打个酱油”罢了。实现很简单，就是使用setTimeout延迟事件代码的执行。(function($)&#123; function DelayHover(options) &#123; var defaults = &#123; speed : 400, // 延迟时间(毫秒) onHover : function(el) &#123;&#125;, // 鼠标悬浮 onOut : function(el)&#123;&#125; // 鼠标离开 &#125;; this.settings = $.extend(&#123;&#125;, defaults, options); var _this = this, hoverTimer; _this.bind = function () &#123; $(_this).hover(function() &#123; hoverTimer = setTimeout(function()&#123; _this.settings.onHover(_this); &#125;, _this.settings.speed); &#125;, function() &#123; clearTimeout(hoverTimer); _this.settings.onOut(_this); &#125;); &#125;; &#125; $.fn.delayHover = function(options) &#123; return this.each(function() &#123; DelayHover.call(this,options); this.bind(); &#125;); &#125;&#125;)(jQuery);","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://imys.net/tags/jQuery/"},{"name":"jQuery插件","slug":"jQuery插件","permalink":"http://imys.net/tags/jQuery插件/"}]},{"title":"使用css3后代选择器实现多背景色标签样式","date":"2015-04-25T19:09:06.000Z","path":"20150426/css3-selector-multiple-color.html","text":"使用css3后代选择器实现多背景色标签样式css3增加了许多新的选择器，包括属性选择器、后代选择器和伪类选择器等，灵活运用可以做出很多出彩的效果。在一些博客站点上经常会见到一些多背景色的标签样式，颜色固定为几种，按顺序循环呈现。使用js迭代并添加不同的样式固然可行，不过css3为我们提供了更便捷的方法–后代选择器。:nth-of-type(n)匹配同类型中的第n个同级兄弟元素。n可以是一个数字，一个关键字，或者一个公式。实现这次的需求要使用公式代入的方式，nth-of-type(an+b)。a代表一个循环的大小，N是一个计数器（从0开始），以及b是偏移量。假设我们需要4种标签颜色，就需要设置4个公式型的后代选择器，那么可以想到的第一个公式为4n+0，选取索引为4的倍数的元素。于是就可以推出剩余的3个公式为4n-1、4n-2、4n-3。实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;使用css3子级选择器实现多颜色标签样式&lt;/title&gt;&lt;style type=\"text/css\"&gt; html &#123; background: #333; &#125; .tags &#123; width: 240px; margin: 150px auto; padding: 10px; background: #ddd; &#125; .tags&gt;a &#123; display: inline-block; text-decoration: none; color: #fff; padding: 5px 10px; margin: 0 5px 5px 0; border-radius: 3px; transition: all .5s; -webkit-transition: all .5s; &#125; .tags&gt;a:hover &#123; background: #666 !important; &#125; .tags&gt;a:nth-of-type(4n+0) &#123; background: #337AB7; &#125; .tags&gt;a:nth-of-type(4n-1) &#123; background: #5CB85C; &#125; .tags&gt;a:nth-of-type(4n-2) &#123; background: #5BC0DE; &#125; .tags&gt;a:nth-of-type(4n-3) &#123; background: #F0AD4E; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tags\"&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"},{"name":"selector","slug":"selector","permalink":"http://imys.net/tags/selector/"}]},{"title":"使用逻辑运算符 || && 简化javascript中if else选择结构","date":"2015-04-24T03:49:30.000Z","path":"20150424/js-simple-condition.html","text":"|| 和 &amp;&amp; 通常使用在条件表达式中，但是由于javascript语言的特殊性，这两个符号又被开发出了特别的使用技巧。最基本的用法console.log(true &amp;&amp; true); // trueconsole.log(true &amp;&amp; false); // falseconsole.log(false &amp;&amp; true); // falseconsole.log(false &amp;&amp; false); // falseconsole.log(true || true); // trueconsole.log(true || false); // trueconsole.log(false || true); // trueconsole.log(false || false); // false这是所有的编程语音通用的使用方法，毋庸置疑。javascript中可以这么用var target, num;target = undefined || 'defaultValue'; // defaultValuenum = 0 || 1; // 1你可以看成这样：var target;target = false || 'defaultValue'; // defaultValuenum = false || 1; // 1因为在javascript中Object、function、非0的整数和字符串都为true，undefined、null和空字符串”” 为false。但是javascript中却可以返回为true表达式的值，应该理解为“真值”和“假值”更贴切。‘||’在javascript中的规则：如果||左侧表达式的值为真值，则返回左侧表达式的值；否则返回右侧表达式的值。console.log('真值'||''); // 真值console.log(undefined||object); // object‘&amp;&amp;’在javascript中的规则：如果&amp;&amp;左侧表达式的值为真值，则返回右侧表达式的值；否则返回左侧表达式的值。console.log(1 === 1 &amp;&amp; 2) // 2console.log(0 === 1 &amp;&amp; 2) // false于是有了高逼格的javascript代码var n=1;((n === 1) &amp;&amp; (n = 3)) || ((n === 3) &amp;&amp; (n = 6)) || (n = 2); // 3((n === 1) &amp;&amp; (n = 3)) || ((n === 3) &amp;&amp; (n = 6)) || (n = 2); // 6((n === 1) &amp;&amp; (n = 3)) || ((n === 3) &amp;&amp; (n = 6)) || (n = 2); // 2//以上代码等价于if(n === 1) &#123; n = 3;&#125; else if(n === 3) &#123; n = 6;&#125; else &#123; n = 2;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"}]},{"title":"css3导航按钮图标样式切换效果","date":"2015-04-20T05:29:44.000Z","path":"20150420/css3-menu-style.html","text":"纯css实现的导航按钮图标样式切换效果，图标样式是css画出来的，再辅以css3动画效果。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;css3效果切换的导航按钮&lt;/title&gt;&lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; background: #3B9DFF; &#125; .menuCtrl &#123; display: block; position: relative; border: 5px solid #fff; border-radius: 50%; width: 30px; height: 40px; padding: 20px 25px; margin: 150px auto; transition: all 0.25s ease-in-out; &#125; .menuCtrl .line &#123; width: 35px; height: 0; border-bottom: 5px solid #fff; position: relative; margin-left: -2px; transition: all 0.25s ease-in-out; &#125; .menuCtrl .line:nth-child(1) &#123; top: 10px; &#125; .menuCtrl .line:nth-child(2) &#123; top: 13px; &#125; .menuCtrl .line:nth-child(3) &#123; top: 16px; &#125; .menuCtrl:hover &#123; padding: 25px 30px; &#125; .menuCtrl:hover .line:nth-child(1) &#123; width: 20px; transform: rotateZ(-45deg) translateX(-3px) translateY(0px); &#125; .menuCtrl:hover .line:nth-child(2) &#123; width: 40px; &#125; .menuCtrl:hover .line:nth-child(3) &#123; width: 20px; transform: rotateZ(45deg) translateX(-3px) translateY(0px); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"javascript:;\" class=\"menuCtrl\"&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://imys.net/tags/CSS3/"}]},{"title":"不链接页面在新窗口或标签页运行代码","date":"2015-04-15T01:58:21.000Z","path":"20150415/online-run-code.html","text":"在一些IT博客或者论坛都有在新窗口或标签页直接运行当前页面内代码的功能，但却不是像一些资源网站里的直接预览资源页面。这样动态的运行代码，无疑是节省了很大服务器空间。前端网（W3Cfuns）就有这样的功能，用户可以直接运行博主笔记内的代码，问答论坛也一样。查看了一下代码实现，原来是window.open()方法。语法重温window.open(URL,name,features,replace)URL 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。name 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 &lt;a&gt; 和 &lt;form&gt; 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。features 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。replace 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。参数1URL省略会打开一个空白页，也就是about:blank页。不过window.open()方法居然是有返回值的，可以返回新页面的window对象。如此的话，我们就能访问新页面的DOM，自然就可以写入代码了。实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;新窗口或标签页运行代码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea style=\"width:600px;height:150px;\" id=\"code\"&gt; &lt;script type=\"text/javascript\"&gt; document.write(\"&lt;h1&gt;我是运行在新窗口或标签页的代码。&lt;/h1&gt;\"); &lt;/script&gt;&lt;/textarea&gt;&lt;br&gt;&lt;button onclick=\"runCode()\"&gt;运行代码&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; function runCode() &#123; var example = window.open('','',''); var code = document.getElementById('code').value; example.document.write(code) example.focus(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"}]},{"title":"js文本复制全兼容实例","date":"2015-04-14T06:00:45.000Z","path":"20150414/js-copytext.html","text":"对于文本复制本来就是右键-&gt;复制，或者Ctrl+C，很简单的事情。不过为了提升用户体验，就让我们找一个兼容性强的万全之策吧。纯JS实现的方式不能兼容到现代浏览器，看了Discuz和bootstrap上代码复制的实现，发现都是借用Flash来实现的。原理Flash可以操作剪贴板，用一个透明的Flash覆盖到一个DOM元素上。点击DOM实际是点击了Flash，从而操作剪贴板。需要用到一个JavaScript库：Zero Clipboard，和一个Flash文件。另外要注意：页面必须在放到服务器上，本地没有Flash权限。代码实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;JS文本复制&lt;/title&gt;&lt;style type=\"text/css\"&gt; .box &#123; width: 610px; margin: 50px auto; position: relative; &#125; textarea &#123; width: 600px; height: 150px; padding: 5px; resize: none; border: 1px solid #ddd; outline: none; &#125; #copy-btn &#123; padding: 5px 8px; background: #F7F7F9; border: 1px solid #ddd; border-radius: 4px 0 0 0; position: absolute; right: -2px; margin-top: -30px; &#125; #clip-btn &#123; width: 80px; height: 40px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;h3&gt;JS文本复制实例&lt;/h3&gt; &lt;textarea placeholder=\"复制的内容区\" id=\"content\"&gt;&lt;/textarea&gt; &lt;button id=\"copy-btn\"&gt;点击复制&lt;/button&gt; &lt;/div&gt; &lt;div id=\"clip-btn\"&gt;&lt;/div&gt;&lt;script src=\"ZeroClipboard.js\"&gt;&lt;/script&gt; &lt;script&gt; var clip = null; // 设置Flash文件路径 ZeroClipboard.setMoviePath(\"ZeroClipboard.swf\"); function copyCode(text) &#123; clip = new ZeroClipboard.Client(); // 设置鼠标悬浮样式 clip.setHandCursor(true); // 点击复制 clip.addEventListener('mouseOver', function() &#123; clip.setText(text); &#125;); // 复制完成回调 clip.addEventListener( \"complete\", function()&#123; alert(\"复制成功！\"); clip.destroy(); //释放 &#125;); // Flash加载的目标容器 clip.glue('clip-btn'); &#125; /* js实现 */ function $(id) &#123; return document.getElementById(id); &#125; $('copy-btn').onmouseover = function(e) &#123; var clipBtn = $('clip-btn'); clipBtn.style.position = 'absolute'; clipBtn.style.left = (e.clientX -55 )+'px'; clipBtn.style.top = (e.clientY - 35)+'px'; copyCode($('content').value); &#125;; /*jQuery实现*/ // $('#copy-btn').mouseover(function() &#123; // var t = $(this); // var cobyText = t.prev().val(); // $('#clip-btn').css(&#123; // position: 'absolute', // left: t.offset().left, // top: t.offset().top, // zIndex: 999 // &#125;).mouseleave(function() &#123; // clip.destroy(); // &#125;); // copyCode(cobyText); // &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;参考文章：兼容主流浏览器的JS复制内容到剪贴板&#160;&#8617;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://imys.net/tags/JavaScript/"}]},{"title":"CSS巧用border画小图形","date":"2015-04-09T13:26:50.000Z","path":"20150409/css-borde-shape.html","text":"CSS巧用border画小图形css画三角形样式相信很多人都用过，比如 border-bottom设置宽度、颜色、实线，其他方向设置宽度和透明色就出现一个朝上的正三角形。今天在看了 zyp199737 的笔记css3巧用border做翻页效果中一张图，突然想到设置2个方向是什么样式？是不是就是直角三角形呢？做了下实验，发现不止可以画出直角三角形，而且还有书签的样式。代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;triangle&lt;/title&gt;&lt;style type=\"text/css\"&gt; .shape &#123; float: left; margin-left: 50px; width:0; height:0; border-width: 30px; border-style: dashed dashed dashed dashed ; border-color: transparent transparent transparent transparent ; &#125; /*三角形*/ .triangle &#123; border-bottom: 30px solid #e66161; &#125; /*标签*/ .mark &#123; border-left: 30px solid #e66161; border-top: 30px solid #e66161; border-right: 30px solid #e66161; &#125; /*直角三角形*/ .right-triangle &#123; border-left: 30px solid #e66161; border-bottom: 30px solid #e66161; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"shape triangle\"&gt;&lt;/div&gt; &lt;div class=\"shape mark\"&gt;&lt;/div&gt; &lt;div class=\"shape right-triangle\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://imys.net/tags/CSS/"},{"name":"border","slug":"border","permalink":"http://imys.net/tags/border/"}]},{"title":"jQuery实现通用的单页面锚点平滑滚动","date":"2015-04-07T05:45:03.000Z","path":"20150407/jquery-anchor-scroll.html","text":"很多商品展示页，专题页等都会用到。代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;锚链接平滑滚动&lt;/title&gt;&lt;meta name=\"description\" content=\"\"&gt;&lt;meta name=\"keywords\" content=\"\"&gt;&lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0 &#125; html,body &#123; height: 100%; min-height: 100%; &#125; .top &#123; width: 100%; height: 40px; line-height: 40px; background: rgba(0, 0, 0, .6); position: fixed; z-index: 9; &#125; a &#123; color: #fff; text-align: center; text-decoration: none; &#125; .top a &#123; display: inline-block; width: 20%; &#125; .top a:hover &#123; background: rgba(0, 0, 0, .4); &#125; .page &#123; width: 100%; height: 100%; min-height: 100%; background: #3C98FF; text-align: center; &#125; h1 &#123; color: #fff; padding-top: 20%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"top\"&gt; &lt;a href=\"#div-1\"&gt;div-1&lt;/a&gt; &lt;a href=\"#div-2\"&gt;div-2&lt;/a&gt; &lt;a href=\"#div-3\"&gt;div-3&lt;/a&gt; &lt;a href=\"#div-4\"&gt;div-4&lt;/a&gt; &lt;/div&gt; &lt;div id=\"div-1\" class=\"page\"&gt; &lt;h1&gt;第一页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-2\" class=\"page\"&gt; &lt;h1&gt;第二页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-3\" class=\"page\"&gt; &lt;h1&gt;第三页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-4\" class=\"page\"&gt; &lt;h1&gt;第四页&lt;/h1&gt; &lt;/div&gt;&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $('a[href*=#]').click(function(event) &#123; // 此处正则用于转换带页面URL的锚点，如 http://abc.html#div,具体正则格式据实际情况而定 var targetId = $(this).attr('href').replace(/\\w+.html/,''); $(\"html,body\").animate(&#123;scrollTop: $(targetId).offset().top&#125;, 1000); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://imys.net/tags/jQuery/"}]}]