{"title":"Vuex与前端缓存的整合策略","slug":"vuex-cache-design","date":"2017-03-18T03:39:54.000Z","updated":"2017-04-16T07:03:00.368Z","comments":true,"path":"api/articles/vuex-cache-design.json","excerpt":"<h2 id=\"如何存放或更新缓存？\"><a href=\"#如何存放或更新缓存？\" class=\"headerlink\" title=\"如何存放或更新缓存？\"></a>如何存放或更新缓存？</h2><p>缓存数据来源是预知的，我们可以预先定义哪些 <code>mutation</code> 是缓存相关的。</p><p>我们期望这个过程更自然一点，通过某种变化自动映射，使以后不管缓存类别增加还是减少都能修改极少的代码来应对变化。</p><p>Vuex的插件可以拦截 <code>mutations</code>，借助这个机制，我们可以制定一种策略化的规则。<br>","content":"<h2 id=\"如何存放或更新缓存？\"><a href=\"#如何存放或更新缓存？\" class=\"headerlink\" title=\"如何存放或更新缓存？\"></a>如何存放或更新缓存？</h2><p>缓存数据来源是预知的，我们可以预先定义哪些 <code>mutation</code> 是缓存相关的。</p><p>我们期望这个过程更自然一点，通过某种变化自动映射，使以后不管缓存类别增加还是减少都能修改极少的代码来应对变化。</p><p>Vuex的插件可以拦截 <code>mutations</code>，借助这个机制，我们可以制定一种策略化的规则。<br><a id=\"more\"></a></p><p>可以规定，所有需要更新缓存的 <code>mutationType</code> 都要符合这种格式：<code>module-type-cacheKey</code>，非缓存的 <code>mutationType</code> 格式为 <code>module-type</code>。</p><p>那么就可以拦截 <code>mutation</code>，去做我们想做的事了：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">store.subscribe(<span class=\"function\">(<span class=\"params\">&#123; type, payload &#125;</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheKey = type.split(<span class=\"string\">'-'</span>)[<span class=\"number\">2</span>]</div><div class=\"line\">    <span class=\"keyword\">if</span> (cacheKey) &#123;</div><div class=\"line\">        Cache.save(cacheKey, payload)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><h2 id=\"如何从缓存取数据避免请求？\"><a href=\"#如何从缓存取数据避免请求？\" class=\"headerlink\" title=\"如何从缓存取数据避免请求？\"></a>如何从缓存取数据避免请求？</h2><p>只需要在缓存相关的 <code>action</code> 中加入缓存判断。</p><figure class=\"highlight js\"><figcaption><span>action</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\">fetchData(&#123;commit&#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheData = Cache.get(cacheKey)</div><div class=\"line\">    <span class=\"keyword\">if</span>(!cacheData) &#123;</div><div class=\"line\">        Api.getData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">            commit(mutationType, data)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        commit(mutationType, cacheData)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><h2 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h2><p>以上的确已经足够完成缓存 <code>读取 --&gt; 更新</code> 的工作了。但试想一下将来某个其他数据类别要做缓存，我们就要把上面的代码格式再搬一遍。</p><p>即：把新的需要缓存的数据类别对应的 <code>mutationType</code> 加 <code>cacheKey</code> 后缀，把获取数据的 <code>action</code> 中加缓存判断。</p><p>虽然实际编码中也没有多大的工作量，但感觉还不是最好的开发体验。</p><h3 id=\"action优化\"><a href=\"#action优化\" class=\"headerlink\" title=\"action优化\"></a>action优化</h3><p><code>action</code> 中的痛点是：每次都需要重复写缓存判断。可以把这个判断过程拿出来放到一个大家都能访问到的公共的地方，且最好是与 Vuex 契合的。</p><p>Vuex 支持 <code>action</code> 相互调用，我们可以设置一个单独的 <code>action</code> 用来提交。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">commitAction(&#123; commit &#125;, mutationType, getData) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheKey = mutationType.split(<span class=\"string\">'-'</span>)[<span class=\"number\">2</span>]</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheData = Cache.get(cacheKey || <span class=\"string\">''</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span>(!cacheData) &#123;</div><div class=\"line\">        getData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">            commit(mutationType, data)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        commit(mutationType, cacheData)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">fetchData(&#123; dispatch &#125;) &#123;</div><div class=\"line\">    dispatch(<span class=\"string\">'commitAction'</span>, mutationType, Api.getData)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>不管是否需要缓存最终都走同一个 <code>action</code> 去提交，由这个 <code>action</code> 去做决策。</p><h3 id=\"mutation优化\"><a href=\"#mutation优化\" class=\"headerlink\" title=\"mutation优化\"></a>mutation优化</h3><p><code>mutation</code> 的痛点在于：加后缀啊！加后缀啊！！</p><p>如果一个数据的相关逻辑复杂，可能对应很多个 <code>mutationType</code>，每个都需要：加后缀！</p><p>要是代码能<strong>自动识别需要走缓存的 <code>mutationType</code></strong> 就完美了！</p><p><code>mutationType</code> 默认的格式为 <code>module-type</code>，假如业务中一个 <code>module</code> 对应一个数据类别，我们就可以基于 <code>module</code> 作缓存识别。</p><figure class=\"highlight js\"><figcaption><span>cacheConfig.js</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    <span class=\"attr\">module1</span>: <span class=\"string\">'key1'</span>,</div><div class=\"line\">    <span class=\"attr\">module2</span>: <span class=\"string\">'key2'</span>,</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><figcaption><span>action</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\">commitAction(&#123; commit &#125;, mutationType, getData) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = mutationType.split(<span class=\"string\">'-'</span>)[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheKey = CacheConfig[<span class=\"built_in\">module</span>] || <span class=\"string\">''</span></div><div class=\"line\">    <span class=\"keyword\">const</span> cacheData = Cache.get(cacheKey)</div><div class=\"line\">    <span class=\"keyword\">if</span>(!cacheData) &#123;</div><div class=\"line\">        getData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</div><div class=\"line\">            commit(mutationType, data)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        commit(mutationType, cacheData)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">fetchData(&#123; dispatch &#125;) &#123;</div><div class=\"line\">    dispatch(<span class=\"string\">'commitAction'</span>, mutationType, Api.getData)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><figure class=\"highlight js\"><figcaption><span>interceptor</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\">store.subscribe(<span class=\"function\">(<span class=\"params\">&#123; type, payload &#125;</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = type.split(<span class=\"string\">'-'</span>)[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">const</span> cacheKey = CacheConfig[<span class=\"built_in\">module</span>]</div><div class=\"line\">    <span class=\"keyword\">if</span> (cacheKey) &#123;</div><div class=\"line\">        Cache.save(cacheKey, payload)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>当我们需要新增或减少缓存数据，只需要去 <code>cacheConfig</code> 中增加或减少一项模块配置。</p>","categories":[],"tags":[{"name":"Vue","path":"api/tags/Vue.json"},{"name":"Vuex","path":"api/tags/Vuex.json"},{"name":"Cache","path":"api/tags/Cache.json"}]}