{"title":"基于 MIME 类型的服务端推送","slug":"multipart-x-mixed-replace","date":"2018-07-03T15:12:03.000Z","updated":"2018-07-03T15:24:41.764Z","comments":true,"path":"api/articles/multipart-x-mixed-replace.json","excerpt":"<p>目前就职于视听行业相关的公司，故而需要接触流媒体传输相关技术。</p><p>今天介绍一种基于 MIME 类型的服务端流媒体推送实现。</p>","content":"<p>目前就职于视听行业相关的公司，故而需要接触流媒体传输相关技术。</p><p>今天介绍一种基于 MIME 类型的服务端流媒体推送实现。</p><a id=\"more\"></a><h2 id=\"multipart\"><a href=\"#multipart\" class=\"headerlink\" title=\"multipart\"></a>multipart</h2><p>MIME 类型由类型和子类型组成：<code>Content-Type: [type]/[subType]</code>，前者是数据大类别，后者是具体的种类。</p><p><code>multipart</code> 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据。也就是一个消息可以包含多个消息体。</p><p>我们常见的一般是表单相关的 <code>multipart/form-data</code>，当我们需要在提交表单时上传文件，就需要设置这个类型。<br>电子邮件中使用的类型是 <code>multipart/alternative</code>，包含纯文本（text/plain）和 HTML（text/html）两种数据。<br>其他相关的可以看看 <a href=\"https://en.wikipedia.org/wiki/MIME#Content-Type\" target=\"_blank\" rel=\"external\">维基百科 MIME#Content-Type</a></p><h2 id=\"x-mixed-replace\"><a href=\"#x-mixed-replace\" class=\"headerlink\" title=\"x-mixed-replace\"></a>x-mixed-replace</h2><p><code>multipart/x-mixed-replace</code> 是 Netscape 在 1995 年引入的。与其他的 multipart 子类型相比，新的消息体会覆盖前一个消息体，而不是累加。</p><p>报文格式如：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Content-type: multipart/x-mixed-replace; boundary=--myBoundary</div><div class=\"line\">--myBoundary</div><div class=\"line\">Content-Type: image/png</div><div class=\"line\">Content-length: 100</div><div class=\"line\">stream1...</div><div class=\"line\"></div><div class=\"line\">--myBoundary</div><div class=\"line\">Content-Type: image/png</div><div class=\"line\">Content-length: 100</div><div class=\"line\">stream2...</div><div class=\"line\"></div><div class=\"line\">--myBoundary</div></pre></td></tr></table></figure><p><code>boundary</code> 用来指定一个边界符，用于分割多个消息体，多个消息体之间隔一行。可以指定为任意字符，但为了避免消息体中包含了该字符，尽量复杂一些。</p><p>要实现服务器推送，就是不发送完整的报文，始终发送新的消息体。这样会使 HTTP 连接得到保持，服务器就可以按一定的频率持续推送数据。</p><p>而 <code>multipart/x-mixed-replace</code> 类型的报文是没有结尾的，一旦客户端连接，将可以永远保持连接。</p><p>客户端的运行策略为：客户端连接后，获取到第一段消息体并显示。之后发现下一段消息体的边界符，就认为第一段消息体已结束，开始显示第二段消息体的内容。往复替换，自动更新。</p><h2 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h2><p>一个不超过 20 行的 NodeJS Demo：<a href=\"https://github.com/yscoder/multipart-x-mixed-replace-example\" target=\"_blank\" rel=\"external\">yscoder/multipart-x-mixed-replace-example</a>。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> server = http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</div><div class=\"line\">    res.writeHead(<span class=\"number\">200</span>, &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'multipart/x-mixed-replace; boundary=--test'</span> &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendData</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> content = fs.readFileSync(<span class=\"string\">`./imgs/run<span class=\"subst\">$&#123;i&#125;</span>.png`</span>)</div><div class=\"line\">        res.write(<span class=\"string\">`--test\\nContent-Type: image/png\\nContent-length: <span class=\"subst\">$&#123;content.length&#125;</span>\\n\\n`</span>)</div><div class=\"line\">        res.write(content)</div><div class=\"line\">        i = i === <span class=\"number\">20</span> ? <span class=\"number\">1</span> : i + <span class=\"number\">1</span></div><div class=\"line\">        setTimeout(sendData, <span class=\"number\">50</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    setTimeout(sendData, <span class=\"number\">50</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">server.listen(<span class=\"number\">8090</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running!'</span>)</div></pre></td></tr></table></figure><p>网上找了一组包含 20 张图片的人物帧序列图，逐个发送到客户端。浏览器打开本地端口地址后可以看到动画的效果。</p><p>实际运用中一般是连接媒体视频设备获取媒体流然后向客户端发送。客户端只需要使用 <code>img</code> 标签引用接口就可以持续接收到推送数据，监听 <code>onload</code> 事件把每次推送的数据绘制到 <code>canvas</code> 上。</p>","categories":[],"tags":[{"name":"Server Push","path":"api/tags/Server Push.json"},{"name":"MIME","path":"api/tags/MIME.json"},{"name":"multipart","path":"api/tags/multipart.json"},{"name":"x-mixed-replace","path":"api/tags/x-mixed-replace.json"}]}