{"title":"canvas实践--图表组件仪表盘、雷达图","slug":"canvas-chart-demo","date":"2015-07-31T01:14:34.000Z","updated":"2017-08-20T13:57:23.703Z","comments":true,"path":"api/articles/canvas-chart-demo.json","excerpt":"<p>大数据概念的到来，图表的运用越来越广泛，不搞搞数据，都不好意思说是互联网公司。</p><p>最近公司又有一块图表展示的栏目要做，由于之前的图表栏目都是我完成的，这次不出意料又落在我身上。<br>之前的图表展示我用的是<code>echarts</code>，按格式封装数据调用就行了。<br>这次领导突然对图表样式有了一些要求，虽然<code>echarts</code>的配置够OP，也不可能完完全全跟设计图搞成一样的。</p><p>暨于上次的<code>canvas</code>的使用，我决定自己动手实现所需要的图表组件。<br>这是最终的完成样式：</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/canvas-chart.jpg\" alt=\"canvas实践--图表组件仪表盘、雷达图\"></div><div class=\"image-caption\">canvas实践--图表组件仪表盘、雷达图</div></figure>","content":"<p>大数据概念的到来，图表的运用越来越广泛，不搞搞数据，都不好意思说是互联网公司。</p><p>最近公司又有一块图表展示的栏目要做，由于之前的图表栏目都是我完成的，这次不出意料又落在我身上。<br>之前的图表展示我用的是<code>echarts</code>，按格式封装数据调用就行了。<br>这次领导突然对图表样式有了一些要求，虽然<code>echarts</code>的配置够OP，也不可能完完全全跟设计图搞成一样的。</p><p>暨于上次的<code>canvas</code>的使用，我决定自己动手实现所需要的图表组件。<br>这是最终的完成样式：</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/canvas-chart.jpg\" alt=\"canvas实践--图表组件仪表盘、雷达图\"></div><div class=\"image-caption\">canvas实践--图表组件仪表盘、雷达图</div></figure><a id=\"more\"></a><p>首先根据效果图来划分出各个图层，以及图层层级位置。<br>然后按照层级关系由下向上依次绘制。</p><p>整个编码过程还是很顺利的，一些问题都得到了很好的解决。</p><p><a href=\"https://github.com/yscoder/canvas-chart\" target=\"_blank\" rel=\"external\">查看github</a></p><h2 id=\"踩过的坎\"><a href=\"#踩过的坎\" class=\"headerlink\" title=\"踩过的坎\"></a>踩过的坎</h2><h3 id=\"确定圆上任意一点的位置\"><a href=\"#确定圆上任意一点的位置\" class=\"headerlink\" title=\"确定圆上任意一点的位置\"></a>确定圆上任意一点的位置</h3><p>此次绘制的图表分别是仪表盘和雷达图，很多图形或点的位置都需要进行一定的计算。比如仪表盘上的指针坐标、雷达图各个角的位置等。<br>而两个图表都是基于圆心角绘制的图形，所以可以使用 <strong>圆的参数方程</strong> 来轻松解决。</p><p><em>x = cx + r &times; cos(π &times; e)</em><br><em>y = cy + r &times; sin(π &times; e)</em></p><ol><li>cx: 圆心点横坐标</li><li>r: 半径</li><li>e: 结束角</li><li>cy: 圆心点纵坐标</li></ol><h3 id=\"绘制渐变色圆环\"><a href=\"#绘制渐变色圆环\" class=\"headerlink\" title=\"绘制渐变色圆环\"></a>绘制渐变色圆环</h3><p>原本看到仪表盘样式图时，预想的这个渐变圆环需要一节一节用不同的颜色画上去的。<br>实际的实现要简单太多了！可以直接使用绘制渐变色的方法。<br><code>canvas</code>支持线性渐变和放射形渐变，这里使用的是线性渐变。</p><table><thead><tr><th>方法</th><th style=\"text-align:center\">描述</th></tr></thead><tbody><tr><td>createLinearGradient(x0, y0, x1, y1)</td><td style=\"text-align:center\">创建线性渐变，参数分别表示起始点x坐标和y坐标、结束点x坐标和y坐标。</td></tr><tr><td>addColorStop(stop, color)</td><td style=\"text-align:center\">规定渐变对象中的颜色和停止位置，stop表示一个颜色的渐变结束位置0-1之间，color表示渐变色。</td></tr></tbody></table><p>具体的使用可以<a href=\"http://www.runoob.com/tags/canvas-addcolorstop.html\" target=\"_blank\" rel=\"external\">点这里</a>。</p><p>顺便说说如何根据设计图确定渐变的位置和颜色。</p><ol><li>用ps打开美工给的psd文件；</li><li>找到渐变的图层样式设置；</li><li>照着上面的设置来就行了。</li></ol><h3 id=\"绘制虚线\"><a href=\"#绘制虚线\" class=\"headerlink\" title=\"绘制虚线\"></a>绘制虚线</h3><p>HTML5规范中已有绘制虚线的方法，支持的浏览器有Chrome, Safari, IE 11 和 Opera。</p><p><code>context.setLineDash()</code></p><p><a href=\"http://www.rgraph.net/blog/2013/january/html5-canvas-dashed-lines.html\" target=\"_blank\" rel=\"external\">使用参考</a></p><h3 id=\"开场动画\"><a href=\"#开场动画\" class=\"headerlink\" title=\"开场动画\"></a>开场动画</h3><p><code>canvas</code>本身没有这方面的支持，需要使用定时器来进行一定时间的重绘来实现。</p><p>整个逻辑大概是这样的：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1. 设置最小初始值，获取最终值</span></div><div class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">0</span>,</div><div class=\"line\">    endValue = <span class=\"number\">668</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. 启动定时器根据value动态绘制</span></div><div class=\"line\"><span class=\"keyword\">var</span> timer = setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 3. value累加，如果小于最终值就加一定值，否则等于最终值</span></div><div class=\"line\">  value = value + <span class=\"number\">1</span> &gt; endValue ? endValue :  value + <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 4. 清空画布</span></div><div class=\"line\">  context.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">500</span>, <span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 5. 根据value来进行此次绘制</span></div><div class=\"line\">  <span class=\"comment\">// 具体步骤省略...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 6. 判断value是否等于最终值来结束定时器</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(value === endValue) &#123;</div><div class=\"line\">    clearInterval(timer);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;, <span class=\"number\">10</span>);</div></pre></td></tr></table></figure><p>可以通过调整累加数和定时器时间来控制动画速度。</p><h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>说起来这两个组件的封装和调用也是凭着<code>echarts</code>的使用经验来设定的，感谢百度前端大大们为此作出的贡献！</p>","categories":[],"tags":[{"name":"Html5","path":"api/tags/Html5.json"},{"name":"Canvas","path":"api/tags/Canvas.json"},{"name":"Chart","path":"api/tags/Chart.json"}]}