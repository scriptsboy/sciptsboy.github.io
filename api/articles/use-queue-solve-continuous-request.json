{"title":"使用“队列”解决“插队”业务场景","slug":"use-queue-solve-continuous-request","date":"2016-10-27T09:21:23.000Z","updated":"2016-11-12T19:39:34.539Z","comments":true,"path":"api/articles/use-queue-solve-continuous-request.json","excerpt":"<p>为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。<br>但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。<br>理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。</p><p>我觉得用“插队”来描述这个场景真是再好不过了。<br>","content":"<p>为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。<br>但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。<br>理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。</p><p>我觉得用“插队”来描述这个场景真是再好不过了。<br><a id=\"more\"></a></p><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>既然有人要“插队”，我们就要定义一个规则：<strong>先进先出</strong>。<br>也就是数据结构中的“队列”了。</p><p>javascript 中队列的实现：</p><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 实现1</span></div><div class=\"line\"><span class=\"keyword\">var</span> queue = []</div><div class=\"line\"><span class=\"comment\">// 进队</span></div><div class=\"line\">queue.push(<span class=\"number\">1</span>)</div><div class=\"line\">queue.push(<span class=\"number\">2</span>)</div><div class=\"line\">queue.push(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// 出队</span></div><div class=\"line\">queue.shift() <span class=\"comment\">// 1</span></div><div class=\"line\">queue.shift() <span class=\"comment\">// 2</span></div><div class=\"line\">queue.shift() <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 实现2</span></div><div class=\"line\"><span class=\"keyword\">var</span> queue2 = []</div><div class=\"line\"><span class=\"comment\">// 进队</span></div><div class=\"line\">queue2.unshift(<span class=\"number\">1</span>)</div><div class=\"line\">queue2.unshift(<span class=\"number\">2</span>)</div><div class=\"line\">queue2.unshift(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// 出队</span></div><div class=\"line\">queue2.pop() <span class=\"comment\">// 1</span></div><div class=\"line\">queue2.pop() <span class=\"comment\">// 2</span></div><div class=\"line\">queue2.pop() <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure><h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。</p><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> requestQueue = []</div><div class=\"line\"><span class=\"keyword\">var</span> XHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method, url, param</span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><p>点击操作的入口函数，先创建请求进队。<br>因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。</p><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myClick</span>(<span class=\"params\">method, url, param</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> len = requestQueue.push(XHR(method, url, param))</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(len === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        update()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>执行的永远是队列中的第一个请求。<br>当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。<br>如果存在未完成的请求，继续调用更新操作。</p><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    requestQueue[<span class=\"number\">0</span>].then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">// request success</span></div><div class=\"line\">        requestQueue.shift()</div><div class=\"line\">        requestQueue.length &amp;&amp; update()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"Promise","path":"api/tags/Promise.json"},{"name":"Request","path":"api/tags/Request.json"},{"name":"HTTP","path":"api/tags/HTTP.json"},{"name":"Queue","path":"api/tags/Queue.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]}