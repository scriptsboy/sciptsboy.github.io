{"title":"java项目下基于webpack的前端开发环境构建","slug":"java-webpack-dev-build","date":"2016-10-13T06:05:56.000Z","updated":"2016-11-12T19:20:21.641Z","comments":true,"path":"api/articles/java-webpack-dev-build.json","excerpt":"<p>标题可能不是很恰当，想不到一个合适的标题来概括我遇到以及解决的问题，暂且这样吧。</p><h2 id=\"项目描述\"><a href=\"#项目描述\" class=\"headerlink\" title=\"项目描述\"></a>项目描述</h2><p>是一个不完全与后端分离的基于 webpack 构建的 Vue 项目。</p><p>项目入口是一个 jsp 页面，其中引用了一些 jsp 模版。我想是因为有一些内容需要后端直出到页面上。<br>该页面上固定引用了 webpack 打包好的 css 及 js 文件路径，当然也加了动态参数用于刷新版本更新后的客户端缓存。</p><p>可以使用 <code>webpack</code> 命令打包，或是用 <code>webpack --progress --colors --watch</code> 命令启动监听模式动态构建。<br>","content":"<p>标题可能不是很恰当，想不到一个合适的标题来概括我遇到以及解决的问题，暂且这样吧。</p><h2 id=\"项目描述\"><a href=\"#项目描述\" class=\"headerlink\" title=\"项目描述\"></a>项目描述</h2><p>是一个不完全与后端分离的基于 webpack 构建的 Vue 项目。</p><p>项目入口是一个 jsp 页面，其中引用了一些 jsp 模版。我想是因为有一些内容需要后端直出到页面上。<br>该页面上固定引用了 webpack 打包好的 css 及 js 文件路径，当然也加了动态参数用于刷新版本更新后的客户端缓存。</p><p>可以使用 <code>webpack</code> 命令打包，或是用 <code>webpack --progress --colors --watch</code> 命令启动监听模式动态构建。<br><a id=\"more\"></a></p><p>这让前端开发环境变的不够友好：监听模式下修改文件后，是需要通过刷新页面获取更改的。<br>好像回到了传统的前端开发环境中。</p><h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>由于入口页面是由后端渲染 jsp 生成的，用 <code>html-webpack-plugin</code> 插件生成 html 并注入脚本、样式的法子行不通了。</p><p>热替换感觉没戏了，就想办法加个自动刷新吧。</p><h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3><p>开始用 <code>webpack-dev-server</code> 代理后端服务器，可以实现监听更改、实时构建，但由于页面上的页面样式脚本引用与 webpack 构建好的文件路径匹配不上，还是获取不到更改。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpackDevServer = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-server'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> webpackDevServer(webpack(config), &#123;</div><div class=\"line\">    <span class=\"attr\">hot</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">quiet</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">stats</span>: &#123; </div><div class=\"line\">        <span class=\"attr\">chunks</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">        <span class=\"attr\">colors</span>: <span class=\"literal\">true</span> </div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">proxy</span>: &#123;</div><div class=\"line\">        <span class=\"string\">'**'</span>: <span class=\"string\">'http://localhost:8080'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">historyApiFallback</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">server.listen(<span class=\"number\">3000</span>)</div></pre></td></tr></table></figure><p>跑了 3000 端口，页面上的文件引用依然是 8080 端口，好像是在后端就写死了。即使是我临时改了 jsp 文件的引用路径，还是需要手动刷新下页面才能获取更改。</p><h3 id=\"browsersync\"><a href=\"#browsersync\" class=\"headerlink\" title=\"browsersync\"></a>browsersync</h3><p>想起了 gulp 时代一直用的 <code>browsersync</code>，用它代理后端服务，监听文件变更并执行 <code>webpack</code> 命令，刷新浏览器。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'shelljs/global'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> bs = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create()</div><div class=\"line\"></div><div class=\"line\">bs.init(&#123;</div><div class=\"line\">    <span class=\"attr\">proxy</span>: <span class=\"string\">'http://localhost:8080'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">bs.watch(<span class=\"string\">'./src/**/*.*'</span>).on(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    exec(<span class=\"string\">'webpack'</span>, bs.reload)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>但这样每次执行 <code>webpack</code> 命令，都相当于全新编译，所以速度很慢。以该项目而言，每次更改后需要等待 6s 才刷新浏览器。</p><p>还实验了 gulp + webpack-stream，属于换汤不换药，每次还是全新编译。</p><p>今天忽然想到，直接用 webpack 的监听模式启动，在每次编译后刷新浏览器就可以了。监听模式下，只有第一次是全新编译，之后会缓存未变化的模块，所以速度很快。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> webpackDevServer = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-server'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.config'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> bs = <span class=\"built_in\">require</span>(<span class=\"string\">'browser-sync'</span>).create()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(config)</div><div class=\"line\"></div><div class=\"line\">bs.init(&#123;</div><div class=\"line\">    <span class=\"attr\">proxy</span>: <span class=\"string\">'http://localhost:8080'</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">compiler.watch(&#123; </div><div class=\"line\">    <span class=\"attr\">aggregateTimeout</span>: <span class=\"number\">300</span>,      <span class=\"comment\">// 300ms 内的文件更改聚合到一次构建中</span></div><div class=\"line\">    ignored: <span class=\"regexp\">/node_modules/</span>,    <span class=\"comment\">// 忽略大文件或基本不会变更的目录</span></div><div class=\"line\">    poll: <span class=\"literal\">true</span>                  </div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    bs.reload()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(stats.toString(&#123;</div><div class=\"line\">        <span class=\"attr\">chunks</span>: <span class=\"literal\">false</span>, </div><div class=\"line\">        <span class=\"attr\">colors</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;))</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>监听模式除了命令行启动外，也可以使用 <code>watch</code> 方法调用，还可以通过 <code>ignored</code> 配置项忽略一些不会变更的目录。<br>之后每次保存文件，只需要 100ms 左右就会刷新浏览器。</p><h2 id=\"感叹一句\"><a href=\"#感叹一句\" class=\"headerlink\" title=\"感叹一句\"></a>感叹一句</h2><blockquote><p>如今的前端把多少时间都耗在环境搭建上了~</p></blockquote>","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"jsp","path":"api/tags/jsp.json"},{"name":"Webpack","path":"api/tags/Webpack.json"},{"name":"BrowserSync","path":"api/tags/BrowserSync.json"}]}