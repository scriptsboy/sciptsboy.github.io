{"title":"Require.js入门--用面向对象语言来理解js模块化","slug":"js-module-requirejs","date":"2015-08-07T02:33:25.000Z","updated":"2016-11-12T19:21:48.683Z","comments":true,"path":"api/articles/js-module-requirejs.json","excerpt":"<p>作为一个曾经的后端开发者，当我第一眼看到一些javascript模块化的代码案例时，我就想到了java、c#这些天生的模块化语言。<br>今天就拿 require.js 来捋一捋这其中的异同。<br>","content":"<p>作为一个曾经的后端开发者，当我第一眼看到一些javascript模块化的代码案例时，我就想到了java、c#这些天生的模块化语言。<br>今天就拿 require.js 来捋一捋这其中的异同。<br><a id=\"more\"></a></p><h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>一个基本的javascript模块，应该是隐藏私有成员及方法，暴漏外部调用的所需的接口。<br>常见的写法有：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prop = <span class=\"string\">''</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> tool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p</span>)</span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  &#125;;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">fn</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      tool(prop);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure><p>在以上代码中，外部环境无法读取和修改变量<code>prop</code>和方法<code>tool</code>，但是该模块返回了一个公开的对象，并有一个可执行的方法<code>fn</code>。</p><p>这不就相当于面向对象编程中的封装吗？<br>在以上代码中使用了闭包来隔离变量作用域，而像java中可以使用<code>public</code>、<code>private</code>这样的关键字来定义成员。</p><h2 id=\"require-js入门\"><a href=\"#require-js入门\" class=\"headerlink\" title=\"require.js入门\"></a>require.js入门</h2><p>刚才通过一段简单的代码理解了模块化的作用，下面来看看require.js是如何定义和调用模块的。</p><h3 id=\"页面加载\"><a href=\"#页面加载\" class=\"headerlink\" title=\"页面加载\"></a>页面加载</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">data-main</span>=<span class=\"string\">\"main\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://cdn.bootcss.com/require.js/2.1.20/require.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure><p>在页面中插入了require.js文件，使用<code>data-main</code>指定主模块或者叫入口模块，我理解为java中的<code>main()</code>方法。<br><code>data-main</code>属性可以写模块文件的路径，在require.js中默认的后缀<code>.js</code>可省略。</p><h3 id=\"入口模块\"><a href=\"#入口模块\" class=\"headerlink\" title=\"入口模块\"></a>入口模块</h3><p>如果我们的页面非常简单的话，在入口模块中可以写我们的js代码。<br>比如：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello require.js!'</span>);</div></pre></td></tr></table></figure><p>此时刷新页面就会直接在控制台输出<code>Hello require.js!</code>。<br>当然如果是这样的话，也就没必要用require.js了。</p><p>正常的写法一般是这样的：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'module1'</span>, <span class=\"string\">'module2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module1, module2</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>第一个参数数组表示依赖的模块名，然后在其后的回调函数中就可以使用这些模块。</p><h3 id=\"加载模块\"><a href=\"#加载模块\" class=\"headerlink\" title=\"加载模块\"></a>加载模块</h3><p>当然，不可能凭空使用模块，按照常规肯定需要某个地方指定模块加载路径吧。</p><p>在主模块头部可作以下配置：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</div><div class=\"line\">  <span class=\"attr\">paths</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'module1'</span>: <span class=\"string\">'js/module1'</span>,</div><div class=\"line\">    <span class=\"string\">'module2'</span>: <span class=\"string\">'js/module2'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>如果所有模块都在同一个目录则可以配置<code>baseUrl</code>。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</div><div class=\"line\">  <span class=\"attr\">baseUrl</span>: <span class=\"string\">'js'</span>,</div><div class=\"line\">  <span class=\"attr\">paths</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'module1'</span>: <span class=\"string\">'module1'</span>,</div><div class=\"line\">    <span class=\"string\">'module2'</span>: <span class=\"string\">'module2'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>也可以直接使用URL配置远程文件链接。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</div><div class=\"line\">  <span class=\"attr\">paths</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'jquery'</span>: <span class=\"string\">'http://cdn.bootcss.com/jquery/2.1.4/jquery'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>与java中的导包的作用类似，<code>import xxx.xxx.xxx;</code>。</p><h3 id=\"定义模块\"><a href=\"#定义模块\" class=\"headerlink\" title=\"定义模块\"></a>定义模块</h3><p>目前常见的的js模块规范有<code>CMD</code>、<code>AMD</code>、<code>CommonJS</code>以及兼容性写法的<code>UMD</code>，require.js是实现了AMD规范的js库。</p><p>定义一个模块<code>tool</code>，如下写法：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> msg = <span class=\"string\">'The Hello at tool.'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">hello</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>如果该模块依赖其他模块，如jquery，就需要定义模块依赖。如入口模块的定义一样，第一个参数写成模块名数组。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'[jquery]'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">$</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> msg = <span class=\"string\">'The Hello at tool.'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">hello</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(msg);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log($ === <span class=\"literal\">undefined</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>依赖的模块依然需要在入口模块中配置加载路径，但不是必须要在入口模块中注入。</p><p>在这个模块中我们发现了这段代码与一开始的基本模块写法类似，一样是只暴漏必须的调用接口。</p><p>现在可以在入口模块中调用这个模块：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'tool'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">t</span>)</span>&#123;</div><div class=\"line\">  t.hello();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure><p>如果jquery加载正确的话，控制台会输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">The Hello at tool.</div><div class=\"line\">false</div></pre></td></tr></table></figure><p>好了，现在可以去更新简历在技能上加上require.js了！</p><h2 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h2><p>各种模块化规范殊途同归，都是为了解决同样的问题。理解了其中一种，都可以轻松掌握其他规范的写法。<br>未来我们还有天然支持类和模块的ES6，期待吧？</p><p>我一直认为好的开发人员不应该局限于一个技术栈，因为这样会阻碍你对一个问题的全面认知和对新知识的快速领会。</p>","categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"模块化","path":"api/tags/模块化.json"},{"name":"Require.js","path":"api/tags/Require.js.json"}]}