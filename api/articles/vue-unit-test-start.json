{"title":"Vue单元测试起步","slug":"vue-unit-test-start","date":"2016-11-10T03:08:14.000Z","updated":"2017-08-20T13:57:23.874Z","comments":true,"path":"api/articles/vue-unit-test-start.json","excerpt":"<p>最近在搭建一个项目的前端开发环境，准备趁此把一些没用过的东西尝试下，比如：单元测试。<br>使用<code>vue-cli</code>可以直接生成一个包含<code>unit</code>、<code>e2e</code>测试的开发环境，不过还是需要去了解其中的组织结构、配置和模块的使用等。</p><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>没有一点相关经验，先把<code>vue-cli</code>生成后的<code>test/unit</code>目录拿到自己的项目中。<br>","content":"<p>最近在搭建一个项目的前端开发环境，准备趁此把一些没用过的东西尝试下，比如：单元测试。<br>使用<code>vue-cli</code>可以直接生成一个包含<code>unit</code>、<code>e2e</code>测试的开发环境，不过还是需要去了解其中的组织结构、配置和模块的使用等。</p><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>没有一点相关经验，先把<code>vue-cli</code>生成后的<code>test/unit</code>目录拿到自己的项目中。<br><a id=\"more\"></a></p><p><code>test</code> 目录结构:</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">└─ test</div><div class=\"line\">    └─ unit</div><div class=\"line\">        ├─ specs</div><div class=\"line\">        ├─ .eslintrc</div><div class=\"line\">        ├─ index.js</div><div class=\"line\">        └─ karma.conf.js</div></pre></td></tr></table></figure><p>之后在<code>package.json</code>中找到<code>karma</code>相关的模块。</p><ul><li><a href=\"http://karma-runner.github.io/0.13/index.html\" target=\"_blank\" rel=\"external\">karma</a> 一个 JavaScript 测试运行器，其在测试中的作用相当于开发构建中使用的<code>webpack</code>。</li><li><a href=\"https://github.com/webpack/karma-webpack\" target=\"_blank\" rel=\"external\">karma-webpack</a> 连接<code>karma</code>和<code>webpack</code>的桥梁。不经过<code>webpack</code>编译命令是文件是无法独立运行的，<code>karma</code>需要了解你的<code>webpack</code>配置，决定如何处理你的测试文件。</li><li><a href=\"https://github.com/karma-runner/karma-phantomjs-launcher\" target=\"_blank\" rel=\"external\">karma-phantomjs-launcher</a> 是<code>phantomjs</code>在<code>karma</code>中的启动器，由此引出了<code>phantomjs</code>。<a href=\"https://github.com/ariya/phantomjs\" target=\"_blank\" rel=\"external\">PhantomJS</a> 是一个没有界面的 “浏览器” ，内置了 JavaScript API，支持各种Web标准：DOM 处理、CSS 选择器、JSON、Canvas 和 SVG 等。在查找相关资料时，也发现了其他的常规浏览器<code>launcher</code>，比如：Chrome、Firefox、Safari、IE 等，以应对不同浏览器或多浏览器的测试需求。见<a href=\"http://karma-runner.github.io/0.13/config/browsers.html\" target=\"_blank\" rel=\"external\">Browsers</a></li><li><a href=\"https://github.com/demerzel3/karma-sourcemap-loader\" target=\"_blank\" rel=\"external\">karma-sourcemap-loader</a> <code>Karma</code>插件，生成文件的<code>sourcemap</code>。</li><li><a href=\"https://github.com/karma-runner/karma-mocha\" target=\"_blank\" rel=\"external\">karma-mocha</a> 让你在 karma 中使用 <a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">Mocha</a> 测试框架的插件，使用时还需要安装前置依赖<code>mocha</code>。</li><li><a href=\"https://github.com/domenic/sinon-chai\" target=\"_blank\" rel=\"external\">karma-sinon-chai</a> 让你在<code>karma</code>中使用<code>sinon-chai</code>断言库的插件，前置依赖有<code>sinon-chai</code>、<code>sinon</code>、<code>chai</code>…😕</li><li><a href=\"https://github.com/mlex/karma-spec-reporter\" target=\"_blank\" rel=\"external\">karma-spec-reporter</a> 用于将测试结果显示到控制台。</li><li><a href=\"https://github.com/karma-runner/karma-coverage\" target=\"_blank\" rel=\"external\">karma-coverage</a> 生成代码覆盖率。</li></ul><p>其中要使用<code>karma-phantomjs-launcher</code>，需要先安装<code>PhantomJS</code>，通过<code>phantomjs-prebuilt</code>安装。</p><p>看到这一大堆依赖，感觉面前又是一个不亚于 Webpack 的技术栈。之所以去了解每个模块的用处，就是为了在学习的时候直插心脏，忽略那些不重要的模块。<br>以上来说，Karma 是基本的运行器，需要了解其配置和使用。测试框架 Mocha 和断言库 sinon-chai 类似于开发中使用的 Lodash，提供一系列用于测试的工具函数。剩下的按示例集成就好。</p><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>整合一条命令。</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm i -D karma karma-webpack phantomjs-prebuilt karma-phantomjs-launcher karma-sourcemap-loader mocha karma-mocha sinon chai sinon-chai karma-sinon-chai karma-spec-reporter karma-coverage</div></pre></td></tr></table></figure><p>PhantomJS 安装比较慢，也可以去其<a href=\"http://phantomjs.org/download.html\" target=\"_blank\" rel=\"external\">官网下载</a>，并手动<a href=\"http://phantomjs.org/build.html\" target=\"_blank\" rel=\"external\">配置环境变量</a>。</p><p>安装好了，先跑一下看看是否安装正确，到<code>package.json</code>的<code>scripts</code>中注册一个命令：<code>&quot;unit&quot;: &quot;karma start test/unit/karma.conf.js --single-run&quot;</code>，然后运行。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">npm run unit</div></pre></td></tr></table></figure><p>然后不出意料的报错了，只是少装了一个模块<code>isparta-loader</code>，是一个代码覆盖工具，继续安装后运行OK。</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/vue-unit-1.jpg\" alt=\"vue-unit-1\"></div><div class=\"image-caption\">vue-unit-1</div></figure><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>karma.conf.js 文件内容分为两部分。<br><code>module.exports</code> 以上是对 Webpack 配置的处理，像<code>webpack.dev.conf</code>和<code>webpack.prod.conf</code>那样，在不同的环境里使用不同的配置。后一部分就是对 Karma 的配置了。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">config</span>) </span>&#123;</div><div class=\"line\">    config.set(&#123;</div><div class=\"line\">        <span class=\"comment\">// 要启动的测试浏览器</span></div><div class=\"line\">        browsers: [<span class=\"string\">'PhantomJS'</span>],</div><div class=\"line\">        <span class=\"comment\">// 测试框架</span></div><div class=\"line\">        frameworks: [<span class=\"string\">'mocha'</span>, <span class=\"string\">'sinon-chai'</span>],</div><div class=\"line\">        <span class=\"comment\">// 测试报告处理</span></div><div class=\"line\">        reporters: [<span class=\"string\">'spec'</span>, <span class=\"string\">'coverage'</span>],</div><div class=\"line\">        <span class=\"comment\">// 要测试的目标文件</span></div><div class=\"line\">        files: [<span class=\"string\">'./index.js'</span>],</div><div class=\"line\">        <span class=\"comment\">// 忽略的文件</span></div><div class=\"line\">        exclude: [],</div><div class=\"line\">        <span class=\"comment\">// 预处理文件</span></div><div class=\"line\">        preprocessors: &#123;</div><div class=\"line\">            <span class=\"string\">'./index.js'</span>: [<span class=\"string\">'webpack'</span>, <span class=\"string\">'sourcemap'</span>]</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"comment\">// webpack</span></div><div class=\"line\">        webpack: webpackConfig,</div><div class=\"line\">        <span class=\"attr\">webpackMiddleware</span>: &#123;</div><div class=\"line\">            <span class=\"attr\">noInfo</span>: <span class=\"literal\">true</span></div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"comment\">// Coverage options</span></div><div class=\"line\">        coverageReporter: &#123;</div><div class=\"line\">            <span class=\"attr\">dir</span>: <span class=\"string\">'./coverage'</span>,</div><div class=\"line\">            <span class=\"attr\">reporters</span>: [</div><div class=\"line\">                &#123; <span class=\"attr\">type</span>: <span class=\"string\">'lcov'</span>, <span class=\"attr\">subdir</span>: <span class=\"string\">'.'</span> &#125;,</div><div class=\"line\">                &#123; <span class=\"attr\">type</span>: <span class=\"string\">'text-summary'</span> &#125;</div><div class=\"line\">            ]</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"comment\">// true: 自动运行测试并退出</span></div><div class=\"line\">        <span class=\"comment\">// false: 监控文件持续测试</span></div><div class=\"line\">        singleRun: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 以下是 vue-cli 没有生成的一些配置</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 文件匹配的起始路径</span></div><div class=\"line\">        <span class=\"comment\">// basePath: '',</span></div><div class=\"line\">        <span class=\"comment\">// 服务器端口</span></div><div class=\"line\">        <span class=\"comment\">// port: 9876,</span></div><div class=\"line\">        <span class=\"comment\">// 输出着色</span></div><div class=\"line\">        <span class=\"comment\">// colors: true,</span></div><div class=\"line\">        <span class=\"comment\">// 日志级别</span></div><div class=\"line\">        <span class=\"comment\">// LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG</span></div><div class=\"line\">        <span class=\"comment\">// logLevel: config.LOG_INFO,</span></div><div class=\"line\">        <span class=\"comment\">// 监控文件更改</span></div><div class=\"line\">        <span class=\"comment\">// autoWatch: true,</span></div><div class=\"line\">        <span class=\"comment\">// 超时处理，6s内没有捕获浏览器将终止进程</span></div><div class=\"line\">        <span class=\"comment\">// captureTimeout: 6000</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><p>其中对于测试文件入口有点难以理解，仅仅是一个脚本文件，而不是路径匹配，也就是配置文件同级的那个<code>index.js</code>，只有 5 行代码。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"built_in\">require</span>(<span class=\"string\">'function-bind'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> testsContext = <span class=\"built_in\">require</span>.context(<span class=\"string\">'./specs'</span>, <span class=\"literal\">true</span>, /\\.spec$/)</div><div class=\"line\">testsContext.keys().forEach(testsContext)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> srcContext = <span class=\"built_in\">require</span>.context(<span class=\"string\">'../../src'</span>, <span class=\"literal\">true</span>, /^\\.\\/(?!main(\\.js)?$)/)</div><div class=\"line\">srcContext.keys().forEach(srcContext)</div></pre></td></tr></table></figure><p>看起来如果使用了高版本的 NodeJs 第一行代码是可以去掉了。</p><ul><li><code>testsContext</code>匹配的是<code>specs</code>目录，里面是存放的是测试用例；</li><li><code>srcContext</code>匹配的是<code>src</code>目录，从正则上看是除了<code>main.js</code>以外的所有文件。</li></ul><p>也就是说，也可以通过脚本文件这种方式设置匹配的目标文件。</p><h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>现在看起来一切妥当了，可以开始写测试用例了。</p><p>把以上步骤又重复了一遍，集成到了一个自己写的 Demo 项目中，然后运行测试。</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/vue-unit-2.jpg\" alt=\"vue-unit-2\"></div><div class=\"image-caption\">vue-unit-2</div></figure><p>什么鬼，找不到 <code>less</code> 变量。</p><p>为了验证不是配置问题，我在 vue-cli 生成项目的组件中使用 less 写了个样式，运行测试出现了一样的问题。<br>最后找到了这条<a href=\"https://github.com/vuejs-templates/webpack/issues/163\" target=\"_blank\" rel=\"external\">issue</a>。<br>翻译了半天，感觉是匹配文件的问题。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> srcContext = <span class=\"built_in\">require</span>.context(<span class=\"string\">'../../src'</span>, <span class=\"literal\">true</span>, /^\\.\\/(?!main(\\.js)?$)/)</div></pre></td></tr></table></figure><p>原来的正则会匹配除了<code>main.js</code>以外的所有文件，所以样式文件也会被匹配上。使用 less 时一般只有一个变量文件，然后从一个 less 出口文件中解析，而单元测试本身做的工作是单文件测试，单个 less 文件肯定是找不到变量的。<br>不过样式本身是不会对逻辑产生影响的，可以不参与测试，干脆直接锁定目标文件后缀，也就是 vue 组件。</p><p>修改如下：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> srcContext = <span class=\"built_in\">require</span>.context(<span class=\"string\">'../../src'</span>, <span class=\"literal\">true</span>, /\\.vue$/)</div></pre></td></tr></table></figure><p>刚翻过一座山，又遇到一条河。</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/vue-unit-3.jpg\" alt=\"vue-unit-3\"></div><div class=\"image-caption\">vue-unit-3</div></figure><p>看起来是因为 API 不兼容，PhantomJS 中还没有集成 Promise。</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/vue-unit-4.jpg\" alt=\"vue-unit-4\"></div><div class=\"image-caption\">vue-unit-4</div></figure><p>为了避免相似的问题，索性把 launcher 换掉了，用<code>karma-chrome-launcher</code>。<br>安装后，更改 Karma 配置中的<code>browsers</code>属性值为<code>[&#39;Chrome&#39;]</code>，测试运行成功。</p><figure class=\"image-bubble\"><div class=\"img-lightbox\"><div class=\"overlay\"></div><img src=\"http://static.imys.net/vue-unit-5.png\" alt=\"vue-unit-5\"></div><div class=\"image-caption\">vue-unit-5</div></figure><p>有一些青色的 LOG，第一条使用 Vue 的应该都已经熟悉了，是浏览器控制台输出的 LOG，所以其他的也是浏览器的日志了。</p><p>第 1、3、4 条 LOG 是有一个指令没有找到，第 2 条是关于路由的。指令和路由的引入是在项目入口的 js 文件内，可以预知如果我使用了其他类别的 Vue 插件也会报出 ERROR。<br>还是有问题要解决啊！😒</p><h2 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h2><p>初次接触测试框架和断言，对于组件的测试用例也还在摸索中。<br>从例子上看，大概思路如下：</p><ol><li>引入一个组件；</li><li>创建一个用于测试的 Vue 实例，然后组件挂上去；</li><li>对实例进行模拟操作，然后断言期望值。</li></ol><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> SearchView <span class=\"keyword\">from</span> <span class=\"string\">'src/components/SearchView'</span></div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'SearchView.vue'</span>, () =&gt; &#123;</div><div class=\"line\">    it(<span class=\"string\">'Input is normal'</span>, () =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">            <span class=\"attr\">el</span>: <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>),</div><div class=\"line\">            <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> h(SearchView)</div><div class=\"line\">        &#125;)</div><div class=\"line\"></div><div class=\"line\">        vm.key = <span class=\"string\">'曾经的你'</span></div><div class=\"line\"></div><div class=\"line\">        vm.$nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            expect(vm.$el.querySelector(<span class=\"string\">'.m-key'</span>).textContent).to.equal(<span class=\"string\">'曾经的你'</span>)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><p>实际的项目中，针对复杂的逻辑或者异步操作，测试一定不会这么简单。😅<br>下一步准备找一些 Vue 的开源项目，学习一下其中的测试用例写法。</p><p>End!</p>","categories":[],"tags":[{"name":"Vue","path":"api/tags/Vue.json"},{"name":"Unit test","path":"api/tags/Unit test.json"},{"name":"单元测试","path":"api/tags/单元测试.json"},{"name":"Karma","path":"api/tags/Karma.json"},{"name":"Phantomjs","path":"api/tags/Phantomjs.json"}]}